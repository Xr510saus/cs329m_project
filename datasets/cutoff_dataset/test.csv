line,code,label
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;",1
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());",1
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;",1
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;",1
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);",1
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrMan::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	return m_impl->Select(new_only, networks);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);",1
Side effect free?,"void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& anchors)	{	LOG_TIME_SECONDS(strprintf(""Flush %d outbound block-relay-only peer addresses to anchors.dat"", anchors.size()));	SerializeFileDB(""anchors"", anchors_db_path, CAddress::V2_DISK(anchors));",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {",1
Side effect free?,"bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	LOCK(cs);	Check();	auto ret = Add_(vAddr, source, time_penalty);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;",1
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());",1
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;",1
Side effect free?,bool is_initialized = false;		void initialize() {	is_initialized = true;,1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;",1
Side effect free?,int* createMem() {	int* placeholder = new int{42};,1
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);",1
Side effect free?,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);",1
Side effect free?,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);",1
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);",1
Side effect free?,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);",1
Side effect free?,int get_next_id() {	static int id = 0;	return ++id;,1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");",1
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;",1
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;",1
Side effect free?,bool isPalindrome(const string &s) {,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);",0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}	",0
Side effect free?,"void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env",0
Side effect free?,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");",0
Side effect free?,"size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	LOCK(cs);	Check();	auto ret = Size_(net, in_new);	Check();	return ret;	}",0
Side effect free?,class myClass {	public:	int publicint;,0
Side effect free?,void printVar(auto var_to_print) { // printing	cout << var_to_print << endl;	},0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),",0
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {",0
Side effect free?,void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);,0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>",0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}	",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {",0
Side effect free?,"bool AddrMan::Good(const CService& addr, NodeSeconds time)	{	return m_impl->Good(addr, time);	}",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests",0
Side effect free?,bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;,0
Side effect free?,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {",0
Side effect free?,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const	{",0
Side effect free?,Delegate* AutoUpdater::GetDelegate() {,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);",0
Side effect free?,CScript operator()(const PubKeyDestination& dest) const,0
Side effect free?,int get_next_id() {	static int id = 0;,0
Side effect free?,class myClass {	public:	int publicint;		void changeMut() { // SEF,0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {",0
Side effect free?,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {",0
Side effect free?,class myClass {	public:,0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)",0
Side effect free?,"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {	LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);	}	return added > 0;",0
Side effect free?,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}	}",0
Side effect free?,void netNothing() {,0
Side effect free?,"bool AddrMan::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	return m_impl->Add(vAddr, source, time_penalty);	}",0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;",0
Side effect free?,double average(const std::vector<int>& numbers) {	if (numbers.empty()) return 0.0;	int sum = 0;	for (int num : numbers) {	sum += num;	}	return static_cast<double>(sum) / numbers.size();,0
Side effect free?,void changeWithin(int changed) {,0
Side effect free?,"bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;		const auto& c_locale = std::locale::classic();	const auto isspace = [&](auto ch) { return std::isspace(ch, c_locale); };	const auto scheme = arg.substr(0U, scheme_end);	return std::size(scheme) > 1U && std::isalpha(scheme.front(), c_locale) &&",0
Side effect free?,"int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const	{	std::vector<unsigned char> vchSourceGroupKey = netgroupman.GetGroup(src);	uint64_t hash1 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << vchSourceGroupKey).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_NEW_BUCKET_COUNT;	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)",0
Side effect free?,bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');,0
Side effect free?,"int AddrInfo::GetBucketPosition(const uint256& nKey, bool fNew, int bucket) const	{",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}	",0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)",0
Side effect free?,"int gcd(int a, int b) {	while (b != 0) {	int temp = b;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}	",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];",0
Side effect free?,bool isPalindrome(const string &s) {	int len = s.size();	for (int i = 0; i < len / 2; ++i) {,0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);",0
Side effect free?,void changeWithin(int changed) {	changed = 5;	},0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif	",0
Side effect free?,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args),0
Side effect free?,void AddrManImpl::Delete(nid_type nId),0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;",0
Side effect free?,int NodeMain() {,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);	",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;",0
Side effect free?,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()	{	LOCK(cs);	Check();	auto ret = SelectTriedCollision_();	Check();	return ret;",0
Side effect free?,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);	has = true;	}	}	return has;	},0
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.",0
Side effect free?,"bool AddrManImpl::Good(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	auto ret = Good_(addr, /*test_before_evict=*/true, time);	Check();	return ret;	}",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {",0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;",0
Side effect free?,"CScript GetScriptForDestination(const CTxDestination& dest)	{	return std::visit(CScriptVisitor(), dest);",0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);	",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};",0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;",0
Side effect free?,bool is_prime(int n) {	if (n <= 1) return false;	for (int i = 2; i * i <= n; ++i) {,0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	LOCK(cs);",0
Side effect free?,"bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;		const auto& c_locale = std::locale::classic();	const auto isspace = [&](auto ch) { return std::isspace(ch, c_locale); };",0
Side effect free?,CScript operator()(const ScriptHash& scriptID) const	{,0
Side effect free?,void AddrManImpl::ResolveCollisions()	{	LOCK(cs);	Check();	ResolveCollisions_();	Check();,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;",0
Side effect free?,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}	",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];",0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});",0
Side effect free?,CScript operator()(const PKHash& keyID) const,0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),",0
Side effect free?,"bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr)	{	const auto pathAddr = args.GetDataDirNet() / ""peers.dat"";",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {",0
Side effect free?,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT,0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);",0
Side effect free?,int incrementedNotLocal() {	x++;	return x;	},0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;	",0
Side effect free?,"void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)	{	LOCK(cs);	Check();	SetServices_(addr, nServices);	Check();	}",0
Side effect free?,"bool AddrManImpl::Good(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;	",0
Side effect free?,"bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	LOCK(cs);	Check();	auto ret = Add_(vAddr, source, time_penalty);	Check();",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}	",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}	",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);",0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	},0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());	",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());	",0
Side effect free?,//SEF	,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())",0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};	",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);	",0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.",0
Side effect free?,int main() {,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));",0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);	",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{",0
Side effect free?,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	},0
Side effect free?,void clear_list(std::vector<int>& numbers) {	numbers.clear();	},0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}	",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables",0
Side effect free?,"int gcd(int a, int b) {	while (b != 0) {	int temp = b;	b = a % b;	a = temp;",0
Side effect free?,bool IsUrlArg(const base::CommandLine::StringViewType arg) {,0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();",0
Side effect free?,std::optional<AddressPosition> AddrMan::FindAddressEntry(const CAddress& addr)	{	return m_impl->FindAddressEntry(addr);	},0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());",0
Side effect free?,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}	",0
Side effect free?,int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());	,0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};",0
Side effect free?,"int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const	{",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to",0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",",0
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}",0
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);",0
Side effect free?,"v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {	std::map<std::string, std::string> keys;	#if !IS_MAS_BUILD()	electron::crash_keys::GetCrashKeys(&keys);	#endif	return gin::ConvertToV8(isolate, keys);	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()",0
Side effect free?,double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;,0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) """,0
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {",0
Side effect free?,double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;	,0
Side effect free?,CScript operator()(const PKHash& keyID) const	{	return CScript() << OP_DUP << OP_HASH160 << ToByteVector(keyID) << OP_EQUALVERIFY << OP_CHECKSIG;	},0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |",0
Side effect free?,bool is_positive(int x) {,0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}	",0
