line,code,label
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();",1
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());",1
Side effect free?,void JustThrow()	{	throw 0;,1
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);",1
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;",1
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};",1
Side effect free?,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;",1
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();",1
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);",1
Side effect free?,"std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	return m_impl->GetAddr(max_addresses, max_pct, network, filtered);",1
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;",1
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);",1
Side effect free?,"void read_user_input(int& input) {	std::cout << ""Enter a number: "";",1
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;",1
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());",1
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;",1
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {",1
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;",1
Side effect free?,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));",1
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	LOCK(cs);	Check();	auto addresses = GetAddr_(max_addresses, max_pct, network, filtered);",1
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;",1
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;",1
Side effect free?,bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {,1
Side effect free?,"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {	LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);",1
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;",1
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);",1
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;",1
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));",1
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);,1
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);",1
Side effect free?,void setSix(){ // setting global variable	x = 6;,1
Side effect free?,"bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr)	{	const auto pathAddr = args.GetDataDirNet() / ""peers.dat"";	return SerializeFileDB(""peers"", pathAddr, addr);",1
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);",1
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();",1
Side effect free?,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();",1
Side effect free?,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);",1
Side effect free?,"v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {	std::map<std::string, std::string> keys;	#if !IS_MAS_BUILD()	electron::crash_keys::GetCrashKeys(&keys);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");",1
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;",1
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;",1
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);",1
Side effect free?,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;",1
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);",1
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);",1
Side effect free?,void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);,1
Side effect free?,void AddrManImpl::ResolveCollisions()	{	LOCK(cs);	Check();	ResolveCollisions_();,1
Side effect free?,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;,1
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(",1
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);",1
Side effect free?,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));",1
Side effect free?,"void ReadFromStream(AddrMan& addr, DataStream& ssPeers)	{	DeserializeDB(ssPeers, addr, false);",1
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;",1
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()	{	LOCK(cs);	Check();	auto ret = SelectTriedCollision_();",1
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;",1
Side effect free?,"void AddrMan::Connected(const CService& addr, NodeSeconds time)	{	m_impl->Connected(addr, time);",1
Side effect free?,void clear_list(std::vector<int>& numbers) {	numbers.clear();,1
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);",1
Side effect free?,AddrManImpl::~AddrManImpl()	{	nKey.SetNull();,1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();",1
Side effect free?,void incrementGlobal() {	++x;,1
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;",1
Side effect free?,void AddrMan::ResolveCollisions()	{	m_impl->ResolveCollisions();,1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);",1
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",",1
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();",1
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));",1
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();",1
Side effect free?,void freeMem(int* memory) {	delete memory;,1
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",",1
Side effect free?,void setFive(int& var_to_set) { // setting variable passed in by reference	var_to_set = 5;,1
Side effect free?,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);",1
Side effect free?,"void write_to_file(const std::string& filename, const std::string& content) {	std::ofstream file(filename);	if (file.is_open()) {	file << content;",1
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;",1
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;",1
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;",1
Side effect free?,"void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& anchors)	{	LOG_TIME_SECONDS(strprintf(""Flush %d outbound block-relay-only peer addresses to anchors.dat"", anchors.size()));",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);",1
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(",1
Side effect free?,"std::unordered_map<int, std::string> database;		void update_record(int id, const std::string& new_value) {	database[id] = new_value;",1
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());",1
Side effect free?,"WitnessV0ScriptHash::WitnessV0ScriptHash(const CScript& in)	{	CSHA256().Write(in.data(), in.size()).Finalize(begin());",1
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();",1
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;",1
Side effect free?,"void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};	if (filein.IsNull()) {	throw DbNotFoundError{};",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(",1
Side effect free?,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);,1
Side effect free?,void indirectPointChange(const int* cpoint) {	*const_cast<int*>(cpoint) = 5;,1
Side effect free?,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);",1
Side effect free?,"float unrelatedNameToo(float& u, float& v) {	float w = (u = v);",1
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);",1
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;",1
Side effect free?,void printVar(auto var_to_print) { // printing	cout << var_to_print << endl;,1
Side effect free?,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {",1
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;",1
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this """,1
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;",1
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(",1
Side effect free?,int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(,1
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);",1
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);",1
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;",1
Side effect free?,int squareGlobal() {	x *= x;,1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());",1
Side effect free?,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();",1
Side effect free?,class Counter {	public:	void increment() {	count++;,1
Side effect free?,"void AddrMan::SetServices(const CService& addr, ServiceFlags nServices)	{	m_impl->SetServices(addr, nServices);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(",1
Side effect free?,void AutoUpdater::SetDelegate(Delegate* delegate) {	delegate_ = delegate;,1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);",1
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;",1
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;",1
Side effect free?,void indirectRefChange(const int& cref) {	const_cast<int&>(cref) = 5;,1
Side effect free?,"//SE		void add_element(std::vector<int>& numbers, int value) {	numbers.push_back(value);",1
Side effect free?,"void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	LOCK(cs);	Check();	Attempt_(addr, fCountFailure, time);",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(",1
Side effect free?,void squareSelf(int& sSval) {	sSval *= sSval;,1
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	LOCK(cs);	Check();	auto addrRet = Select_(new_only, networks);",1
Side effect free?,"void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)	{	LOCK(cs);	Check();	SetServices_(addr, nServices);",1
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());",1
Side effect free?,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());",1
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);",1
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);",1
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;",1
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");",1
Side effect free?,int incrementedNotLocal() {	x++;,1
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;",1
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;",1
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);",1
Side effect free?,"void changePoint(int* pointed, int& ref) {	pointed = &ref;",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;",1
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");",1
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);",1
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;",1
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));",1
Side effect free?,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();",1
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);",1
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {",1
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;	",1
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;",1
Side effect free?,"bool AddrMan::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	return m_impl->Add(vAddr, source, time_penalty);",1
Side effect free?,"int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;	if (cache.find(n) != cache.end()) return cache[n];		cache[n] = fibonacci(n - 1) + fibonacci(n - 2);",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");",1
Side effect free?,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;",1
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrMan::SelectTriedCollision()	{	return m_impl->SelectTriedCollision();",1
Side effect free?,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;",1
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");",1
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;",1
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);",1
Side effect free?,"// 6. Modifies a global array	int global_array[10] = {0};	void update_global_array(int index, int value) {	if (index >= 0 && index < 10) {	global_array[index] = value;",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");",1
Side effect free?,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;",1
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;",1
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));",1
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;",1
Side effect free?,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;",1
Side effect free?,"void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};	if (filein.IsNull()) {	throw DbNotFoundError{};	}	DeserializeDB(filein, data);",1
Side effect free?,"void read_user_input(int& input) {	std::cout << ""Enter a number: "";	std::cin >> input;",1
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;",1
Side effect free?,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);",1
Side effect free?,// 1. Modifies a global variable	int global_count = 0;	void increment_global_count() {	global_count++;,1
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",",1
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;",1
Side effect free?,"void AddrMan::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	m_impl->Attempt(addr, fCountFailure, time);",1
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;",1
Side effect free?,"void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");",1
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {",1
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};",1
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();",1
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));",1
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;",0
Side effect free?,bool is_prime(int n) {,0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);	",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}	,0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	},0
Side effect free?,bool is_initialized = false;,0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;",0
Side effect free?,void AutoUpdater::CheckForUpdates() {},0
Side effect free?,int modifyPoint(int* points) {,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{",0
Side effect free?,v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;",0
Side effect free?,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	},0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{	LOCK(cs);	Check();	auto entry = FindAddressEntry_(addr);	Check();,0
Side effect free?,void AddrMan::Serialize(Stream& s_) const,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}",0
Side effect free?,"bool SerializeDB(Stream& stream, const Data& data)",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, """,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);	",0
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	},0
Side effect free?,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;",0
Side effect free?,"bool AutoUpdater::IsVersionAllowedForUpdate(const std::string& current_version,	const std::string& target_version) {	return false;",0
Side effect free?,vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {	evens.push_back(num);,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()	{	LOCK(cs);	Check();	auto ret = SelectTriedCollision_();	Check();",0
Side effect free?,"// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content	file.close();	}	return content;",0
Side effect free?,bool is_prime(int n) {	if (n <= 1) return false;,0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];	",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;",0
Side effect free?,void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is,0
Side effect free?,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);	",0
Side effect free?,"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;",0
Side effect free?,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);",0
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};",0
Side effect free?,CScript operator()(const WitnessV0KeyHash& id) const	{	return CScript() << OP_0 << ToByteVector(id);,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());",0
Side effect free?,"bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr)",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;",0
Side effect free?,int absolute_value(int x) {,0
Side effect free?,int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();,0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));",0
Side effect free?,void AddrManImpl::ResolveCollisions()	{,0
Side effect free?,int factorial(int n) {	if (n == 0) {,0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)",0
Side effect free?,int squareReference(int& sRval) { // returning square of input passed in by reference	return sRval * sRval;	},0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about",0
Side effect free?,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());",0
Side effect free?,"int max_of_three(int a, int b, int c) {	return std::max({a, b, c});	}",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;",0
Side effect free?,"void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)	{	LOCK(cs);",0
Side effect free?,"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/",0
Side effect free?,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}	,0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {",0
Side effect free?,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};",0
Side effect free?,"int AddrInfo::GetBucketPosition(const uint256& nKey, bool fNew, int bucket) const	{	uint64_t hash1 = (HashWriter{} << nKey << (fNew ? uint8_t{'N'} : uint8_t{'K'}) << bucket << GetKey()).GetCheapHash();",0
Side effect free?,"int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const	{	std::vector<unsigned char> vchSourceGroupKey = netgroupman.GetGroup(src);	uint64_t hash1 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << vchSourceGroupKey).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_NEW_BUCKET_COUNT;",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {",0
Side effect free?,vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {	evens.push_back(num);	}	}	return evens;	},0
Side effect free?,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg)),0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present",0
Side effect free?,"int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;	if (cache.find(n) != cache.end()) return cache[n];		cache[n] = fibonacci(n - 1) + fibonacci(n - 2);	return cache[n];",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}	",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();	",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);",0
Side effect free?,void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.,0
Side effect free?,CScript operator()(const ScriptHash& scriptID) const	{	return CScript() << OP_HASH160 << ToByteVector(scriptID) << OP_EQUAL;	},0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {",0
Side effect free?,"void AddrMan::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)",0
Side effect free?,bool is_even(int x) {,0
Side effect free?,#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>,0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);	",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);",0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {,0
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{",0
Side effect free?,bool IsValidDestination(const CTxDestination& dest) {,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())",0
Side effect free?,int squareGlobal() {	x *= x;	return x;,0
Side effect free?,vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;,0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address",0
Side effect free?,"void write_to_file(const std::string& filename, const std::string& content) {	std::ofstream file(filename);	if (file.is_open()) {	file << content;	file.close();	}	}",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to",0
Side effect free?,"bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	LOCK(cs);",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	LOCK(cs);	Check();	auto addrRet = Select_(new_only, networks);	Check();	return addrRet;",0
Side effect free?,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];	",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;	",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments",0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{	LOCK(cs);,0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {",0
Side effect free?,"int gcd(int a, int b) {	while (b != 0) {	int temp = b;	b = a % b;",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrMan::SelectTriedCollision()	{	return m_impl->SelectTriedCollision();	}",0
Side effect free?,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};",0
Side effect free?,"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.",0
Side effect free?,void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};,0
Side effect free?,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;,0
Side effect free?,// 6. Modifies a global array	int global_array[10] = {0};,0
Side effect free?,"void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,",0
Side effect free?,void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};	",0
Side effect free?,void netNothing() {	int* temp = new int{42};	delete temp;	},0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;	",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {",0
Side effect free?,void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);,0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;	",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;	",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();	",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}	",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};	",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];",0
Side effect free?,double area_of_circle(double radius) {	return M_PI * radius * radius;,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}	,0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);",0
Side effect free?,"bool IsValidDestination(const CTxDestination& dest) {	return std::visit(ValidDestinationVisitor(), dest);	}",0
Side effect free?,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {,0
Side effect free?,"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {	return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;	} else {",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}",0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Side effect free?,"void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};	if (filein.IsNull()) {",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};	",0
Side effect free?,int* createMem() {	int* placeholder = new int{42};	return placeholder;,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif",0
Side effect free?,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);	return anchors;",0
Side effect free?,void setSix(){ // setting global variable,0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	LOCK(cs);	Check();",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}",0
Side effect free?,double average(const std::vector<int>& numbers) {	if (numbers.empty()) return 0.0;,0
Side effect free?,CKeyID ToKeyID(const WitnessV0KeyHash& key_hash)	{	return CKeyID{uint160{key_hash}};,0
Side effect free?,void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);	,0
Side effect free?,class Counter {	public:	int get_count() const {,0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());",0
Side effect free?,bool IsSandboxEnabled(base::CommandLine* command_line) {,0
Side effect free?,"float unrelatedNameToo(float& u, float& v) {",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};",0
Side effect free?,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests	",0
Side effect free?,void ThrowCatch()	{	try	{	throw 1;,0
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}",0
Side effect free?,AddrManImpl::~AddrManImpl()	{,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}",0
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);	",0
Side effect free?,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;	",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;",0
Side effect free?,void AddrManImpl::Delete(nid_type nId)	{,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;",0
Side effect free?,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);",0
Side effect free?,double average(const std::vector<int>& numbers) {	if (numbers.empty()) return 0.0;	int sum = 0;	for (int num : numbers) {	sum += num;	},0
Side effect free?,void AddrMan::ResolveCollisions()	{,0
Side effect free?,void ThrowCatch()	{	try	{	throw 1;	},0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif	",0
Side effect free?,"void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)",0
Side effect free?,"void SetCrashKeyStub(const std::string& key, const std::string& value) {}",0
Side effect free?,class Counter {	public:	int get_count() const {	return count;	}	,0
Side effect free?,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;",0
Side effect free?,void read_user_input(int& input) {,0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with",0
Side effect free?,"bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;		const auto& c_locale = std::locale::classic();	const auto isspace = [&](auto ch) { return std::isspace(ch, c_locale); };	const auto scheme = arg.substr(0U, scheme_end);	return std::size(scheme) > 1U && std::isalpha(scheme.front(), c_locale) &&	std::ranges::none_of(scheme, isspace);	}",0
Side effect free?,int reverse_number(int num) {	int reversed = 0;	while (num != 0) {	reversed = reversed * 10 + num % 10;	num /= 10;	}	return reversed;	},0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;	",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);	",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrMan::Select(bool new_only, const std::unordered_set<Network>& networks) const	{",0
Side effect free?,// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;,0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;	",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,",0
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.",0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}",0
Side effect free?,CScript operator()(const WitnessV0ScriptHash& id) const,0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	",0
Side effect free?,"bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr)	{	const auto pathAddr = args.GetDataDirNet() / ""peers.dat"";	return SerializeFileDB(""peers"", pathAddr, addr);	}",0
Side effect free?,bool operator()(const PKHash& dest) const { return true; },0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);	",0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{",0
Side effect free?,bool is_prime(int n) {	if (n <= 1) return false;	for (int i = 2; i * i <= n; ++i) {	if (n % i == 0) return false;,0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);",0
Side effect free?,"WitnessV0ScriptHash::WitnessV0ScriptHash(const CScript& in)	{	CSHA256().Write(in.data(), in.size()).Finalize(begin());	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}",0
Side effect free?,void indirectPointChange(const int* cpoint) {,0
Side effect free?,std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{,0
Side effect free?,double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}	,0
Side effect free?,CScriptID ToScriptID(const ScriptHash& script_hash)	{	return CScriptID{uint160{script_hash}};	},0
Side effect free?,int get_next_id() {	static int id = 0;	return ++id;	},0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);",0
Side effect free?,"bool AddrMan::Good(const CService& addr, NodeSeconds time)	{",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,",0
Side effect free?,void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {,0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}",0
Side effect free?,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);	has = true;	}	},0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};	",0
Side effect free?,int* createMem() {	int* placeholder = new int{42};	return placeholder;	},0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	LOCK(cs);	Check();	auto addresses = GetAddr_(max_addresses, max_pct, network, filtered);	Check();",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;",0
Side effect free?,int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrMan::SelectTriedCollision()	{",0
Side effect free?,int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);	,0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {",0
Side effect free?,double average(const std::vector<int>& numbers) {	if (numbers.empty()) return 0.0;	int sum = 0;,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;",0
Side effect free?,int squareGlobal() {	x *= x;	return x;	},0
Side effect free?,void AddrMan::Serialize(Stream& s_) const	{	m_impl->Serialize<Stream>(s_);	},0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;,0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};",0
Side effect free?,void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);,0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;",0
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)",0
Side effect free?,"size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	LOCK(cs);	Check();",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {",0
Side effect free?,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data",0
Side effect free?,bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;,0
Side effect free?,void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);,0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;	",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()",0
Side effect free?,#include <vector>,0
Side effect free?,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;",0
Side effect free?,void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {,0
Side effect free?,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;,0
Side effect free?,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {",0
Side effect free?,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}",0
Side effect free?,bool IsSandboxEnabled(base::CommandLine* command_line) {	return command_line->HasSwitch(switches::kEnableSandbox) ||	!command_line->HasSwitch(sandbox::policy::switches::kNoSandbox);,0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;	",0
Side effect free?,"double distance(double x1, double y1, double x2, double y2) {",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)	",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {",0
Side effect free?,CScript operator()(const WitnessV0KeyHash& id) const	{,0
Side effect free?,int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);,0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.	",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;",0
Side effect free?,"int fibonacci(int n) {	static std::unordered_map<int, int> cache;",0
Side effect free?,"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));	",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}	",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)",0
Side effect free?,"int AddrInfo::GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const	{	uint64_t hash1 = (HashWriter{} << nKey << GetKey()).GetCheapHash();",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {",0
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)",0
Side effect free?,bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	},0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)",0
Side effect free?,class myClass {,0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;",0
Side effect free?,CScript operator()(const PubKeyDestination& dest) const	{	return CScript() << ToByteVector(dest.GetPubKey()) << OP_CHECKSIG;	},0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);	",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).",0
Side effect free?,CScript operator()(const WitnessUnknown& id) const	{	return CScript() << CScript::EncodeOP_N(id.GetWitnessVersion()) << id.GetWitnessProgram();,0
Side effect free?,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);",0
Side effect free?,void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);,0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}",0
Side effect free?,"void ReadFromStream(AddrMan& addr, DataStream& ssPeers)",0
Side effect free?,void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({,0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;",0
Side effect free?,double area_of_circle(double radius) {,0
Side effect free?,int AddrManImpl::CheckAddrman() const	{,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);	",0
Side effect free?,"bool AddrManImpl::Good(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	auto ret = Good_(addr, /*test_before_evict=*/true, time);	Check();",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();",0
Side effect free?,bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;,0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>",0
Side effect free?,"size_t AddrMan::Size(std::optional<Network> net, std::optional<bool> in_new) const	{",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;	",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}	",0
Side effect free?,void squareSelf(int& sSval) {,0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();",0
Side effect free?,int find_max(const std::vector<int>& numbers) {,0
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];",0
Side effect free?,CScript operator()(const WitnessV0KeyHash& id) const,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;",0
Side effect free?,int reverse_number(int num) {	int reversed = 0;	while (num != 0) {,0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.",0
Side effect free?,int main() {	cout << sum(testArray) << endl;	},0
Side effect free?,"void AddrManImpl::Connected(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");	",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrMan::Select(bool new_only, const std::unordered_set<Network>& networks) const",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip",0
Side effect free?,void AddrMan::Unserialize(Stream& s_)	{	m_impl->Unserialize<Stream>(s_);	},0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}",0
Side effect free?,"v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {	std::map<std::string, std::string> keys;	#if !IS_MAS_BUILD()	electron::crash_keys::GetCrashKeys(&keys);	#endif",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(",0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.",0
Side effect free?,"int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;	if (cache.find(n) != cache.end()) return cache[n];",0
Side effect free?,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",0
Side effect free?,int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;",0
Side effect free?,bool is_palindrome(const std::string& str) {	int left = 0;,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&",0
Side effect free?,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:	int privateint_;,0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point",0
Side effect free?,int* createMem() {,0
Side effect free?,//SEF,0
Side effect free?,void AddrMan::ResolveCollisions(),0
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.",0
Side effect free?,void changeWithin(int changed) {	changed = 5;,0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);	",0
Side effect free?,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",",0
Side effect free?,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT,0
Side effect free?,void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;,0
Side effect free?,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;",0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();	",0
Side effect free?,std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;,0
Side effect free?,bool isPalindrome(const string &s) {	int len = s.size();	for (int i = 0; i < len / 2; ++i) {	if (s[i] != s[len - i - 1]) {	return false;	}	},0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}	",0
Side effect free?,double area_of_circle(double radius) {	return M_PI * radius * radius;	},0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;",0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};",0
Side effect free?,void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {",0
Side effect free?,double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);",0
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);",0
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}",0
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}",0
Side effect free?,void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;,0
Side effect free?,CScript operator()(const WitnessV1Taproot& tap) const	{,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	LOCK(cs);	Check();	auto addrRet = Select_(new_only, networks);	Check();",0
Side effect free?,class myClass {,0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const",0
Side effect free?,void AddrManImpl::ResolveCollisions_(),0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()	{",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;",0
Side effect free?,"void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};	if (filein.IsNull()) {	throw DbNotFoundError{};	}	DeserializeDB(filein, data);	}",0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{,0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {",0
Side effect free?,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}",0
Side effect free?,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE,0
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}	",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {",0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {",0
Side effect free?,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);	",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;	",0
Side effect free?,"int AddrInfo::GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const	{	uint64_t hash1 = (HashWriter{} << nKey << GetKey()).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;",0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};",0
Side effect free?,void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that,0
Side effect free?,"void remove_element(std::vector<int>& numbers, int value) {",0
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)",0
Side effect free?,int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {	sum_total += array_to_sum[i];,0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Side effect free?,vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {	evens.push_back(num);	}	}	return evens;,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));",0
Side effect free?,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);	",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {",0
Side effect free?,#include <vector>	#include <string>	#include <algorithm>,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {",0
Side effect free?,"int AddrInfo::GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const	{",0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()	{	LOCK(cs);",0
Side effect free?,CScript operator()(const WitnessUnknown& id) const	{	return CScript() << CScript::EncodeOP_N(id.GetWitnessVersion()) << id.GetWitnessProgram();	},0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(",0
Side effect free?,"//SE		void add_element(std::vector<int>& numbers, int value) {",0
Side effect free?,"bool SerializeDB(Stream& stream, const Data& data)	{",0
Side effect free?,int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;,0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;",0
Side effect free?,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;",0
Side effect free?,CScript operator()(const WitnessV0ScriptHash& id) const	{	return CScript() << OP_0 << ToByteVector(id);	},0
Side effect free?,double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	},0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);	",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}",0
Side effect free?,"void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& anchors)	{",0
Side effect free?,void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",",0
Side effect free?,void AddrMan::Unserialize(Stream& s_),0
Side effect free?,"size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const",0
Side effect free?,bool operator()(const WitnessV0ScriptHash& dest) const { return true; },0
Side effect free?,"bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr)	{",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);	",0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;",0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//",0
Side effect free?,class Counter {	public:,0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}",0
Side effect free?,WitnessV0ScriptHash::WitnessV0ScriptHash(const CScript& in),0
Side effect free?,#include <vector>	#include <string>,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success,0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {",0
Side effect free?,"int gcd(int a, int b) {	while (b != 0) {",0
Side effect free?,void netNothing() {	int* temp = new int{42};	delete temp;,0
Side effect free?,"// 6. Modifies a global array	int global_array[10] = {0};	void update_global_array(int index, int value) {	if (index >= 0 && index < 10) {",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()	{	LOCK(cs);	Check();",0
Side effect free?,void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}",0
Side effect free?,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {",0
Side effect free?,"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {	return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;",0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>",0
Side effect free?,void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {,0
Side effect free?,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{",0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;	,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {",0
Side effect free?,CScript operator()(const WitnessV0ScriptHash& id) const	{	return CScript() << OP_0 << ToByteVector(id);,0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,",0
Side effect free?,// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.",0
Side effect free?,std::string reverse_string(const std::string& str) {	std::string reversed = str;,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;",0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);	,0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty	",0
Side effect free?,AddrManImpl::~AddrManImpl(),0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {",0
Side effect free?,class myClass {	public:	int publicint;	,0
Side effect free?,CScript operator()(const WitnessV1Taproot& tap) const,0
Side effect free?,"int gcd(int a, int b) {	while (b != 0) {	int temp = b;	b = a % b;	a = temp;	}	return a;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};	",0
Side effect free?,"float unrelatedNameToo(float& u, float& v) {	float w = (u = v);	return w;",0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};",0
Side effect free?,bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;,0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)",0
Side effect free?,double celsius_to_fahrenheit(double celsius) {	return (celsius * 9.0 / 5.0) + 32.0;	},0
Side effect free?,void indirectRefChange(const int& cref) {	const_cast<int&>(cref) = 5;	},0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}",0
Side effect free?,"void AddrMan::SetServices(const CService& addr, ServiceFlags nServices)	{	m_impl->SetServices(addr, nServices);	}",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on",0
Side effect free?,int pointedInt(int* point) {	return *point;,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());",0
Side effect free?,int AddrManImpl::CheckAddrman() const,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);",0
Side effect free?,int absolute_value(int x) {	return (x < 0) ? -x : x;,0
Side effect free?,void AutoUpdater::SetDelegate(Delegate* delegate) {,0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);	",0
Side effect free?,"size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const	{",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));",0
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);	",0
Side effect free?,"float unrelatedName(float u, float v) {	float w = (u = v);	return w;",0
Side effect free?,void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);	,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {",0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);	",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {",0
Side effect free?,"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)",0
Side effect free?,void JustThrow(),0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {",0
Side effect free?,bool isPalindrome(const string &s) {	int len = s.size();,0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;",0
Side effect free?,bool isPalindrome(const string &s) {	int len = s.size();	for (int i = 0; i < len / 2; ++i) {	if (s[i] != s[len - i - 1]) {	return false;,0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;	",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;",0
Side effect free?,int modifyPoint(int* points) {	*points += 1;	return *points;	},0
Side effect free?,CScript operator()(const CNoDestination& dest) const,0
Side effect free?,"bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	LOCK(cs);	Check();	auto ret = Add_(vAddr, source, time_penalty);	Check();	return ret;",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}	",0
Side effect free?,double AddrInfo::GetChance(NodeSeconds now) const	{,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;",0
Side effect free?,void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}",0
Side effect free?,"void AddrMan::Connected(const CService& addr, NodeSeconds time)",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);",0
Side effect free?,int count_chars(const std::string& str) {,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);",0
Side effect free?,"void DeserializeFileDB(const fs::path& path, Data&& data)",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {",0
Side effect free?,"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{",0
Side effect free?,void netNothing() {	int* temp = new int{42};,0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {",0
Side effect free?,std::optional<AddressPosition> AddrMan::FindAddressEntry(const CAddress& addr)	{	return m_impl->FindAddressEntry(addr);,0
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Side effect free?,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}",0
Side effect free?,"int AddrInfo::GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const	{	uint64_t hash1 = (HashWriter{} << nKey << GetKey()).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =",0
Side effect free?,class Counter {	public:	int get_count() const {	return count;	}		private:,0
Side effect free?,"void DeserializeFileDB(const fs::path& path, Data&& data)	{",0
Side effect free?,int returnChanges() {	int rc = 10;	rc = 5;	return rc;	},0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;",0
Side effect free?,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);	has = true;,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;",0
Side effect free?,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,",0
Side effect free?,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.",0
Side effect free?,"int find_max(const std::vector<int>& numbers) {	if (numbers.empty()) return 0;  // Return 0 for an empty list	return *std::max_element(numbers.begin(), numbers.end());",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30",0
Side effect free?,Delegate* AutoUpdater::GetDelegate() {	return delegate_;	},0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*",0
Side effect free?,"int gcd(int a, int b) {	while (b != 0) {	int temp = b;	b = a % b;	a = temp;	}	return a;	}",0
Side effect free?,bool is_even(int x) {	return x % 2 == 0;,0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.",0
Side effect free?,"bool starts_with(const std::string& str, const std::string& prefix) {	return str.rfind(prefix, 0) == 0;	}",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();",0
Side effect free?,"void AddrManImpl::Connected(const CService& addr, NodeSeconds time)",0
Side effect free?,CKeyID ToKeyID(const PKHash& key_hash),0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);",0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);	",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};	",0
Side effect free?,class myClass {	public:	int publicint;,0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const	{	LOCK(cs);	Check();	auto addrInfos = GetEntries_(from_tried);",0
Side effect free?,"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;	}",0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);	",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();	",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {",0
Side effect free?,// 1. Modifies a global variable	int global_count = 0;	void increment_global_count() {	global_count++;	},0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}",0
Side effect free?,void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());,0
Side effect free?,"void ReadFromStream(AddrMan& addr, DataStream& ssPeers)	{	DeserializeDB(ssPeers, addr, false);	}",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;",0
Side effect free?,class myClass {,0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};",0
Side effect free?,double average(const std::vector<int>& numbers) {	if (numbers.empty()) return 0.0;	int sum = 0;	for (int num : numbers) {	sum += num;,0
Side effect free?,bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos),0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}",0
Side effect free?,"v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {	std::map<std::string, std::string> keys;	#if !IS_MAS_BUILD()	electron::crash_keys::GetCrashKeys(&keys);	#endif	return gin::ConvertToV8(isolate, keys);",0
Side effect free?,void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:,0
Side effect free?,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;",0
Side effect free?,"size_t AddrMan::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	return m_impl->Size(net, in_new);",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;",0
Side effect free?,"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};	",0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",0
Side effect free?,void AddrMan::Unserialize(Stream& s_)	{,0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>	",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write",0
Side effect free?,void AddrManImpl::ResolveCollisions()	{	LOCK(cs);,0
Side effect free?,class Counter {	public:	int get_count() const {	return count;,0
Side effect free?,"void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{",0
Side effect free?,AddrManImpl::~AddrManImpl()	{	nKey.SetNull();	},0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history,0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);	",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);	",0
Side effect free?,"int max(int a, int b) {",0
Side effect free?,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}		private:,0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{",0
Side effect free?,"bool AddrManImpl::Good(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	auto ret = Good_(addr, /*test_before_evict=*/true, time);",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",",0
Side effect free?,bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {,0
Side effect free?,"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {	return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;	} else {	return numbers[n / 2];",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);",0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());	",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);",0
Side effect free?,void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;	,0
Side effect free?,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;	},0
Side effect free?,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;,0
Side effect free?,// 8. Opens a file and reads its content,0
Side effect free?,"size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	LOCK(cs);	Check();	auto ret = Size_(net, in_new);	Check();",0
Side effect free?,void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);	,0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}",0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Side effect free?,void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);,0
Side effect free?,"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}",0
Side effect free?,bool is_initialized = false;		void initialize() {,0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out",0
Side effect free?,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {",0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours",0
Side effect free?,double celsius_to_fahrenheit(double celsius) {	return (celsius * 9.0 / 5.0) + 32.0;,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;",0
Side effect free?,"bool AddrManImpl::Good(const CService& addr, NodeSeconds time)",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);",0
Side effect free?,"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}	",0
Side effect free?,"int AddrInfo::GetBucketPosition(const uint256& nKey, bool fNew, int bucket) const	{	uint64_t hash1 = (HashWriter{} << nKey << (fNew ? uint8_t{'N'} : uint8_t{'K'}) << bucket << GetKey()).GetCheapHash();	return hash1 % ADDRMAN_BUCKET_SIZE;",0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};",0
Side effect free?,CKeyID ToKeyID(const WitnessV0KeyHash& key_hash),0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif",0
Side effect free?,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT,0
Side effect free?,"int find_max(const std::vector<int>& numbers) {	if (numbers.empty()) return 0;  // Return 0 for an empty list	return *std::max_element(numbers.begin(), numbers.end());	}",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);",0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours	",0
Side effect free?,vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {,0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;	",0
Side effect free?,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);	}	return false;	}",0
Side effect free?,CScript operator()(const CNoDestination& dest) const	{	return dest.GetScript();	},0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))",0
Side effect free?,void printVar(auto var_to_print) { // printing,0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)",0
Side effect free?,void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];	,0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets",0
Side effect free?,// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);,0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.",0
Side effect free?,CScript operator()(const WitnessV1Taproot& tap) const	{	return CScript() << OP_1 << ToByteVector(tap);	},0
Side effect free?,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,",0
Side effect free?,"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {	LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);	}	return added > 0;	}",0
Side effect free?,"// 6. Modifies a global array	int global_array[10] = {0};	void update_global_array(int index, int value) {	if (index >= 0 && index < 10) {	global_array[index] = value;	}	}",0
Side effect free?,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)",0
Side effect free?,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {",0
Side effect free?,CScriptID ToScriptID(const ScriptHash& script_hash),0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);",0
Side effect free?,void ThrowCatch()	{,0
Side effect free?,CKeyID ToKeyID(const PKHash& key_hash)	{,0
Side effect free?,void AddrMan::Unserialize(Stream& s_)	{	m_impl->Unserialize<Stream>(s_);,0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;	",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;	",0
Side effect free?,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;,0
Side effect free?,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}",0
Side effect free?,"// 6. Modifies a global array	int global_array[10] = {0};	void update_global_array(int index, int value) {	if (index >= 0 && index < 10) {	global_array[index] = value;	}",0
Side effect free?,void indirectPointChange(const int* cpoint) {	*const_cast<int*>(cpoint) = 5;	},0
Side effect free?,void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);,0
Side effect free?,CKeyID ToKeyID(const PKHash& key_hash)	{	return CKeyID{uint160{key_hash}};	},0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}	",0
Side effect free?,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrMan::GetEntries(bool use_tried) const	{",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;",0
Side effect free?,#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>	,0
Side effect free?,void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);	",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif	",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const",0
Side effect free?,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;	}",0
Side effect free?,//SEF		int stringLength(const string &s) {	return s.length();	},0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {",0
Side effect free?,bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;		const auto& c_locale = std::locale::classic();,0
Side effect free?,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info",0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;	",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrMan::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	return m_impl->Select(new_only, networks);	}",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;	",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;",0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;",0
Side effect free?,"bool AddrMan::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {",0
Side effect free?,"vector<int> addToArray(vector<int> array_copy, int value_to_add) { // returning modified array passed in by value	for (int i = 0; i < array_copy.size(); ++i) {	array_copy[i] += value_to_add;	}	return array_copy;",0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{	LOCK(cs);	Check();	auto entry = FindAddressEntry_(addr);,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{	LOCK(cs);	Check();	auto entry = FindAddressEntry_(addr);	Check();	return entry;	},0
Side effect free?,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;	}",0
Side effect free?,int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {	sum_total += array_to_sum[i];	}		return sum_total;,0
Side effect free?,"std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{",0
Side effect free?,"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}",0
Side effect free?,bool is_palindrome(const std::string& str) {,0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);",0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these",0
Side effect free?,void AddrManImpl::Check() const	{	AssertLockHeld(cs);,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).",0
Side effect free?,int factorial(int n) {	if (n == 0) {	return 1;	}	return n * factorial(n - 1);	},0
Side effect free?,"int AddrInfo::GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const",0
Side effect free?,"void AddrManImpl::Connected(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	Connected_(addr, time);	Check();	}",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}",0
Side effect free?,int squareGlobal() {,0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);",0
Side effect free?,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security",0
Side effect free?,void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {",0
Side effect free?,// 1. Modifies a global variable,0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);",0
Side effect free?,CScript operator()(const CNoDestination& dest) const	{	return dest.GetScript();,0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {",0
Side effect free?,Delegate* AutoUpdater::GetDelegate() {	return delegate_;,0
Side effect free?,void AddrManImpl::Check() const	{	AssertLockHeld(cs);	,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	LOCK(cs);	Check();	auto addrRet = Select_(new_only, networks);	Check();	return addrRet;	}",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Side effect free?,CKeyID ToKeyID(const WitnessV0KeyHash& key_hash)	{	return CKeyID{uint160{key_hash}};	},0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}",0
Side effect free?,vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {	evens.push_back(num);	}	},0
Side effect free?,"bool IsValidDestination(const CTxDestination& dest) {	return std::visit(ValidDestinationVisitor(), dest);",0
Side effect free?,"vector<int> addToArray(vector<int> array_copy, int value_to_add) { // returning modified array passed in by value	for (int i = 0; i < array_copy.size(); ++i) {",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {",0
Side effect free?,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);	has = true;	},0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;	",0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}	",0
Side effect free?,CScript operator()(const ScriptHash& scriptID) const	{	return CScript() << OP_HASH160 << ToByteVector(scriptID) << OP_EQUAL;,0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrMan::GetEntries(bool use_tried) const	{	return m_impl->GetEntries(use_tried);	}",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif	",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()",0
Side effect free?,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;,0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);	",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};",0
Side effect free?,bool isPalindrome(const string &s) {	int len = s.size();	for (int i = 0; i < len / 2; ++i) {	if (s[i] != s[len - i - 1]) {	return false;	}	}	return true;	},0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {",0
Side effect free?,CScript operator()(const WitnessUnknown& id) const,0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;	",0
Side effect free?,"int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);	",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;	",0
Side effect free?,bool operator()(const ScriptHash& dest) const { return true; },0
Side effect free?,bool isPalindrome(const string &s) {	int len = s.size();	for (int i = 0; i < len / 2; ++i) {	if (s[i] != s[len - i - 1]) {	return false;	},0
Side effect free?,"void write_to_file(const std::string& filename, const std::string& content) {	std::ofstream file(filename);",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};",0
Side effect free?,void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {,0
Side effect free?,vector<int> filterEvenNumbers(const vector<int>& numbers) {,0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {",0
Side effect free?,void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];,0
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.",0
Side effect free?,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];",0
Side effect free?,void AddrMan::ResolveCollisions()	{	m_impl->ResolveCollisions();	},0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrMan::SelectTriedCollision()",0
Side effect free?,void AddrManImpl::Check() const,0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {",0
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;	",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;	",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)",0
Side effect free?,"int max_of_three(int a, int b, int c) {",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	},0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());",0
Side effect free?,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);",0
Side effect free?,#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>,0
Side effect free?,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;	}",0
Side effect free?,int reverse_number(int num) {	int reversed = 0;,0
Side effect free?,class Counter {,0
Side effect free?,int squareReference(int& sRval) { // returning square of input passed in by reference	return sRval * sRval;,0
Side effect free?,bool CBanDB::Write(const banmap_t& banSet),0
Side effect free?,"void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};	if (filein.IsNull()) {	throw DbNotFoundError{};	}",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);",0
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;	",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}",0
Side effect free?,class myClass {	public:,0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}",0
Side effect free?,bool is_initialized = false;		void initialize() {	is_initialized = true;	},0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.",0
Side effect free?,"bool AddrManImpl::Good(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	auto ret = Good_(addr, /*test_before_evict=*/true, time);	Check();	return ret;",0
Side effect free?,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).",0
Side effect free?,//SEF		int stringLength(const string &s) {,0
Side effect free?,"bool starts_with(const std::string& str, const std::string& prefix) {",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}	",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {",0
Side effect free?,void AutoUpdater::SetFeedURL(gin::Arguments* args) {},0
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;	",0
Side effect free?,bool IsSandboxEnabled(base::CommandLine* command_line) {	return command_line->HasSwitch(switches::kEnableSandbox) ||,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);",0
Side effect free?,int factorial(int n) {	if (n == 0) {	return 1;	},0
Side effect free?,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}	,0
Side effect free?,"size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	LOCK(cs);",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}	",0
Side effect free?,bool IsSandboxEnabled(base::CommandLine* command_line) {	return command_line->HasSwitch(switches::kEnableSandbox) ||	!command_line->HasSwitch(sandbox::policy::switches::kNoSandbox);	},0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;",0
Side effect free?,double average(const std::vector<int>& numbers) {	if (numbers.empty()) return 0.0;	int sum = 0;	for (int num : numbers) {,0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;",0
Side effect free?,void ThrowCatch()	{	try	{,0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};	",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {",0
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}",0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)",0
Side effect free?,int incrementedNotLocal() {,0
Side effect free?,bool operator()(const WitnessUnknown& dest) const { return true; },0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey",0
Side effect free?,"int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;	if (cache.find(n) != cache.end()) return cache[n];		cache[n] = fibonacci(n - 1) + fibonacci(n - 2);	return cache[n];	}",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.",0
Side effect free?,void AddrManImpl::Serialize(Stream& s_) const,0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{",0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};	",0
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();",0
Side effect free?,int incrementedNotLocal() {	x++;	return x;,0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)",0
Side effect free?,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};",0
Side effect free?,"void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	LOCK(cs);	Check();	Attempt_(addr, fCountFailure, time);	Check();",0
Side effect free?,int reverse_number(int num) {	int reversed = 0;	while (num != 0) {	reversed = reversed * 10 + num % 10;	num /= 10;,0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for",0
Side effect free?,"bool starts_with(const std::string& str, const std::string& prefix) {	return str.rfind(prefix, 0) == 0;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}	",0
Side effect free?,"void AddrManImpl::Connected(const CService& addr, NodeSeconds time)	{",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;",0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {",0
Side effect free?,"bool is_divisible(int a, int b) {",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;",0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);,0
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;",0
Side effect free?,"void AddrManImpl::Connected(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	Connected_(addr, time);	Check();",0
Side effect free?,"int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const	{	std::vector<unsigned char> vchSourceGroupKey = netgroupman.GetGroup(src);	uint64_t hash1 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << vchSourceGroupKey).GetCheapHash();",0
Side effect free?,CKeyID ToKeyID(const PKHash& key_hash)	{	return CKeyID{uint160{key_hash}};,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}",0
Side effect free?,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Side effect free?,int factorial(int n) {	if (n == 0) {	return 1;	}	return n * factorial(n - 1);,0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}	,0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;	",0
Side effect free?,int squareValue(int sVval) { // returning square of input passed in by value	return sVval * sVval;	},0
Side effect free?,void setFive(int& var_to_set) { // setting variable passed in by reference	var_to_set = 5;	},0
Side effect free?,std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {,0
Side effect free?,"bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	LOCK(cs);	Check();	auto ret = Add_(vAddr, source, time_penalty);	Check();	return ret;	}",0
Side effect free?,int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {	sum_total += array_to_sum[i];	},0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried",0
Side effect free?,void setFive(int& var_to_set) { // setting variable passed in by reference,0
Side effect free?,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{",0
Side effect free?,void freeMem(int* memory) {	delete memory;	},0
Side effect free?,int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;	",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);",0
Side effect free?,"bool AddrMan::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);",0
Side effect free?,"std::string AutoUpdater::GetFeedURL() {	return """";",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);	",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const	{	LOCK(cs);",0
Side effect free?,"double distance(double x1, double y1, double x2, double y2) {	return std::sqrt(std::pow(x2 - x1, 2) + std::pow(y2 - y1, 2));	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;",0
Side effect free?,vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {,0
Side effect free?,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;	}	return true;,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {",0
Side effect free?,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);	}	return false;",0
Side effect free?,"int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const",0
Side effect free?,"void AddrMan::SetServices(const CService& addr, ServiceFlags nServices)	{",0
Side effect free?,"int fibonacci(int n) {	static std::unordered_map<int, int> cache;	",0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}",0
Side effect free?,void freeMem(int* memory) {,0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {",0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum",0
Side effect free?,"int gcd(int a, int b) {	while (b != 0) {	int temp = b;	b = a % b;	a = temp;	}",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const	{	LOCK(cs);	Check();	auto addrInfos = GetEntries_(from_tried);	Check();	return addrInfos;	}",0
Side effect free?,"int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const	{	std::vector<unsigned char> vchSourceGroupKey = netgroupman.GetGroup(src);",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/	",0
Side effect free?,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}",0
Side effect free?,int count_chars(const std::string& str) {	return str.length();,0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {",0
Side effect free?,int returnChanges() {	int rc = 10;,0
Side effect free?,bool isPalindrome(const string &s) {	int len = s.size();	for (int i = 0; i < len / 2; ++i) {	if (s[i] != s[len - i - 1]) {,0
Side effect free?,"void AddrMan::Connected(const CService& addr, NodeSeconds time)	{",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;",0
Side effect free?,"v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {	std::map<std::string, std::string> keys;",0
Side effect free?,class Counter {	public:	void increment() {	count++;	}		private:	int count = 0;	};,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}	,0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {",0
Side effect free?,CScript operator()(const WitnessUnknown& id) const	{,0
Side effect free?,"void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& anchors)	{	LOG_TIME_SECONDS(strprintf(""Flush %d outbound block-relay-only peer addresses to anchors.dat"", anchors.size()));	SerializeFileDB(""anchors"", anchors_db_path, CAddress::V2_DISK(anchors));	}",0
Side effect free?,void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());	,0
Side effect free?,"bool is_divisible(int a, int b) {	return b != 0 && a % b == 0;",0
Side effect free?,void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);	,0
Side effect free?,void AddrMan::Serialize(Stream& s_) const	{,0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}",0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)",0
Side effect free?,"void changePoint(int* pointed, int& ref) {	pointed = &ref;	}",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;",0
Side effect free?,bool is_prime(int n) {	if (n <= 1) return false;	for (int i = 2; i * i <= n; ++i) {	if (n % i == 0) return false;	},0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {",0
Side effect free?,bool CBanDB::Read(banmap_t& banSet),0
Side effect free?,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}",0
Side effect free?,"// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content	file.close();	}",0
Side effect free?,class myClass {	public:	int publicint;,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.",0
Side effect free?,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);	",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	LOCK(cs);	Check();	auto addresses = GetAddr_(max_addresses, max_pct, network, filtered);	Check();	return addresses;	}",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {",0
Side effect free?,"bool AutoUpdater::IsVersionAllowedForUpdate(const std::string& current_version,",0
Side effect free?,"double distance(double x1, double y1, double x2, double y2) {	return std::sqrt(std::pow(x2 - x1, 2) + std::pow(y2 - y1, 2));",0
Side effect free?,bool UnsetHijackableEnvs(base::Environment* env) {,0
Side effect free?,CScript operator()(const PubKeyDestination& dest) const	{	return CScript() << ToByteVector(dest.GetPubKey()) << OP_CHECKSIG;,0
Side effect free?,"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {	return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;	} else {	return numbers[n / 2];	}	}",0
Side effect free?,"int gcd(int a, int b) {",0
Side effect free?,"int AddrInfo::GetBucketPosition(const uint256& nKey, bool fNew, int bucket) const	{	uint64_t hash1 = (HashWriter{} << nKey << (fNew ? uint8_t{'N'} : uint8_t{'K'}) << bucket << GetKey()).GetCheapHash();	return hash1 % ADDRMAN_BUCKET_SIZE;	}",0
Side effect free?,"//SE		void add_element(std::vector<int>& numbers, int value) {	numbers.push_back(value);	}",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;	",0
Side effect free?,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);	return anchors;	}",0
Side effect free?,"void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)	{	LOCK(cs);	Check();",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}",0
Side effect free?,std::optional<AddressPosition> AddrMan::FindAddressEntry(const CAddress& addr)	{,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}	",0
Side effect free?,bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;,0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;,0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	",0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr),0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}	",0
Side effect free?,double AddrInfo::GetChance(NodeSeconds now) const,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);",0
Side effect free?,void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()",0
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const	{	LOCK(cs);	Check();	auto addrInfos = GetEntries_(from_tried);	Check();",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}	",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);	",0
Side effect free?,int find_max(const std::vector<int>& numbers) {	if (numbers.empty()) return 0;  // Return 0 for an empty list,0
Side effect free?,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;",0
Side effect free?,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;",0
Side effect free?,"size_t AddrMan::Size(std::optional<Network> net, std::optional<bool> in_new) const",0
Side effect free?,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;",0
Side effect free?,int returnChanges() {,0
Side effect free?,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;	}	return true;	},0
Side effect free?,double median(std::vector<int> numbers) {,0
Side effect free?,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}	",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}	",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;",0
Side effect free?,void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];	",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,",0
Side effect free?,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {,0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);	",0
Side effect free?,"void write_to_file(const std::string& filename, const std::string& content) {",0
Side effect free?,int absolute_value(int x) {	return (x < 0) ? -x : x;	},0
Side effect free?,void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;	",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""",0
Side effect free?,// 1. Modifies a global variable	int global_count = 0;,0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const	{	LOCK(cs);	Check();",0
Side effect free?,void AddrManImpl::ResolveCollisions()	{	LOCK(cs);	Check();	ResolveCollisions_();	Check();	},0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}	",0
Side effect free?,"void write_to_file(const std::string& filename, const std::string& content) {	std::ofstream file(filename);	if (file.is_open()) {	file << content;	file.close();	}",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {",0
Side effect free?,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash),0
Side effect free?,CScript operator()(const PKHash& keyID) const	{,0
Side effect free?,"std::unordered_map<int, std::string> database;		void update_record(int id, const std::string& new_value) {	database[id] = new_value;	}",0
Side effect free?,class Counter {	public:	void increment() {	count++;	}	,0
Side effect free?,void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);	,0
Side effect free?,int main() {	cout << sum(testArray) << endl;,0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};	",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);	",0
Side effect free?,class myClass {	public:,0
Side effect free?,int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {	sum_total += array_to_sum[i];	}		return sum_total;	},0
Side effect free?,bool is_positive(int x) {	return x > 0;	},0
Side effect free?,bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;	},0
Side effect free?,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const	{",0
Side effect free?,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)",0
Side effect free?,bool operator()(const CNoDestination& dest) const { return false; },0
Side effect free?,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};",0
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it",0
Side effect free?,bool isPalindrome(const string &s) {	int len = s.size();	for (int i = 0; i < len / 2; ++i) {	if (s[i] != s[len - i - 1]) {	return false;	}	}	return true;,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;",0
Side effect free?,#include <vector>	#include <string>	#include <algorithm>	#include <cmath>,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}",0
Side effect free?,void indirectRefChange(const int& cref) {,0
Side effect free?,"void read_user_input(int& input) {	std::cout << ""Enter a number: "";	std::cin >> input;	}",0
Side effect free?,// 6. Modifies a global array,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.",0
Side effect free?,CScript operator()(const PKHash& keyID) const	{	return CScript() << OP_DUP << OP_HASH160 << ToByteVector(keyID) << OP_EQUALVERIFY << OP_CHECKSIG;,0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	},0
Side effect free?,CScript operator()(const WitnessV0ScriptHash& id) const	{,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {",0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;",0
Side effect free?,"int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const	{	std::vector<unsigned char> vchSourceGroupKey = netgroupman.GetGroup(src);	uint64_t hash1 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << vchSourceGroupKey).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetCheapHash();",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()	{	LOCK(cs);	Check();	auto ret = SelectTriedCollision_();	Check();	return ret;	}",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Side effect free?,void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);	,0
Side effect free?,"vector<int> addToArray(vector<int> array_copy, int value_to_add) { // returning modified array passed in by value",0
Side effect free?,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,",0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{	LOCK(cs);	Check();,0
Side effect free?,void AddrManImpl::ResolveCollisions_()	{,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}",0
Side effect free?,void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{	int temporary = 0;,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;",0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{	LOCK(cs);	Check();	auto entry = FindAddressEntry_(addr);	Check();	return entry;,0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);	",0
Side effect free?,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);	",0
Side effect free?,class myClass {	public:	int publicint;	,0
Side effect free?,"bool AddrMan::Good(const CService& addr, NodeSeconds time)	{	return m_impl->Good(addr, time);",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}",0
Side effect free?,void AddrManImpl::Unserialize(Stream& s_)	{,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);",0
Side effect free?,"void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)	{",0
Side effect free?,"bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file",0
Side effect free?,CScript GetScriptForDestination(const CTxDestination& dest),0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))",0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);	",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute,0
Side effect free?,void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;,0
Side effect free?,void ThrowCatch()	{	try,0
Side effect free?,// 1. Modifies a global variable	int global_count = 0;	void increment_global_count() {,0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);",0
Side effect free?,void AddrMan::Serialize(Stream& s_) const	{	m_impl->Serialize<Stream>(s_);,0
Side effect free?,"size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	LOCK(cs);	Check();	auto ret = Size_(net, in_new);",0
Side effect free?,"// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content",0
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);	",0
Side effect free?,"void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)	{	LOCK(cs);	Check();	SetServices_(addr, nServices);	Check();",0
Side effect free?,CScriptID ToScriptID(const ScriptHash& script_hash)	{,0
Side effect free?,"void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	LOCK(cs);	Check();",0
Side effect free?,CScriptID ToScriptID(const ScriptHash& script_hash)	{	return CScriptID{uint160{script_hash}};,0
Side effect free?,int returnChanges() {	int rc = 10;	rc = 5;,0
Side effect free?,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));	",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};",0
Side effect free?,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;",0
Side effect free?,"// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content	file.close();	}	return content;	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;",0
Side effect free?,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;",0
Side effect free?,int pointedInt(int* point) {	return *point;	},0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}",0
Side effect free?,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;	}",0
Side effect free?,CKeyID ToKeyID(const WitnessV0KeyHash& key_hash)	{,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}",0
Side effect free?,void JustThrow()	{	throw 0;	},0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");",0
Side effect free?,"void AddrManImpl::Connected(const CService& addr, NodeSeconds time)	{	LOCK(cs);",0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];	",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?",0
Side effect free?,bool CBanDB::Write(const banmap_t& banSet)	{,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}",0
Side effect free?,void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];,0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}	",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;",0
Side effect free?,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;",0
Side effect free?,"std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const",0
Side effect free?,void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{	int temporary = 0;	},0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;",0
Side effect free?,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:,0
Side effect free?,"// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content	file.close();",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Side effect free?,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:",0
Side effect free?,"void ReadFromStream(AddrMan& addr, DataStream& ssPeers)	{",0
Side effect free?,int get_next_id() {,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.",0
Side effect free?,//SE,0
Side effect free?,int squareValue(int sVval) { // returning square of input passed in by value,0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}	,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}",0
Side effect free?,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);	",0
Side effect free?,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {",0
Side effect free?,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	},0
Side effect free?,"std::string reverse_string(const std::string& str) {	std::string reversed = str;	std::reverse(reversed.begin(), reversed.end());	return reversed;",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;",0
Side effect free?,int pointedInt(int* point) {,0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;	",0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions",0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);	",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;",0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);",0
Side effect free?,void AddrManImpl::Unserialize(Stream& s_),0
Side effect free?,"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {",0
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}",0
Side effect free?,int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {	sum_total += array_to_sum[i];	}	,0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	LOCK(cs);",0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Side effect free?,"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {	return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;	} else {	return numbers[n / 2];	}",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}",0
Side effect free?,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}		private:	int privateint_;,0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Side effect free?,vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {	evens.push_back(num);	},0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrMan::GetEntries(bool use_tried) const",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {",0
Side effect free?,bool operator()(const WitnessV0KeyHash& dest) const { return true; },0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {",0
Side effect free?,"std::string reverse_string(const std::string& str) {	std::string reversed = str;	std::reverse(reversed.begin(), reversed.end());	return reversed;	}",0
Side effect free?,"int max(int a, int b) {	return (a > b) ? a : b;	}",0
Side effect free?,"void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& anchors)",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}",0
Side effect free?,"bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {",0
Side effect free?,"void write_to_file(const std::string& filename, const std::string& content) {	std::ofstream file(filename);	if (file.is_open()) {",0
Side effect free?,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;,0
Side effect free?,"std::string AutoUpdater::GetFeedURL() {	return """";	}",0
Side effect free?,"int max(int a, int b) {	return (a > b) ? a : b;",0
Side effect free?,std::string AutoUpdater::GetFeedURL() {,0
Side effect free?,"int AddrInfo::GetBucketPosition(const uint256& nKey, bool fNew, int bucket) const",0
Side effect free?,"vector<int> addToArray(vector<int> array_copy, int value_to_add) { // returning modified array passed in by value	for (int i = 0; i < array_copy.size(); ++i) {	array_copy[i] += value_to_add;",0
Side effect free?,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect",0
Side effect free?,bool is_positive(int x) {	return x > 0;,0
Side effect free?,class Counter {,0
Side effect free?,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);",0
Side effect free?,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {",0
Side effect free?,"size_t AddrMan::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	return m_impl->Size(net, in_new);	}",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);	",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}",0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",",0
Side effect free?,"void AddrMan::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{",0
Side effect free?,CScript operator()(const WitnessV0KeyHash& id) const	{	return CScript() << OP_0 << ToByteVector(id);	},0
Side effect free?,void clear_list(std::vector<int>& numbers) {,0
Side effect free?,CScript operator()(const WitnessV1Taproot& tap) const	{	return CScript() << OP_1 << ToByteVector(tap);,0
Side effect free?,int reverse_number(int num) {	int reversed = 0;	while (num != 0) {	reversed = reversed * 10 + num % 10;,0
Side effect free?,std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);	,0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}",0
Side effect free?,std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path),0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const	{	LOCK(cs);	Check();	auto addrInfos = GetEntries_(from_tried);	Check();	return addrInfos;",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}",0
Side effect free?,"bool AutoUpdater::IsVersionAllowedForUpdate(const std::string& current_version,	const std::string& target_version) {",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.",0
Side effect free?,int squareReference(int& sRval) { // returning square of input passed in by reference,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif",0
Side effect free?,"bool is_divisible(int a, int b) {	return b != 0 && a % b == 0;	}",0
Side effect free?,void incrementGlobal() {	++x;	},0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {",0
Side effect free?,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}",0
Side effect free?,bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;	,0
Side effect free?,void AddrManImpl::ResolveCollisions(),0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);	",0
Side effect free?,void AddrManImpl::Serialize(Stream& s_) const	{,0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {",0
Side effect free?,void incrementGlobal() {,0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}	",0
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{",0
Side effect free?,"vector<int> addToArray(vector<int> array_copy, int value_to_add) { // returning modified array passed in by value	for (int i = 0; i < array_copy.size(); ++i) {	array_copy[i] += value_to_add;	}	return array_copy;	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;",0
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);",0
Side effect free?,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}	",0
Side effect free?,"std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	return m_impl->GetAddr(max_addresses, max_pct, network, filtered);	}",0
Side effect free?,int squareValue(int sVval) { // returning square of input passed in by value	return sVval * sVval;,0
Side effect free?,int fibonacci(int n) {,0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;",0
Side effect free?,class Counter {	public:	void increment() {	count++;	}		private:	int count = 0;,0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;",0
Side effect free?,"bool AddrManImpl::Good(const CService& addr, NodeSeconds time)	{",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {",0
Side effect free?,void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`),0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {",0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const",0
Side effect free?,"bool AutoUpdater::IsVersionAllowedForUpdate(const std::string& current_version,	const std::string& target_version) {	return false;	}",0
Side effect free?,class myClass {	public:	int publicint;	,0
Side effect free?,double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away,0
Side effect free?,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();	",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();",0
Side effect free?,void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;,0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}",0
Side effect free?,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);	",0
Side effect free?,"v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {	std::map<std::string, std::string> keys;	#if !IS_MAS_BUILD()",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}",0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)",0
Side effect free?,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {",0
Side effect free?,double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;,0
Side effect free?,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);	}",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}",0
Side effect free?,"float unrelatedName(float u, float v) {	float w = (u = v);",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {",0
Side effect free?,"void changePoint(int* pointed, int& ref) {",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before",0
Side effect free?,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {",0
Side effect free?,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {",0
Side effect free?,int reverse_number(int num) {	int reversed = 0;	while (num != 0) {	reversed = reversed * 10 + num % 10;	num /= 10;	},0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;",0
Side effect free?,void JustThrow()	{,0
Side effect free?,//SEF		int stringLength(const string &s) {	return s.length();,0
Side effect free?,class Counter {	public:	int get_count() const {	return count;	}		private:	int count = 0;,0
Side effect free?,"void remove_element(std::vector<int>& numbers, int value) {	numbers.erase(std::remove(numbers.begin(), numbers.end(), value), numbers.end());	}",0
Side effect free?,"void AddrMan::SetServices(const CService& addr, ServiceFlags nServices)",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}",0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;",0
Side effect free?,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;	",0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;,0
Side effect free?,"vector<int> addToArray(vector<int> array_copy, int value_to_add) { // returning modified array passed in by value	for (int i = 0; i < array_copy.size(); ++i) {	array_copy[i] += value_to_add;	}",0
Side effect free?,"float unrelatedNameToo(float& u, float& v) {	float w = (u = v);	return w;	}",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrMan::GetEntries(bool use_tried) const	{	return m_impl->GetEntries(use_tried);",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];	",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;	",0
Side effect free?,int reverse_number(int num) {,0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {",0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;",0
Side effect free?,class Counter {	public:,0
Side effect free?,"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());",0
Side effect free?,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);",0
Side effect free?,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}",0
Side effect free?,int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {,0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",",0
Side effect free?,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);	",0
Side effect free?,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {",0
Side effect free?,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const",0
Side effect free?,"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);	",0
Side effect free?,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",",0
Side effect free?,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}		private:	int privateint_;,0
Side effect free?,int returnChanges() {	int rc = 10;	rc = 5;	return rc;,0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);",0
Side effect free?,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}",0
Side effect free?,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;",0
Side effect free?,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);",0
Side effect free?,"int max_of_three(int a, int b, int c) {	return std::max({a, b, c});",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {",0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};",0
Side effect free?,void AutoUpdater::QuitAndInstall() {},0
Side effect free?,"bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;		const auto& c_locale = std::locale::classic();	const auto isspace = [&](auto ch) { return std::isspace(ch, c_locale); };	const auto scheme = arg.substr(0U, scheme_end);",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();",0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {",0
Side effect free?,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];",0
Side effect free?,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;		",0
Side effect free?,bool is_even(int x) {	return x % 2 == 0;	},0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}",0
Side effect free?,bool operator()(const PubKeyDestination& dest) const { return false; },0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions",0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)",0
Side effect free?,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}",0
Side effect free?,class Counter {	public:	int get_count() const {	return count;	}		private:	int count = 0;	};,0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});	",0
Side effect free?,"float unrelatedName(float u, float v) {",0
Side effect free?,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;",0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {",0
Side effect free?,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;	",0
Side effect free?,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);",0
Side effect free?,WitnessV0ScriptHash::WitnessV0ScriptHash(const CScript& in)	{,0
Side effect free?,void squareSelf(int& sSval) {	sSval *= sSval;	},0
Side effect free?,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}	",0
Side effect free?,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(",0
Side effect free?,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered",0
Side effect free?,bool is_prime(int n) {	if (n <= 1) return false;	for (int i = 2; i * i <= n; ++i) {	if (n % i == 0) return false;	}	return true;,0
Side effect free?,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;,0
Side effect free?,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;",0
Side effect free?,"bool AddrMan::Good(const CService& addr, NodeSeconds time)",0
Side effect free?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.	",0
Side effect free?,class Counter {	public:	int get_count() const {	return count;	},0
Side effect free?,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {,0
Side effect free?,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}	,0
Side effect free?,std::string reverse_string(const std::string& str) {,0
Side effect free?,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).",0
Side effect free?,"bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	LOCK(cs);	Check();",0
Side effect free?,void AddrManImpl::Check() const	{,0
Side effect free?,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:",0
Side effect free?,"void write_to_file(const std::string& filename, const std::string& content) {	std::ofstream file(filename);	if (file.is_open()) {	file << content;	file.close();",0
Side effect free?,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;,0
