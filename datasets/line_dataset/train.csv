line,code,label
Line 34: remove(pathTmp);,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",1
Line 62: NodeBindings::RegisterBuiltinBindings();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
"Line 36: LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());","std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",1
Line 3: throw 0;,void JustThrow()	{	throw 0;	},1
Line 53: addressRet = CNoDestination(scriptPubKey);,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",1
Line 17: m_network_counts[info.GetNetwork()].n_new--;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",1
Line 10: AutoFile fileout{file};,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",1
Line 15: nNew--;,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",1
Line 30: fileout.fclose();,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",1
"Line 35: LogError(""%s: Rename-into-place failed\n"", __func__);","bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",1
"Line 3: return m_impl->GetAddr(max_addresses, max_pct, network, filtered);","std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	return m_impl->GetAddr(max_addresses, max_pct, network, filtered);	}",1
Line 11: vvNew[bucket][pos] = -1;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",1
"Line 11: DeserializeFileDB(path_addr, *addrman);","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",1
"Line 2: std::cout << ""Enter a number: "";","void read_user_input(int& input) {	std::cout << ""Enter a number: "";	std::cin >> input;	}",1
Line 17: info.m_last_success = time;,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",1
"Line 14: LOG(ERROR) << ""The Node.js cli flag "" << key","void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",1
"Line 40: DCHECK(base::StringToInt(pid_string, &pid));","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
"Line 75: fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 12: info.nRefCount--;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",1
Line 59: m_network_counts[info.GetNetwork()].n_new++;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
"Line 33: if (!RenameOver(pathTmp, path)) {","bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",1
"Line 14: if (!common::ReadSettings(m_banlist_json, settings, errors)) {","bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",1
Line 88: ElectronCrashReporterClient::Create();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 30: s >> nNew;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
"Line 5: DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));","std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);	return anchors;	}",1
"Line 5: auto addresses = GetAddr_(max_addresses, max_pct, network, filtered);","std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	LOCK(cs);	Check();	auto addresses = GetAddr_(max_addresses, max_pct, network, filtered);	Check();	return addresses;	}",1
Line 21: addressRet = ScriptHash(uint160(vSolutions[0]));,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",1
Line 135: ++info.nRefCount;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 18: info.m_last_try = time;,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",1
Line 3: if (fs::exists(m_banlist_dat)) {,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",1
"Line 8: LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);","bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {	LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);	}	return added > 0;	}",1
Line 27: addressRet = hash;,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",1
Line 35: nTried--;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",1
Line 58: vRandom.push_back(n);,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 19: it_2->second.nRandomPos = nRndPos1;,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",1
"Line 24: LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",1
Line 5: AddrInfo* addr_info = Find(addr);,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",1
Line 26: remove(pathTmp);,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",1
Line 2: x = 6;,void setSix(){ // setting global variable	x = 6;	},1
"Line 4: return SerializeFileDB(""peers"", pathAddr, addr);","bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr)	{	const auto pathAddr = args.GetDataDirNet() / ""peers.dat"";	return SerializeFileDB(""peers"", pathAddr, addr);	}",1
"Line 12: LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);","void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",1
Line 43: addressRet = PayToAnchor();,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",1
"Line 4: if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {","bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);	}	return false;	}",1
Line 97: ElectronCrashReporterClient::Create();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 11: fs::remove(anchors_db_path);,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);	return anchors;	}",1
Line 4: electron::crash_keys::GetCrashKeys(&keys);,"v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {	std::map<std::string, std::string> keys;	#if !IS_MAS_BUILD()	electron::crash_keys::GetCrashKeys(&keys);	#endif	return gin::ConvertToV8(isolate, keys);	}",1
"Line 108: base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 57: m_network_counts[info.GetNetwork()].n_tried++;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",1
Line 79: m_network_counts[info.GetNetwork()].n_tried++;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 75: s << info;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",1
Line 10: addressRet = CNoDestination(scriptPubKey);,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",1
Line 14: info.nServices = nServices;,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;	}",1
Line 20: exit(9);,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",1
"Line 39: Good_(info_new, false, current_time);","void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",1
Line 8: s_ >> Using<CustomUintFormatter<1>>(format);,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 5: ResolveCollisions_();,void AddrManImpl::ResolveCollisions()	{	LOCK(cs);	Check();	ResolveCollisions_();	Check();	},1
Line 6: privateint_ = value;,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,1
"Line 41: ClearNew(nUBucket, nUBucketPos);","void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",1
Line 90: crash_keys::SetCrashKeysFromCommandLine(,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 23: throw InvalidAddrManVersionError(strprintf(,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 14: Delete(nIdDelete);,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",1
Line 66: ExitIfContainsDisallowedFlags(args);,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
"Line 139: CHECK_NE(nullptr, env);","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
"Line 6: LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));","std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);	return anchors;	}",1
"Line 3: DeserializeDB(ssPeers, addr, false);","void ReadFromStream(AddrMan& addr, DataStream& ssPeers)	{	DeserializeDB(ssPeers, addr, false);	}",1
Line 19: info.nAttempts = 0;,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",1
Line 5: auto ret = SelectTriedCollision_();,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()	{	LOCK(cs);	Check();	auto ret = SelectTriedCollision_();	Check();	return ret;	}",1
Line 39: addressRet = tap;,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",1
"Line 3: m_impl->Connected(addr, time);","void AddrMan::Connected(const CService& addr, NodeSeconds time)	{	m_impl->Connected(addr, time);	}",1
Line 2: numbers.clear();,void clear_list(std::vector<int>& numbers) {	numbers.clear();	},1
Line 15: m_tried_collisions.erase(it);,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",1
Line 3: nKey.SetNull();,AddrManImpl::~AddrManImpl()	{	nKey.SetNull();	},1
Line 184: v8::V8::Dispose();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 2: ++x;,void incrementGlobal() {	++x;	},1
Line 13: verifier >> data;,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",1
Line 3: m_impl->ResolveCollisions();,void AddrMan::ResolveCollisions()	{	m_impl->ResolveCollisions();	},1
Line 78: nIdCount++;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 74: vRandom.push_back(nIdCount);,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
"Line 49: LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",","void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",1
Line 51: s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",1
Line 101: crash_keys::SetPlatformCrashKey();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 17: addressRet = PKHash(uint160(vSolutions[0]));,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",1
Line 46: s << static_cast<uint8_t>(FILE_FORMAT);,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",1
Line 31: s >> nTried;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 57: info.nRandomPos = vRandom.size();,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 2: delete memory;,void freeMem(int* memory) {	delete memory;	},1
"Line 66: LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",","bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",1
Line 2: var_to_set = 5;,void setFive(int& var_to_set) { // setting variable passed in by reference	var_to_set = 5;	},1
"Line 11: LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);","void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}	}",1
Line 4: file << content;,"void write_to_file(const std::string& filename, const std::string& content) {	std::ofstream file(filename);	if (file.is_open()) {	file << content;	file.close();	}	}",1
Line 16: info.m_last_count_attempt = time;,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",1
"Line 27: LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));","bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",1
Line 55: s >> info;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 142: vvNew[bucket][bucket_position] = entry_index;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 16: info.nTime = time;,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",1
Line 56: mapAddr[info] = n;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
"Line 3: LOG_TIME_SECONDS(strprintf(""Flush %d outbound block-relay-only peer addresses to anchors.dat"", anchors.size()));","void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& anchors)	{	LOG_TIME_SECONDS(strprintf(""Flush %d outbound block-relay-only peer addresses to anchors.dat"", anchors.size()));	SerializeFileDB(""anchors"", anchors_db_path, CAddress::V2_DISK(anchors));	}",1
"Line 171: node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 37: m_tried_collisions.insert(nId);,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",1
Line 72: info.nRandomPos = vRandom.size();,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 39: throw std::ios_base::failure(,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 4: database[id] = new_value;,"std::unordered_map<int, std::string> database;		void update_record(int id, const std::string& new_value) {	database[id] = new_value;	}",1
"Line 51: Good_(info_new, false, Now<NodeSeconds>());","void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",1
"Line 3: CSHA256().Write(in.data(), in.size()).Finalize(begin());","WitnessV0ScriptHash::WitnessV0ScriptHash(const CScript& in)	{	CSHA256().Write(in.data(), in.size()).Finalize(begin());	}",1
"Line 27: std::ignore = freopen(""/dev/null"", ""w"", stderr);","// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",1
"Line 41: base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 182: base::ThreadPoolInstance::Get()->Shutdown();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 22: vRandom[nRndPos2] = nId1;,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",1
Line 6: throw DbNotFoundError{};,"void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};	if (filein.IsNull()) {	throw DbNotFoundError{};	}	DeserializeDB(filein, data);	}",1
Line 16: throw std::ios_base::failure(strprintf(,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 5: env->UnSetVar(name);,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);	has = true;	}	}	return has;	},1
Line 2: *const_cast<int*>(cpoint) = 5;,void indirectPointChange(const int* cpoint) {	*const_cast<int*>(cpoint) = 5;	},1
Line 13: mapAddr.erase(info);,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",1
Line 2: float w = (u = v);,"float unrelatedNameToo(float& u, float& v) {	float w = (u = v);	return w;	}",1
"Line 48: MakeTried(info, nId);","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",1
Line 55: nTried++;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",1
Line 2: cout << var_to_print << endl;,void printVar(auto var_to_print) { // printing	cout << var_to_print << endl;	},1
Line 8: mapInfo[nId].nRandomPos = vRandom.size();,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",1
Line 78: return result->exit_code();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 84: nTried -= nLost;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 23: if (UnsetHijackableEnvs(os_env.get())) {,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 48: m_network_counts[infoOld.GetNetwork()].n_new++;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",1
Line 61: nIdCount = nNew;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
"Line 25: std::ignore = freopen(""/dev/null"", ""w"", stdout);","// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",1
Line 92: crash_keys::SetPlatformCrashKey();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
"Line 24: LOG(ERROR) << ""Node.js environment variables are disabled because this ""","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 47: nNew++;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",1
"Line 47: addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};","bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",1
Line 165: throw std::ios_base::failure(strprintf(,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 5: LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",1
"Line 62: ClearNew(nUBucket, nUBucketPos);","bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",1
Line 5: AddrInfo* pinfo = Find(addr);,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",1
Line 53: s << nKey;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",1
Line 2: x *= x;,int squareGlobal() {	x *= x;	return x;	},1
Line 100: *base::CommandLine::ForCurrentProcess());,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 8: anchors.clear();,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);	return anchors;	}",1
Line 4: count++;,class Counter {	public:	void increment() {	count++;	}		private:	int count = 0;	};,1
"Line 3: m_impl->SetServices(addr, nServices);","void AddrMan::SetServices(const CService& addr, ServiceFlags nServices)	{	m_impl->SetServices(addr, nServices);	}",1
Line 99: crash_keys::SetCrashKeysFromCommandLine(,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 2: delegate_ = delegate;,void AutoUpdater::SetDelegate(Delegate* delegate) {	delegate_ = delegate;	},1
"Line 45: os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
"Line 163: node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 17: info.nAttempts++;,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",1
"Line 131: CHECK_NE(nullptr, isolate_data);","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 104: gin::V8Initializer::LoadV8Snapshot(,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 134: vvNew[bucket][bucket_position] = entry_index;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 66: s << info;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",1
Line 2: const_cast<int&>(cref) = 5;,void indirectRefChange(const int& cref) {	const_cast<int&>(cref) = 5;	},1
Line 4: numbers.push_back(value);,"//SE		void add_element(std::vector<int>& numbers, int value) {	numbers.push_back(value);	}",1
"Line 5: Attempt_(addr, fCountFailure, time);","void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	LOCK(cs);	Check();	Attempt_(addr, fCountFailure, time);	Check();	}",1
Line 46: throw std::ios_base::failure(,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 2: sSval *= sSval;,void squareSelf(int& sSval) {	sSval *= sSval;	},1
"Line 5: auto addrRet = Select_(new_only, networks);","std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	LOCK(cs);	Check();	auto addrRet = Select_(new_only, networks);	Check();	return addrRet;	}",1
"Line 5: SetServices_(addr, nServices);","void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)	{	LOCK(cs);	Check();	SetServices_(addr, nServices);	Check();	}",1
Line 36: m_network_counts[infoOld.GetNetwork()].n_tried--;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",1
Line 91: *base::CommandLine::ForCurrentProcess());,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
"Line 9: LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());","bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;	}",1
Line 12: addressRet = PubKeyDestination(pubKey);,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",1
Line 9: entry = -1;,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",1
Line 94: command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 34: vvTried[nKBucket][nKBucketPos] = -1;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",1
Line 57: m_tried_collisions.erase(it++);,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",1
"Line 98: crash_reporter::InitializeCrashpad(false, ""node"");","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 2: x++;,int incrementedNotLocal() {	x++;	return x;	},1
Line 14: info.m_last_try = time;,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",1
Line 29: s >> nKey;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 14: entry = -1;,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",1
Line 13: time_penalty = 0s;,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",1
Line 173: node::FreeEnvironment(env);,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 2: pointed = &ref;,"void changePoint(int* pointed, int& ref) {	pointed = &ref;	}",1
Line 76: mapAddr[info] = nIdCount;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
"Line 9: AddrInfo* pinfo = Find(addr, &nId);","bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",1
"Line 7: os_env->UnSetVar(""NODE_OPTIONS"");","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
"Line 15: << "" is not supported in Electron"";","void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",1
"Line 160: LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 6: verifier >> pchMsgTmp;,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",1
"Line 14: LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));","bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",1
Line 12: vRandom.pop_back();,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",1
Line 5: AddrInfo* pinfo = Find(addr);,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",1
"Line 19: if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",1
Line 18: ,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",1
Line 54: s << nNew;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",1
Line 67: s >> info;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
"Line 3: return m_impl->Add(vAddr, source, time_penalty);","bool AddrMan::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	return m_impl->Add(vAddr, source, time_penalty);	}",1
Line 7: cache[n] = fibonacci(n - 1) + fibonacci(n - 2);,"int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;	if (cache.find(n) != cache.end()) return cache[n];		cache[n] = fibonacci(n - 1) + fibonacci(n - 2);	return cache[n];	}",1
"Line 89: crash_reporter::InitializeCrashpad(false, ""node"");","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 13: *pnId = nId;,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",1
Line 3: return m_impl->SelectTriedCollision();,"std::pair<CAddress, NodeSeconds> AddrMan::SelectTriedCollision()	{	return m_impl->SelectTriedCollision();	}",1
Line 11: m_network_counts[info.GetNetwork()].n_new--;,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",1
"Line 9: FILE *file = fsbridge::fopen(pathTmp, ""wb"");","bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",1
Line 58: s << nUBuckets;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",1
"Line 9: AddrInfo* pinfo = Find(addr, &nId);","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",1
Line 5: global_array[index] = value;,"// 6. Modifies a global array	int global_array[10] = {0};	void update_global_array(int index, int value) {	if (index >= 0 && index < 10) {	global_array[index] = value;	}	}",1
"Line 8: os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 11: m_network_counts[addr.GetNetwork()].n_new++;,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",1
Line 64: vvNew[nUBucket][nUBucketPos] = nId;,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",1
"Line 16: LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",1
Line 55: s << nTried;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",1
Line 10: nNew++;,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",1
"Line 8: DeserializeDB(filein, data);","void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};	if (filein.IsNull()) {	throw DbNotFoundError{};	}	DeserializeDB(filein, data);	}",1
Line 3: std::cin >> input;,"void read_user_input(int& input) {	std::cout << ""Enter a number: "";	std::cin >> input;	}",1
Line 12: fileout.fclose();,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",1
Line 143: ++info.nRefCount;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
"Line 6: mapInfo[nId] = AddrInfo(addr, addrSource);","AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",1
Line 4: global_count++;,// 1. Modifies a global variable	int global_count = 0;	void increment_global_count() {	global_count++;	},1
"Line 41: LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",1
Line 85: s << nSize;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",1
"Line 3: m_impl->Attempt(addr, fCountFailure, time);","void AddrMan::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	m_impl->Attempt(addr, fCountFailure, time);	}",1
Line 109: s >> serialized_asmap_checksum;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
"Line 3: FILE* file = fsbridge::fopen(path, ""rb"");","void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};	if (filein.IsNull()) {	throw DbNotFoundError{};	}	DeserializeDB(filein, data);	}",1
Line 7: if (!fs::exists(m_banlist_json)) {,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",1
"Line 9: throw std::runtime_error{""Invalid network magic number""};","void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",1
Line 20: fileout.fclose();,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",1
"Line 39: DCHECK(base::StringToInt(fd_string, &fd));","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 54: for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 50: nid_type node_id;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 79: chance_factor *= 1.2;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 1: bool is_prime(int n) {,bool is_prime(int n) {	if (n <= 1) return false;	for (int i = 2; i * i <= n; ++i) {	if (n % i == 0) return false;	}	return true;	},0
"Line 1: bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)","bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
"Line 87: crash_reporter::switches::kCrashpadHandlerPid, pid_string);","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 20: ,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 18: ,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 5: },bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 1: bool is_initialized = false;,bool is_initialized = false;		void initialize() {	is_initialized = true;	},0
Line 80: int nSize = 0;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 107: uint256 serialized_asmap_checksum;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 1: void AutoUpdater::CheckForUpdates() {},void AutoUpdater::CheckForUpdates() {},0
Line 1: int modifyPoint(int* points) {,int modifyPoint(int* points) {	*points += 1;	return *points;	},0
Line 68: const auto it_found{mapInfo.find(node_id)};,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 2: {,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 1: v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {,"v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {	std::map<std::string, std::string> keys;	#if !IS_MAS_BUILD()	electron::crash_keys::GetCrashKeys(&keys);	#endif	return gin::ConvertToV8(isolate, keys);	}",0
"Line 89: std::vector<std::pair<int, int>> bucket_entries;","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 11: },"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 174: node::FreeIsolateData(isolate_data);,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 103: return 0;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 55: if (vvTried[n][i] != -1) {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 31: WitnessV0ScriptHash hash;,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 121: AddrInfo& info = mapInfo[entry_index];,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 36: return -5;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 7: },class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 6: Check();,std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{	LOCK(cs);	Check();	auto entry = FindAddressEntry_(addr);	Check();	return entry;	},0
Line 1: void AddrMan::Serialize(Stream& s_) const,void AddrMan::Serialize(Stream& s_) const	{	m_impl->Serialize<Stream>(s_);	},0
Line 22: },"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
"Line 1: bool SerializeDB(Stream& stream, const Data& data)","bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;	}",0
"Line 24: ""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 106: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 5: , m_netgroupman{netgroupman}","AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",0
Line 18: // Serialize,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 13: },bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 7: return nullptr;,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",0
Line 3: return false;,"bool AutoUpdater::IsVersionAllowedForUpdate(const std::string& current_version,	const std::string& target_version) {	return false;	}",0
Line 5: evens.push_back(num);,vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {	evens.push_back(num);	}	}	return evens;	},0
Line 6: Check();,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()	{	LOCK(cs);	Check();	auto ret = SelectTriedCollision_();	Check();	return ret;	}",0
Line 9: return content;,"// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content	file.close();	}	return content;	}",0
Line 2: if (n <= 1) return false;,bool is_prime(int n) {	if (n <= 1) return false;	for (int i = 2; i * i <= n; ++i) {	if (n % i == 0) return false;	}	return true;	},0
Line 31: ,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 17: },"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 48: return true;,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 10: *   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 4: ,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;	}",0
Line 13: return fChance;,"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;	}",0
Line 7: return vvTried[bucket][position];,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;	}",0
Line 156: &electron::crash_keys::ClearCrashKey);,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 9: return;,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Line 56: const auto it{mapInfo.find(node_id)};,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 3: return CScript() << OP_0 << ToByteVector(id);,CScript operator()(const WitnessV0KeyHash& id) const	{	return CScript() << OP_0 << ToByteVector(id);	},0
Line 101: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 44: m_tried_collisions.size());,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
"Line 1: bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr)","bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr)	{	const auto pathAddr = args.GetDataDirNet() / ""peers.dat"";	return SerializeFileDB(""peers"", pathAddr, addr);	}",0
"Line 11: std::map<std::string, common::SettingsValue> settings;","bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Line 1: int absolute_value(int x) {,int absolute_value(int x) {	return (x < 0) ? -x : x;	},0
Line 5: bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 12: const auto key = std::string_view{arg}.substr(0, arg.find('='));","void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Line 2: {,void AddrManImpl::ResolveCollisions()	{	LOCK(cs);	Check();	ResolveCollisions_();	Check();	},0
Line 2: if (n == 0) {,int factorial(int n) {	if (n == 0) {	return 1;	}	return n * factorial(n - 1);	},0
Line 23: * * all tried addresses (total count: nTried),"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 3: },int squareReference(int& sRval) { // returning square of input passed in by reference	return sRval * sRval;	},0
"Line 20: // nTime is not updated here, to avoid leaking information about","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 12: if (pnId),"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",0
"Line 143: gin_helper::Dictionary process(isolate, env->process_object());","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 3: },"int max_of_three(int a, int b, int c) {	return std::max({a, b, c});	}",0
Line 21: const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 3: LOCK(cs);,"void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)	{	LOCK(cs);	Check();	SetServices_(addr, nServices);	Check();	}",0
Line 4: int n = numbers.size();,"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {	return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;	} else {	return numbers[n / 2];	}	}",0
Line 41: */,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 8: ,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 8: const auto start{SteadyClock::now()};,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 6: if (max_pct != 0) {,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 3: AssertLockHeld(cs);,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;	}",0
"Line 44: ParamsStream s{s_, CAddress::V2_DISK};","void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 3: uint64_t hash1 = (HashWriter{} << nKey << (fNew ? uint8_t{'N'} : uint8_t{'K'}) << bucket << GetKey()).GetCheapHash();,"int AddrInfo::GetBucketPosition(const uint256& nKey, bool fNew, int bucket) const	{	uint64_t hash1 = (HashWriter{} << nKey << (fNew ? uint8_t{'N'} : uint8_t{'K'}) << bucket << GetKey()).GetCheapHash();	return hash1 % ADDRMAN_BUCKET_SIZE;	}",0
Line 6: return hash2 % ADDRMAN_NEW_BUCKET_COUNT;,"int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const	{	std::vector<unsigned char> vchSourceGroupKey = netgroupman.GetGroup(src);	uint64_t hash1 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << vchSourceGroupKey).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_NEW_BUCKET_COUNT;	}",0
Line 24: case TxoutType::WITNESS_V0_KEYHASH: {,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 9: },vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {	evens.push_back(num);	}	}	return evens;	},0
Line 8: if (IsUrlArg(arg)),bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;	}	return true;	},0
Line 27: // do not update if no new information is present,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 8: return cache[n];,"int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;	if (cache.find(n) != cache.end()) return cache[n];		cache[n] = fibonacci(n - 1) + fibonacci(n - 2);	return cache[n];	}",0
Line 21: int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 176: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 183: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 27: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 11: #if BUILDFLAG(IS_MAC),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 17: const AddrInfo& info = entry.second;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
"Line 51: int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);","bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 25: pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 2: // Options that are unilaterally disallowed.,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Line 4: },CScript operator()(const ScriptHash& scriptID) const	{	return CScript() << OP_HASH160 << ToByteVector(scriptID) << OP_EQUAL;	},0
"Line 14: // Addrman can be in an inconsistent state after failure, reset it","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 21: try {,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
"Line 1: void AddrMan::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)","void AddrMan::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	m_impl->Attempt(addr, fCountFailure, time);	}",0
Line 1: bool is_even(int x) {,bool is_even(int x) {	return x % 2 == 0;	},0
Line 5: #include <iostream>,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;	}",0
Line 2: {,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 145: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 11: if (fileout.IsNull()) {,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 80: mapNew.erase(vvNew[n][i]);,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 9: if(addr_info->fInTried) {,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 2: {,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Line 1: bool IsValidDestination(const CTxDestination& dest) {,"bool IsValidDestination(const CTxDestination& dest) {	return std::visit(ValidDestinationVisitor(), dest);	}",0
"Line 19: //                               NODE_OPTIONS: ""--require 'bad.js'""}})","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 89: if (nKey.IsNull()),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 3: return x;,int squareGlobal() {	x *= x;	return x;	},0
Line 2: vector<int> evens;,vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {	evens.push_back(num);	}	}	return evens;	},0
Line 19: if (!info_new.IsValid()) { // id_new may no longer map to a valid address,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 7: },"void write_to_file(const std::string& filename, const std::string& content) {	std::ofstream file(filename);	if (file.is_open()) {	file << content;	file.close();	}	}",0
Line 30: // which tried bucket to move the entry to,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 3: LOCK(cs);,"bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	LOCK(cs);	Check();	auto ret = Add_(vAddr, source, time_penalty);	Check();	return ret;	}",0
Line 7: return addrRet;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	LOCK(cs);	Check();	auto addrRet = Select_(new_only, networks);	Check();	return addrRet;	}",0
"Line 11: return AddressPosition(/*tried_in=*/true,","std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 20: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 20: ,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
"Line 13: // On macOS, it is forbidden to run sandboxed app with custom arguments","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 3: LOCK(cs);,std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{	LOCK(cs);	Check();	auto entry = FindAddressEntry_(addr);	Check();	return entry;	},0
Line 22: return false;,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 27: const auto current_time{Now<NodeSeconds>()};,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 145: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 63: return -18;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 3: AssertLockHeld(cs);,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 14: const auto now{Now<NodeSeconds>()};,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 6: if (in_new.has_value()) {,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 4: b = a % b;,"int gcd(int a, int b) {	while (b != 0) {	int temp = b;	b = a % b;	a = temp;	}	return a;	}",0
Line 20: return true;,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
"Line 14: // from another app, i.e. args are discarded in following call:","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 4: },"std::pair<CAddress, NodeSeconds> AddrMan::SelectTriedCollision()	{	return m_impl->SelectTriedCollision();	}",0
Line 12: return &(*it2).second;,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",0
Line 17: *     format=5 will not try to read the file.,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
"Line 75: return {info, info.m_last_try};","std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
"Line 10: // deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.","double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;	}",0
Line 9: const int err{CheckAddrman()};,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}	}",0
Line 2: bool has = false;,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);	has = true;	}	}	return has;	},0
Line 2: int global_array[10] = {0};,"// 6. Modifies a global array	int global_array[10] = {0};	void update_global_array(int index, int value) {	if (index >= 0 && index < 10) {	global_array[index] = value;	}	}",0
Line 4: AutoFile filein{file};,"void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};	if (filein.IsNull()) {	throw DbNotFoundError{};	}	DeserializeDB(filein, data);	}",0
"Line 71: {node::ProcessInitializationFlags::kNoInitializeV8,","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 8: * * lowest compatible format version byte. This is used to help old software decide,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 66: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
"Line 35: std::string fd_string, pid_string;","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 17: },"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 5: if (vRandom.empty()) return {};,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 45: ,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 4: },void netNothing() {	int* temp = new int{42};	delete temp;	},0
Line 14: ,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Line 23: } catch (const std::runtime_error& e) {,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Line 3: LOCK(cs);,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 13: ,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 48: // and looping around.,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 10: if (id >= 0) {,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 13: ,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Line 20: erase_collision = true;,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 24: if (new_only && new_count == 0) return {};,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 8: size_t tried_count = nTried;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 153: Delete(itCopy->first);,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 185: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 31: ,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 71: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 55: AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 2: return M_PI * radius * radius;,double area_of_circle(double radius) {	return M_PI * radius * radius;	},0
Line 72: node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 6: ,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 56: assert(false);,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 3: },"bool IsValidDestination(const CTxDestination& dest) {	return std::visit(ValidDestinationVisitor(), dest);	}",0
Line 3: for (const auto& arg : argv) {,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;	}	return true;	},0
Line 7: } else {,"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {	return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;	} else {	return numbers[n / 2];	}	}",0
Line 60: },"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 10: #include <cstdio>,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
"Line 62: if (it->second.GetBucketPosition(nKey, false, n) != i) {","int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 31: },"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 5: if (filein.IsNull()) {,"void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};	if (filein.IsNull()) {	throw DbNotFoundError{};	}	DeserializeDB(filein, data);	}",0
Line 23: return -2;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 59: break;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 26: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 3: return placeholder;,int* createMem() {	int* placeholder = new int{42};	return placeholder;	},0
Line 157: #endif,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 12: return anchors;,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);	return anchors;	}",0
Line 1: void setSix(){ // setting global variable,void setSix(){ // setting global variable	x = 6;	},0
Line 36: case TxoutType::WITNESS_V1_TAPROOT: {,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 4: Check();,"std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	LOCK(cs);	Check();	auto addresses = GetAddr_(max_addresses, max_pct, network, filtered);	Check();	return addresses;	}",0
Line 68: } else {,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 161: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 2: if (numbers.empty()) return 0.0;,double average(const std::vector<int>& numbers) {	if (numbers.empty()) return 0.0;	int sum = 0;	for (int num : numbers) {	sum += num;	}	return static_cast<double>(sum) / numbers.size();	},0
Line 3: return CKeyID{uint160{key_hash}};,CKeyID ToKeyID(const WitnessV0KeyHash& key_hash)	{	return CKeyID{uint160{key_hash}};	},0
Line 9: ,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",0
Line 3: int get_count() const {,class Counter {	public:	int get_count() const {	return count;	}		private:	int count = 0;	};,0
"Line 26: std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());","bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 1: bool IsSandboxEnabled(base::CommandLine* command_line) {,bool IsSandboxEnabled(base::CommandLine* command_line) {	return command_line->HasSwitch(switches::kEnableSandbox) ||	!command_line->HasSwitch(sandbox::policy::switches::kNoSandbox);	},0
"Line 1: float unrelatedNameToo(float& u, float& v) {","float unrelatedNameToo(float& u, float& v) {	float w = (u = v);	return w;	}",0
"Line 6: auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 11: result *= x;,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;	}",0
Line 135: env = node::CreateEnvironment(,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 5: ,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 5: throw 1;,void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{	int temporary = 0;	}	},0
Line 2: : insecure_rand{deterministic},"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",0
Line 29: },"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Line 38: // Replaces an existing address already in the tried table with the new address,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 110: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 2: {,AddrManImpl::~AddrManImpl()	{	nKey.SetNull();	},0
Line 157: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 6: ,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Line 10: ,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;	}",0
Line 41: return -6;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
"Line 31: int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 13: if (info.nRefCount == 0) break;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 2: {,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",0
"Line 1: std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()","std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()	{	LOCK(cs);	Check();	auto ret = SelectTriedCollision_();	Check();	return ret;	}",0
Line 38: // find which new bucket it belongs to,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 45: infoOld.nRefCount = 1;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
"Line 10: SwapRandom(info.nRandomPos, vRandom.size() - 1);","void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",0
Line 6: },double average(const std::vector<int>& numbers) {	if (numbers.empty()) return 0.0;	int sum = 0;	for (int num : numbers) {	sum += num;	}	return static_cast<double>(sum) / numbers.size();	},0
Line 2: {,void AddrMan::ResolveCollisions()	{	m_impl->ResolveCollisions();	},0
Line 6: },void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{	int temporary = 0;	}	},0
Line 11: nid_type id_new = *it;,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 103: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 1: void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)","void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	LOCK(cs);	Check();	Attempt_(addr, fCountFailure, time);	Check();	}",0
"Line 1: void SetCrashKeyStub(const std::string& key, const std::string& value) {}","void SetCrashKeyStub(const std::string& key, const std::string& value) {}",0
Line 6: ,class Counter {	public:	int get_count() const {	return count;	}		private:	int count = 0;	};,0
Line 13: return result;,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;	}",0
Line 1: void read_user_input(int& input) {,"void read_user_input(int& input) {	std::cout << ""Enter a number: "";	std::cin >> input;	}",0
Line 48: // Increment `lowest_compatible` iff a newly introduced format is incompatible with,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 11: },"bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;		const auto& c_locale = std::locale::classic();	const auto isspace = [&](auto ch) { return std::isspace(ch, c_locale); };	const auto scheme = arg.substr(0U, scheme_end);	return std::size(scheme) > 1U && std::isalpha(scheme.front(), c_locale) &&	std::ranges::none_of(scheme, isspace);	}",0
Line 8: },int reverse_number(int num) {	int reversed = 0;	while (num != 0) {	reversed = reversed * 10 + num % 10;	num /= 10;	}	return reversed;	},0
Line 8: const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 30: ,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 7: if (nTime > now + 10min) { // came in a flying DeLorean,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 43: if (info.m_last_success < NodeSeconds{0s}) {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 33: ,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 19: },"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 2: {,"std::pair<CAddress, NodeSeconds> AddrMan::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	return m_impl->Select(new_only, networks);	}",0
Line 4: std::string content;,"// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content	file.close();	}	return content;	}",0
Line 10: ,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",0
"Line 14: /*multiplicity_in=*/from_tried ? 1 : info.nRefCount,","std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 10: },"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",0
Line 128: // this bucket_entry.,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 17: },"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",0
"Line 177: // According to ""src/gin/shell/gin_main.cc"":","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 1: std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const","std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
"Line 32: // do not update if the entry was already in the ""tried"" table","bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
"Line 18: ""is lower than the expected minimum value %u."",","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 23: },"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 1: CScript operator()(const WitnessV0ScriptHash& id) const,CScript operator()(const WitnessV0ScriptHash& id) const	{	return CScript() << OP_0 << ToByteVector(id);	},0
Line 37: ,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 5: },"bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr)	{	const auto pathAddr = args.GetDataDirNet() / ""peers.dat"";	return SerializeFileDB(""peers"", pathAddr, addr);	}",0
Line 1: bool operator()(const PKHash& dest) const { return true; },bool operator()(const PKHash& dest) const { return true; },0
Line 4: ,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 2: {,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Line 4: if (n % i == 0) return false;,bool is_prime(int n) {	if (n <= 1) return false;	for (int i = 2; i * i <= n; ++i) {	if (n % i == 0) return false;	}	return true;	},0
Line 16: position);,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 4: },"WitnessV0ScriptHash::WitnessV0ScriptHash(const CScript& in)	{	CSHA256().Write(in.data(), in.size()).Finalize(begin());	}",0
Line 175: },"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 1: void indirectPointChange(const int* cpoint) {,void indirectPointChange(const int* cpoint) {	*const_cast<int*>(cpoint) = 5;	},0
Line 2: {,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);	return anchors;	}",0
Line 9: ,"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;	}",0
Line 4: },CScriptID ToScriptID(const ScriptHash& script_hash)	{	return CScriptID{uint160{script_hash}};	},0
Line 4: },int get_next_id() {	static int id = 0;	return ++id;	},0
Line 16: addresses.reserve(nNodes);,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 2: {,"bool AddrMan::Good(const CService& addr, NodeSeconds time)	{	return m_impl->Good(addr, time);	}",0
"Line 41: nNew,","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 10: if (err) {,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}	}",0
Line 78: },"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 8: },bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);	has = true;	}	}	return has;	},0
Line 6: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 4: },int* createMem() {	int* placeholder = new int{42};	return placeholder;	},0
Line 6: Check();,"std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	LOCK(cs);	Check();	auto addresses = GetAddr_(max_addresses, max_pct, network, filtered);	Check();	return addresses;	}",0
"Line 23: int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);","std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 18: auto counts = it->second;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 4: auto os_env = base::Environment::Create();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 2: {,"std::pair<CAddress, NodeSeconds> AddrMan::SelectTriedCollision()	{	return m_impl->SelectTriedCollision();	}",0
Line 4: ,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 8: for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 3: int sum = 0;,double average(const std::vector<int>& numbers) {	if (numbers.empty()) return 0.0;	int sum = 0;	for (int num : numbers) {	sum += num;	}	return static_cast<double>(sum) / numbers.size();	},0
"Line 6: strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);","int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 56: info.fInTried = true;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 4: },int squareGlobal() {	x *= x;	return x;	},0
Line 4: },void AddrMan::Serialize(Stream& s_) const	{	m_impl->Serialize<Stream>(s_);	},0
Line 4: return false;,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
"Line 9: const int pos{info.GetBucketPosition(nKey, true, bucket)};","void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 3: AssertLockHeld(cs);,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 72: },"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 69: },"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 49: // the previous one.,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
"Line 38: std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());","bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 28: return true;,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Line 22: return infos;,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
"Line 1: void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)","void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",0
Line 4: Check();,"size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	LOCK(cs);	Check();	auto ret = Size_(net, in_new);	Check();	return ret;	}",0
Line 51: for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
"Line 3: // Write and commit header, data","bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;	}",0
Line 9: --right;,bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;	}	return true;	},0
Line 7: assert(!info.fInTried);,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",0
Line 8: fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 54: AddrInfo& info = mapInfo[n];,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 52: ,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 22: // environment variables that may be used to inject scripts are removed.,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 68: std::unique_ptr<node::InitializationResult> result =,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 19: const auto update_interval{currently_online ? 1h : 24h};,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 70: if (info.IsValid(),"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 1: #include <vector>,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;	}",0
Line 6: hashwriter << Params().MessageStart() << data;,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;	}",0
Line 5: for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 6: return privateint_;,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 15: } else {,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 8: } catch (const std::exception& e) {,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;	}",0
Line 51: },"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 3: !command_line->HasSwitch(sandbox::policy::switches::kNoSandbox);,bool IsSandboxEnabled(base::CommandLine* command_line) {	return command_line->HasSwitch(switches::kEnableSandbox) ||	!command_line->HasSwitch(sandbox::policy::switches::kNoSandbox);	},0
Line 33: ,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
"Line 1: double distance(double x1, double y1, double x2, double y2) {","double distance(double x1, double y1, double x2, double y2) {	return std::sqrt(std::pow(x2 - x1, 2) + std::pow(y2 - y1, 2));	}",0
Line 3: AssertLockHeld(cs);,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 29: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 26: } else {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 2: {,CScript operator()(const WitnessV0KeyHash& id) const	{	return CScript() << OP_0 << ToByteVector(id);	},0
Line 3: AssertLockHeld(cs);,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 4: ,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 31: * deserialization.,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 64: int nLost = 0;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 2: static std::unordered_map<int, int> cache;","int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;	if (cache.find(n) != cache.end()) return cache[n];		cache[n] = fibonacci(n - 1) + fibonacci(n - 2);	return cache[n];	}",0
Line 12: ,"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;	}",0
Line 84: ,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 33: if (pinfo->fInTried),"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 3: uint64_t hash1 = (HashWriter{} << nKey << GetKey()).GetCheapHash();,"int AddrInfo::GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const	{	uint64_t hash1 = (HashWriter{} << nKey << GetKey()).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;	}",0
Line 61: for (const auto& entry : mapInfo) {,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
"Line 1: void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)","void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Line 7: },bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;	}	return true;	},0
Line 53: for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 29: if (!info.nRefCount),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 1: class myClass {,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 13: auto net_count = it->second;,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 4: },CScript operator()(const PubKeyDestination& dest) const	{	return CScript() << ToByteVector(dest.GetPubKey()) << OP_CHECKSIG;	},0
Line 16: if (pinfo) {,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 40: * very little in common.,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 4: ,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 148: // Prune new entries with refcount 0 (as a result of collisions or invalid address).,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 3: return CScript() << CScript::EncodeOP_N(id.GetWitnessVersion()) << id.GetWitnessProgram();,CScript operator()(const WitnessUnknown& id) const	{	return CScript() << CScript::EncodeOP_N(id.GetWitnessVersion()) << id.GetWitnessProgram();	},0
Line 12: },"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;	}",0
Line 14: if (mapInfo.count(id_new) != 1) {,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 7: std::set<nid_type>::iterator it = m_tried_collisions.begin();,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 56: if (erase_collision) {,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
"Line 148: reporter.SetMethod(""getParameters"", &GetParameters);","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 3: LOCK(cs);,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 10: nid_type nId1 = vRandom[nRndPos1];,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 19: },"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
"Line 1: void ReadFromStream(AddrMan& addr, DataStream& ssPeers)","void ReadFromStream(AddrMan& addr, DataStream& ssPeers)	{	DeserializeDB(ssPeers, addr, false);	}",0
Line 3: static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Line 4: // de-serialize file header (network specific magic number) and ..,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Line 72: const AddrInfo& info = entry.second;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 1: double area_of_circle(double radius) {,double area_of_circle(double radius) {	return M_PI * radius * radius;	},0
Line 2: {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 79: if (--mapNew[vvNew[n][i]] == 0),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 4: ,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 6: Check();,"bool AddrManImpl::Good(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	auto ret = Good_(addr, /*test_before_evict=*/true, time);	Check();	return ret;	}",0
Line 65: const std::vector<std::string> args = ElectronCommandLine::AsUtf8();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 3: std::vector<std::string> errors;,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);	}	return false;	}",0
Line 9: #include <unistd.h>,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 2: {,"size_t AddrMan::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	return m_impl->Size(net, in_new);	}",0
Line 26: },"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 110: // Allow Node.js to track the amount of time the event loop has spent,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 12: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 31: search_tried = false;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 55: ,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 1: void squareSelf(int& sSval) {,void squareSelf(int& sSval) {	sSval *= sSval;	},0
"Line 25: DumpPeerAddresses(args, *addrman);","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 54: },"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 35: search_tried = insecure_rand.randbool();,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 1: int find_max(const std::vector<int>& numbers) {,"int find_max(const std::vector<int>& numbers) {	if (numbers.empty()) return 0;  // Return 0 for an empty list	return *std::max_element(numbers.begin(), numbers.end());	}",0
Line 8: AddrInfo& infoDelete = mapInfo[nIdDelete];,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",0
Line 1: CScript operator()(const WitnessV0KeyHash& id) const,CScript operator()(const WitnessV0KeyHash& id) const	{	return CScript() << OP_0 << ToByteVector(id);	},0
Line 29: bool search_tried;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 3: while (num != 0) {,int reverse_number(int num) {	int reversed = 0;	while (num != 0) {	reversed = reversed * 10 + num % 10;	num /= 10;	}	return reversed;	},0
Line 61: },"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 52: // Deserialize entries from the new table.,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 3: },int main() {	cout << sum(testArray) << endl;	},0
Line 4: Check();,"void AddrManImpl::Connected(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	Connected_(addr, time);	Check();	}",0
Line 109: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 1: std::pair<CAddress, NodeSeconds> AddrMan::Select(bool new_only, const std::unordered_set<Network>& networks) const","std::pair<CAddress, NodeSeconds> AddrMan::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	return m_impl->Select(new_only, networks);	}",0
"Line 127: // ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 4: },void AddrMan::Unserialize(Stream& s_)	{	m_impl->Unserialize<Stream>(s_);	},0
Line 18: },"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 5: #endif,"v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {	std::map<std::string, std::string> keys;	#if !IS_MAS_BUILD()	electron::crash_keys::GetCrashKeys(&keys);	#endif	return gin::ConvertToV8(isolate, keys);	}",0
Line 12: AddressPosition location = AddressPosition(,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 19: // consistency.,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Line 5: if (cache.find(n) != cache.end()) return cache[n];,"int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;	if (cache.find(n) != cache.end()) return cache[n];		cache[n] = fibonacci(n - 1) + fibonacci(n - 2);	return cache[n];	}",0
Line 15: },"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",0
Line 4: for (int i = 0; i < array_to_sum.size(); ++i) {,int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {	sum_total += array_to_sum[i];	}		return sum_total;	},0
Line 12: tried_count = 0;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 2: int left = 0;,bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;	}	return true;	},0
"Line 36: if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 10: int privateint_;,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 11: // Do not set a penalty for a source's self-announcement,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
"Line 42: // Following API is unsafe in multi-threaded scenario, but at this point","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 1: int* createMem() {,int* createMem() {	int* placeholder = new int{42};	return placeholder;	},0
Line 1: //SEF,//SEF		int stringLength(const string &s) {	return s.length();	},0
Line 1: void AddrMan::ResolveCollisions(),void AddrMan::ResolveCollisions()	{	m_impl->ResolveCollisions();	},0
Line 2: {,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",0
Line 138: // try to give them a reference based on their primary source address.,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 2: changed = 5;,void changeWithin(int changed) {	changed = 5;	},0
Line 9: return vRandom.size();,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 15: for (const auto& err : errors) {,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Line 10: ,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 14: return &mapInfo[nId];,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",0
"Line 42: colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 11: mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 7: if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}	}",0
Line 9: int result = 1;,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;	}",0
Line 2: {,std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{	LOCK(cs);	Check();	auto entry = FindAddressEntry_(addr);	Check();	return entry;	},0
Line 63: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 3: std::vector<CAddress> anchors;,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);	return anchors;	}",0
Line 7: },bool isPalindrome(const string &s) {	int len = s.size();	for (int i = 0; i < len / 2; ++i) {	if (s[i] != s[len - i - 1]) {	return false;	}	}	return true;	},0
Line 82: if (vvNew[bucket][i] != -1),"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 70: const AddrInfo& info{it_found->second};,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 117: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 3: },double area_of_circle(double radius) {	return M_PI * radius * radius;	},0
Line 17: for (unsigned int n = 0; n < vRandom.size(); n++) {,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 77: return -19;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 22: },"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Line 75: const auto it{mapInfo.find(vvNew[n][i])};,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 12: erase_collision = true;,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 53: for (int n = 0; n < nNew; n++) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 7: fChance *= 0.01;,"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;	}",0
"Line 1: std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const","std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	LOCK(cs);	Check();	auto addrRet = Select_(new_only, networks);	Check();	return addrRet;	}",0
Line 40: auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 7: nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",0
"Line 22: int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);","void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 11: },"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",0
Line 16: },"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",0
Line 6: nid_type id_new = *it;,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 2: {,CScript operator()(const WitnessV1Taproot& tap) const	{	return CScript() << OP_1 << ToByteVector(tap);	},0
Line 6: Check();,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	LOCK(cs);	Check();	auto addrRet = Select_(new_only, networks);	Check();	return addrRet;	}",0
Line 1: class myClass {,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
"Line 1: std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const","std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const	{	LOCK(cs);	Check();	auto addrInfos = GetEntries_(from_tried);	Check();	return addrInfos;	}",0
Line 1: void AddrManImpl::ResolveCollisions_(),"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 2: {,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()	{	LOCK(cs);	Check();	auto ret = SelectTriedCollision_();	Check();	return ret;	}",0
Line 62: mapUnkIds[entry.first] = nIds;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 9: },"void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};	if (filein.IsNull()) {	throw DbNotFoundError{};	}	DeserializeDB(filein, data);	}",0
Line 2: {,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 11: AddrInfo& info = *pinfo;,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",0
"Line 97: for (const auto& [net, count] : m_network_counts) {","int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 13: },"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;	}",0
Line 5: void setPrivateInt(int value) { // SE,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 8: if (!pinfo),"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Line 57: return -11;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 63: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 42: case TxoutType::ANCHOR: {,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 21: },"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Line 94: for (int n = 0; n < num_entries; ++n) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 4: ,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;	}",0
Line 90: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 5: return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;,"int AddrInfo::GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const	{	uint64_t hash1 = (HashWriter{} << nKey << GetKey()).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;	}",0
Line 3: AssertLockHeld(cs);,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 5: if (m_tried_collisions.size() == 0) return {};,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 11: *     introduced in version N+1 that is compatible with format=3 and it is known that,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
"Line 1: void remove_element(std::vector<int>& numbers, int value) {","void remove_element(std::vector<int>& numbers, int value) {	numbers.erase(std::remove(numbers.begin(), numbers.end(), value), numbers.end());	}",0
"Line 1: AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)","AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",0
Line 5: sum_total += array_to_sum[i];,int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {	sum_total += array_to_sum[i];	}		return sum_total;	},0
Line 37: if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS),"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 11: } else {,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 38: },"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 8: return evens;,vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {	evens.push_back(num);	}	}	return evens;	},0
Line 59: base::FeatureList::SetInstance(std::move(feature_list));,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 12: };,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 4: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 74: return -12;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 28: if (addr.nTime <= pinfo->nTime) {,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 13: for (auto& network : networks) {,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 3: #include <algorithm>,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;	}",0
Line 132: if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 55: if (!networks.empty()) {,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 2: {,"int AddrInfo::GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const	{	uint64_t hash1 = (HashWriter{} << nKey << GetKey()).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;	}",0
"Line 7: ""--use-bundled-ca"",","void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Line 3: LOCK(cs);,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()	{	LOCK(cs);	Check();	auto ret = SelectTriedCollision_();	Check();	return ret;	}",0
Line 4: },CScript operator()(const WitnessUnknown& id) const	{	return CScript() << CScript::EncodeOP_N(id.GetWitnessVersion()) << id.GetWitnessProgram();	},0
Line 86: command_line->AppendSwitchASCII(,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 3: void add_element(std::vector<int>& numbers, int value) {","//SE		void add_element(std::vector<int>& numbers, int value) {	numbers.push_back(value);	}",0
Line 2: {,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;	}",0
Line 2: int sum_total = 0;,int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {	sum_total += array_to_sum[i];	}		return sum_total;	},0
Line 22: return true;,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 5: const auto it = mapAddr.find(addr);,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",0
Line 42: assert(vvNew[nUBucket][nUBucketPos] == -1);,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 28: return false;,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 4: },CScript operator()(const WitnessV0ScriptHash& id) const	{	return CScript() << OP_0 << ToByteVector(id);	},0
Line 8: },"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;	}",0
"Line 1: // Copyright (c) 2022 Slack Technologies, Inc.","// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 10: ,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 79: },"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 19: },"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 2: {,"void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& anchors)	{	LOG_TIME_SECONDS(strprintf(""Flush %d outbound block-relay-only peer addresses to anchors.dat"", anchors.size()));	SerializeFileDB(""anchors"", anchors_db_path, CAddress::V2_DISK(anchors));	}",0
Line 5: /**,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
"Line 153: reporter.SetMethod(""addExtraParameter"",","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 1: void AddrMan::Unserialize(Stream& s_),void AddrMan::Unserialize(Stream& s_)	{	m_impl->Unserialize<Stream>(s_);	},0
"Line 1: size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const","size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	LOCK(cs);	Check();	auto ret = Size_(net, in_new);	Check();	return ret;	}",0
Line 1: bool operator()(const WitnessV0ScriptHash& dest) const { return true; },bool operator()(const WitnessV0ScriptHash& dest) const { return true; },0
Line 2: {,"bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr)	{	const auto pathAddr = args.GetDataDirNet() / ""peers.dat"";	return SerializeFileDB(""peers"", pathAddr, addr);	}",0
Line 55: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 2: // Use of this source code is governed by the MIT license that can be,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 28: // Filter by network (optional),"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
"Line 38: int fd = -1, pid = -1;","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 19: //,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 2: public:,class Counter {	public:	int get_count() const {	return count;	}		private:	int count = 0;	};,0
Line 71: },"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 1: WitnessV0ScriptHash::WitnessV0ScriptHash(const CScript& in),"WitnessV0ScriptHash::WitnessV0ScriptHash(const CScript& in)	{	CSHA256().Write(in.data(), in.size()).Finalize(begin());	}",0
Line 2: #include <string>,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;	}",0
"Line 10: std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));","std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 15: if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 35: if (current_time - info_old.m_last_try > 60s) {,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 2: while (b != 0) {,"int gcd(int a, int b) {	while (b != 0) {	int temp = b;	b = a % b;	a = temp;	}	return a;	}",0
Line 3: delete temp;,void netNothing() {	int* temp = new int{42};	delete temp;	},0
Line 4: if (index >= 0 && index < 10) {,"// 6. Modifies a global array	int global_array[10] = {0};	void update_global_array(int index, int value) {	if (index >= 0 && index < 10) {	global_array[index] = value;	}	}",0
Line 27: },"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 58: const auto it{mapInfo.find(vvTried[n][i])};,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
"Line 25: ""but the maximum supported by this version of %s is %u."",","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 144: process.SetMethod(""crash"", &ElectronBindings::Crash);","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 40: },"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 4: Check();,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()	{	LOCK(cs);	Check();	auto ret = SelectTriedCollision_();	Check();	return ret;	}",0
Line 10: // If id_new not found in mapInfo remove it from m_tried_collisions,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 50: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 10: for (int i = 0; i < y; ++i) {,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;	}",0
Line 6: return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;,"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {	return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;	} else {	return numbers[n / 2];	}	}",0
Line 8: #include <sys/stat.h>,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 1: void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Line 2: {,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",0
Line 8: ,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 15: if (it == m_network_counts.end()) {,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 3: return CScript() << OP_0 << ToByteVector(id);,CScript operator()(const WitnessV0ScriptHash& id) const	{	return CScript() << OP_0 << ToByteVector(id);	},0
Line 29: // Has successfully connected in last X hours,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
"Line 87: // An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 5: if (file.is_open()) {,"// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content	file.close();	}	return content;	}",0
Line 33: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 86: for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 105: // serialization.,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 2: std::string reversed = str;,"std::string reverse_string(const std::string& str) {	std::string reversed = str;	std::reverse(reversed.begin(), reversed.end());	return reversed;	}",0
Line 25: local_counts[info.GetNetwork()].n_tried++;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 6: ,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 22: ,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 1: AddrManImpl::~AddrManImpl(),AddrManImpl::~AddrManImpl()	{	nKey.SetNull();	},0
Line 97: if (entry_index >= 0 && entry_index < nNew) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 4: ,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 1: CScript operator()(const WitnessV1Taproot& tap) const,CScript operator()(const WitnessV1Taproot& tap) const	{	return CScript() << OP_1 << ToByteVector(tap);	},0
Line 7: return a;,"int gcd(int a, int b) {	while (b != 0) {	int temp = b;	b = a % b;	a = temp;	}	return a;	}",0
Line 46: },"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 5: nid_type nId;,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
"Line 17: infos.emplace_back(info, location);","std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 35: },"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 52: erase_collision = true;,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
"Line 55: } // no default case, so the compiler can warn about missing cases","bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 3: std::vector<valtype> vSolutions;,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 28: ,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 3: return w;,"float unrelatedNameToo(float& u, float& v) {	float w = (u = v);	return w;	}",0
"Line 17: // Otherwise, an unrelated file descriptor will be assigned as stdout/stderr","// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
"Line 20: return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 4: return false;,"bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;		const auto& c_locale = std::locale::classic();	const auto isspace = [&](auto ch) { return std::isspace(ch, c_locale); };	const auto scheme = arg.substr(0U, scheme_end);	return std::size(scheme) > 1U && std::isalpha(scheme.front(), c_locale) &&	std::ranges::none_of(scheme, isspace);	}",0
"Line 22: if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)","// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 3: },double celsius_to_fahrenheit(double celsius) {	return (celsius * 9.0 / 5.0) + 32.0;	},0
Line 3: },void indirectRefChange(const int& cref) {	const_cast<int&>(cref) = 5;	},0
Line 26: },"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Line 35: if (it == mapAddr.end() || it->second != n) {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 45: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 4: },"void AddrMan::SetServices(const CService& addr, ServiceFlags nServices)	{	m_impl->SetServices(addr, nServices);	}",0
Line 30: * as incompatible. This is necessary because it did not check the version number on,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 2: return *point;,int pointedInt(int* point) {	return *point;	},0
"Line 130: isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 1: int AddrManImpl::CheckAddrman() const,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
"Line 139: bucket = info.GetNewBucket(nKey, m_netgroupman);","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 2: return (x < 0) ? -x : x;,int absolute_value(int x) {	return (x < 0) ? -x : x;	},0
Line 1: void AutoUpdater::SetDelegate(Delegate* delegate) {,void AutoUpdater::SetDelegate(Delegate* delegate) {	delegate_ = delegate;	},0
Line 40: return true;,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 132: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 2: {,"size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	LOCK(cs);	Check();	auto ret = Size_(net, in_new);	Check();	return ret;	}",0
Line 61: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 149: int nLostUnk = 0;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 167: check_code));,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 4: ,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",0
Line 3: return w;,"float unrelatedName(float u, float v) {	float w = (u = v);	return w;	}",0
Line 4: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 42: while (1) {,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 11: nid_type nId2 = vRandom[nRndPos2];,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 67: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 10: if (vvNew[bucket][pos] == nId) {,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 2: {,"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {	LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);	}	return added > 0;	}",0
Line 1: bool AddrInfo::IsTerrible(NodeSeconds now) const,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 48: if (setTried.size() != (size_t)nTried),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 1: void JustThrow(),void JustThrow()	{	throw 0;	},0
Line 8: if (pchMsgTmp != Params().MessageStart()) {,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Line 2: int len = s.size();,bool isPalindrome(const string &s) {	int len = s.size();	for (int i = 0; i < len / 2; ++i) {	if (s[i] != s[len - i - 1]) {	return false;	}	}	return true;	},0
Line 7: return *in_new ? nNew : nTried;,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 5: return false;,bool isPalindrome(const string &s) {	int len = s.size();	for (int i = 0; i < len / 2; ++i) {	if (s[i] != s[len - i - 1]) {	return false;	}	}	return true;	},0
Line 25: *   * number of elements,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
"Line 36: * This format is more complex, but significantly smaller (at most 1.5 MiB), and supports","void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 7: ,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 28: return -3;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 4: },int modifyPoint(int* points) {	*points += 1;	return *points;	},0
Line 1: CScript operator()(const CNoDestination& dest) const,CScript operator()(const CNoDestination& dest) const	{	return dest.GetScript();	},0
Line 7: return ret;,"bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	LOCK(cs);	Check();	auto ret = Add_(vAddr, source, time_penalty);	Check();	return ret;	}",0
Line 18: } catch (const InvalidAddrManVersionError&) {,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 104: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 50: {,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 10: ,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Line 2: {,"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;	}",0
Line 60: return -17;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 8: bool erase_collision = false;,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 21: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
"Line 1: void AddrMan::Connected(const CService& addr, NodeSeconds time)","void AddrMan::Connected(const CService& addr, NodeSeconds time)	{	m_impl->Connected(addr, time);	}",0
Line 10: if (!networks.empty()) {,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
"Line 17: DumpPeerAddresses(args, *addrman);","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 44: int bucket = insecure_rand.randrange(bucket_count);,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 1: int count_chars(const std::string& str) {,int count_chars(const std::string& str) {	return str.length();	},0
"Line 103: // If the bucket count and asmap checksum haven't changed, then attempt","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 40: int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);","void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
"Line 22: SwapRandom(n, nRndPos);","std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
"Line 1: void DeserializeFileDB(const fs::path& path, Data&& data)","void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};	if (filein.IsNull()) {	throw DbNotFoundError{};	}	DeserializeDB(filein, data);	}",0
Line 53: },"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 2: {,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 30: if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 6: },"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {	LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);	}	return added > 0;	}",0
Line 74: for (const std::string& error : result->errors()),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 26: return {info_old, info_old.m_last_try};","std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 2: {,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 2: int* temp = new int{42};,void netNothing() {	int* temp = new int{42};	delete temp;	},0
Line 9: if (max_addresses != 0) {,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 3: return m_impl->FindAddressEntry(addr);,std::optional<AddressPosition> AddrMan::FindAddressEntry(const CAddress& addr)	{	return m_impl->FindAddressEntry(addr);	},0
"Line 4: , m_consistency_check_ratio{consistency_check_ratio}","AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",0
Line 58: },"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 54: },"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 11: },"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;	}",0
Line 4: uint64_t hash2 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();,"int AddrInfo::GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const	{	uint64_t hash1 = (HashWriter{} << nKey << GetKey()).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;	}",0
Line 70: nIds = 0;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 30: if (new_only || tried_count == 0) {,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 115: bool setup_wasm_streaming =,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 7: private:,class Counter {	public:	int get_count() const {	return count;	}		private:	int count = 0;	};,0
Line 2: {,"void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};	if (filein.IsNull()) {	throw DbNotFoundError{};	}	DeserializeDB(filein, data);	}",0
Line 5: },int returnChanges() {	int rc = 10;	rc = 5;	return rc;	},0
Line 11: new_count = 0;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 6: has = true;,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);	has = true;	}	}	return has;	},0
Line 49: return -9;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
"Line 13: /*bucket_in=*/bucket,","std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
"Line 1: AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)","AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",0
Line 43: // we are still single threaded.,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 3: return *std::max_element(numbers.begin(), numbers.end());","int find_max(const std::vector<int>& numbers) {	if (numbers.empty()) return 0;  // Return 0 for an empty list	return *std::max_element(numbers.begin(), numbers.end());	}",0
"Line 21: * * number of ""new"" buckets XOR 2**30","void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 3: },Delegate* AutoUpdater::GetDelegate() {	return delegate_;	},0
Line 35: *,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 8: },"int gcd(int a, int b) {	while (b != 0) {	int temp = b;	b = a % b;	a = temp;	}	return a;	}",0
Line 2: return x % 2 == 0;,bool is_even(int x) {	return x % 2 == 0;	},0
Line 37: * changes to the ADDRMAN_ parameters without breaking the on-disk structure.,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 3: },"bool starts_with(const std::string& str, const std::string& prefix) {	return str.rfind(prefix, 0) == 0;	}",0
Line 7: for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 25: fileout.fclose();,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
"Line 1: void AddrManImpl::Connected(const CService& addr, NodeSeconds time)","void AddrManImpl::Connected(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	Connected_(addr, time);	Check();	}",0
Line 1: CKeyID ToKeyID(const PKHash& key_hash),CKeyID ToKeyID(const PKHash& key_hash)	{	return CKeyID{uint160{key_hash}};	},0
Line 3: AssertLockHeld(cs);,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 13: const auto it_1{mapInfo.find(nId1)};,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 16: // However it is possible to bypass the restriction by abusing the node mode,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 50: } else { // Collision is not actually a collision anymore,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 24: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 120: const int entry_index{bucket_entry.second};,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 32: if (ai.IsTerrible(now) && filtered) continue;,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 27: ,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 3: int publicint;,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 5: auto addrInfos = GetEntries_(from_tried);,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const	{	LOCK(cs);	Check();	auto addrInfos = GetEntries_(from_tried);	Check();	return addrInfos;	}",0
Line 14: },"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;	}",0
Line 4: ,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",0
Line 24: * * for each new bucket:,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 122: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 69: if (pinfo->nRefCount == 0) {,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 5: },// 1. Modifies a global variable	int global_count = 0;	void increment_global_count() {	global_count++;	},0
Line 83: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 5: assert(vRandom.empty());,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 4: },"void ReadFromStream(AddrMan& addr, DataStream& ssPeers)	{	DeserializeDB(ssPeers, addr, false);	}",0
Line 14: },"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 7: size_t new_count = nNew;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 1: class myClass {,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 70: Delete(nId);,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 95: int entry_index{0};,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 5: sum += num;,double average(const std::vector<int>& numbers) {	if (numbers.empty()) return 0.0;	int sum = 0;	for (int num : numbers) {	sum += num;	}	return static_cast<double>(sum) / numbers.size();	},0
Line 3: if (scheme_end == base::CommandLine::StringViewType::npos),"bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;		const auto& c_locale = std::locale::classic();	const auto isspace = [&](auto ch) { return std::isspace(ch, c_locale); };	const auto scheme = arg.substr(0U, scheme_end);	return std::size(scheme) > 1U && std::isalpha(scheme.front(), c_locale) &&	std::ranges::none_of(scheme, isspace);	}",0
Line 42: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 13: },"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 7: nNodes = max_pct * nNodes / 100;,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 16: },"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
"Line 6: return gin::ConvertToV8(isolate, keys);","v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {	std::map<std::string, std::string> keys;	#if !IS_MAS_BUILD()	electron::crash_keys::GetCrashKeys(&keys);	#endif	return gin::ConvertToV8(isolate, keys);	}",0
Line 9: *   whether to parse the file. For example:,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
"Line 12: /*multiplicity_in=*/1,","std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 81: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 124: if (!info.IsValid()) continue;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 3: return m_impl->Size(net, in_new);","size_t AddrMan::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	return m_impl->Size(net, in_new);	}",0
Line 76: nIds++;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 4: for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {,"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {	LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);	}	return added > 0;	}",0
Line 37: },"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 12: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 18: },"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",0
Line 2: {,void AddrMan::Unserialize(Stream& s_)	{	m_impl->Unserialize<Stream>(s_);	},0
Line 12: ,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
"Line 12: *     version N will be able to parse it, then version N+1 will write","void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 3: LOCK(cs);,void AddrManImpl::ResolveCollisions()	{	LOCK(cs);	Check();	ResolveCollisions_();	Check();	},0
Line 4: return count;,class Counter {	public:	int get_count() const {	return count;	}		private:	int count = 0;	};,0
Line 2: {,"void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	LOCK(cs);	Check();	Attempt_(addr, fCountFailure, time);	Check();	}",0
Line 4: },AddrManImpl::~AddrManImpl()	{	nKey.SetNull();	},0
"Line 70: args,","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 54: base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 23: // Get the to-be-evicted address that is being tested,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 11: if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 17: // periodically update nTime,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 147: auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 30: return addrman;,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 8: CPubKey pubKey(vSolutions[0]);,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
"Line 6: std::vector<std::pair<AddrInfo, AddressPosition>> infos;","std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 168: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 5: ,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
"Line 1: int max(int a, int b) {","int max(int a, int b) {	return (a > b) ? a : b;	}",0
Line 9: private:,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 2: {,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
"Line 5: auto ret = Good_(addr, /*test_before_evict=*/true, time);","bool AddrManImpl::Good(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	auto ret = Good_(addr, /*test_before_evict=*/true, time);	Check();	return ret;	}",0
Line 47: #endif,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 155: reporter.SetMethod(""removeExtraParameter"",","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 4: while (left < right) {,bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;	}	return true;	},0
Line 8: return numbers[n / 2];,"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {	return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;	} else {	return numbers[n / 2];	}	}",0
Line 52: assert(vvTried[nKBucket][nKBucketPos] == -1);,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 9: ,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
"Line 10: nNodes = std::min(nNodes, max_addresses);","std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 9: ,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 10: },bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;	}	return true;	},0
Line 2: bool block_args = false;,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;	}	return true;	},0
Line 1: // 8. Opens a file and reads its content,"// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content	file.close();	}	return content;	}",0
Line 6: Check();,"size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	LOCK(cs);	Check();	auto ret = Size_(net, in_new);	Check();	return ret;	}",0
Line 4: ,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",0
Line 49: },"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 23: },"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Line 8: assert(info.nRefCount == 0);,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",0
"Line 1: bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)","bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {	LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);	}	return added > 0;	}",0
Line 59: },"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 3: void initialize() {,bool is_initialized = false;		void initialize() {	is_initialized = true;	},0
"Line 11: // if not found, bail out","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 3: AssertLockHeld(cs);,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;	}",0
Line 71: for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 7: // ... verify the network matches ours,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Line 2: return (celsius * 9.0 / 5.0) + 32.0;,double celsius_to_fahrenheit(double celsius) {	return (celsius * 9.0 / 5.0) + 32.0;	},0
Line 34: } else {,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 63: // Deserialize entries from the tried table.,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 28: return true;,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
"Line 1: bool AddrManImpl::Good(const CService& addr, NodeSeconds time)","bool AddrManImpl::Good(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	auto ret = Good_(addr, /*test_before_evict=*/true, time);	Check();	return ret;	}",0
"Line 23: int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);","void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 5: if (n % 2 == 0) {,"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {	return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;	} else {	return numbers[n / 2];	}	}",0
Line 24: assert(it != mapInfo.end());,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
"Line 64: // If the bucket is entirely empty, start over with a (likely) different one.","std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
"Line 13: // gather a list of random nodes, skipping those of low quality","std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 3: AssertLockHeld(cs);,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 80: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 4: return hash1 % ADDRMAN_BUCKET_SIZE;,"int AddrInfo::GetBucketPosition(const uint256& nKey, bool fNew, int bucket) const	{	uint64_t hash1 = (HashWriter{} << nKey << (fNew ? uint8_t{'N'} : uint8_t{'K'}) << bucket << GetKey()).GetCheapHash();	return hash1 % ADDRMAN_BUCKET_SIZE;	}",0
Line 14: const auto update_interval{20min};,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",0
Line 1: CKeyID ToKeyID(const WitnessV0KeyHash& key_hash),CKeyID ToKeyID(const WitnessV0KeyHash& key_hash)	{	return CKeyID{uint160{key_hash}};	},0
Line 102: #endif,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 11: mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 4: },"int find_max(const std::vector<int>& numbers) {	if (numbers.empty()) return 0;  // Return 0 for an empty list	return *std::max_element(numbers.begin(), numbers.end());	}",0
Line 22: * * all new addresses (total count: nNew),"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 92: },"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 3: AssertLockHeld(cs);,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 13: void FixStdioStreams() {,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 33: ,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 4: if (num % 2 == 0) {,vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {	evens.push_back(num);	}	}	return evens;	},0
Line 7: ,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 12: },"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);	}	return false;	}",0
Line 4: },CScript operator()(const CNoDestination& dest) const	{	return dest.GetScript();	},0
Line 56: if (!setTried.count(vvTried[n][i])),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 1: void printVar(auto var_to_print) { // printing,void printVar(auto var_to_print) { // printing	cout << var_to_print << endl;	},0
"Line 1: void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)","void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 15: ,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 37: WitnessV1Taproot tap;,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 87: if (vvNew[bucket][i] != -1) {,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
"Line 65: assert(nIds != nNew); // this means nNew was wrong, oh ow","void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 49: ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 129: if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 12: if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 17: // of Electron apps:,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 5: // remove the entry from all new buckets,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 3: std::ifstream file(filename);,"// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content	file.close();	}	return content;	}",0
"Line 39: // Output the entry we'd be colliding with, for debugging purposes","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 34: * they are instead reconstructed from the other information.,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 4: },CScript operator()(const WitnessV1Taproot& tap) const	{	return CScript() << OP_1 << ToByteVector(tap);	},0
"Line 18: /*multiplicity_in=*/addr_info->nRefCount,","std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 11: },"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {	LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);	}	return added > 0;	}",0
Line 7: },"// 6. Modifies a global array	int global_array[10] = {0};	void update_global_array(int index, int value) {	if (index >= 0 && index < 10) {	global_array[index] = value;	}	}",0
"Line 1: AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)","AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",0
Line 6: if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;	}",0
"Line 27: return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 30: case TxoutType::WITNESS_V0_SCRIPTHASH: {,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 65: for (int n = 0; n < nTried; n++) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 1: CScriptID ToScriptID(const ScriptHash& script_hash),CScriptID ToScriptID(const ScriptHash& script_hash)	{	return CScriptID{uint160{script_hash}};	},0
Line 45: int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 2: {,void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{	int temporary = 0;	}	},0
Line 2: {,CKeyID ToKeyID(const PKHash& key_hash)	{	return CKeyID{uint160{key_hash}};	},0
Line 3: m_impl->Unserialize<Stream>(s_);,void AddrMan::Unserialize(Stream& s_)	{	m_impl->Unserialize<Stream>(s_);	},0
Line 18: return false;,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Line 37: ,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 125: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 5: break;,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;	}	return true;	},0
"Line 14: /*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));","std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 56: if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 48: },"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 6: },"// 6. Modifies a global array	int global_array[10] = {0};	void update_global_array(int index, int value) {	if (index >= 0 && index < 10) {	global_array[index] = value;	}	}",0
Line 3: },void indirectPointChange(const int* cpoint) {	*const_cast<int*>(cpoint) = 5;	},0
Line 3: AssertLockHeld(cs);,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",0
Line 4: },CKeyID ToKeyID(const PKHash& key_hash)	{	return CKeyID{uint160{key_hash}};	},0
Line 11: AddrInfo info = mapInfo.at(id);,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 47: ,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 5: HashedSourceWriter hashwriter{stream};,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;	}",0
Line 2: {,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrMan::GetEntries(bool use_tried) const	{	return m_impl->GetEntries(use_tried);	}",0
Line 13: return -7;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 7: ,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;	}",0
Line 11: if (mapInfo.count(id_new) != 1) {,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 7: ,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 17: },"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Line 16: return {};,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 58: } else {,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 26: const AddrInfo& ai{it->second};,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 36: if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 48: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 1: size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const","size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 14: },"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;	}",0
Line 5: },//SEF		int stringLength(const string &s) {	return s.length();	},0
Line 52: position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 91: for (int bucket = 0; bucket < nUBuckets; ++bucket) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 6: const auto& c_locale = std::locale::classic();,"bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;		const auto& c_locale = std::locale::classic();	const auto isspace = [&](auto ch) { return std::isspace(ch, c_locale); };	const auto scheme = arg.substr(0U, scheme_end);	return std::size(scheme) > 1U && std::isalpha(scheme.front(), c_locale) &&	std::ranges::none_of(scheme, isspace);	}",0
Line 13: // update info,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;	}",0
Line 21: },"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Line 62: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 4: },"std::pair<CAddress, NodeSeconds> AddrMan::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	return m_impl->Select(new_only, networks);	}",0
Line 14: ,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
"Line 47: pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);","bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 99: return -21;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 17: uint256 hashTmp;,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Line 2: {,"bool AddrMan::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	return m_impl->Add(vAddr, source, time_penalty);	}",0
Line 45: if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 5: return array_copy;,"vector<int> addToArray(vector<int> array_copy, int value_to_add) { // returning modified array passed in by value	for (int i = 0; i < array_copy.size(); ++i) {	array_copy[i] += value_to_add;	}	return array_copy;	}",0
Line 5: auto entry = FindAddressEntry_(addr);,std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{	LOCK(cs);	Check();	auto entry = FindAddressEntry_(addr);	Check();	return entry;	},0
Line 77: if (result->early_return() != 0) {,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 57: },"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 8: },std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{	LOCK(cs);	Check();	auto entry = FindAddressEntry_(addr);	Check();	return entry;	},0
Line 14: },"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;	}",0
Line 8: return sum_total;,int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {	sum_total += array_to_sum[i];	}		return sum_total;	},0
Line 2: {,"std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	return m_impl->GetAddr(max_addresses, max_pct, network, filtered);	}",0
Line 3: int added{0};,"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {	LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);	}	return added > 0;	}",0
Line 68: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 1: bool is_palindrome(const std::string& str) {,bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;	}	return true;	},0
"Line 4: TxoutType whichType = Solver(scriptPubKey, vSolutions);","bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 17: // when setting up cli flags and env vars. Since we're outlawing these,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Line 3: AssertLockHeld(cs);,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}	}",0
"Line 131: int bucket_position = info.GetBucketPosition(nKey, true, bucket);","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 12: std::vector<std::string> errors;,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
"Line 25: // first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).","void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 6: },int factorial(int n) {	if (n == 0) {	return 1;	}	return n * factorial(n - 1);	},0
"Line 1: int AddrInfo::GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const","int AddrInfo::GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const	{	uint64_t hash1 = (HashWriter{} << nKey << GetKey()).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;	}",0
Line 7: },"void AddrManImpl::Connected(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	Connected_(addr, time);	Check();	}",0
Line 73: },"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 1: int squareGlobal() {,int squareGlobal() {	x *= x;	return x;	},0
"Line 23: addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 12: },"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;	}",0
Line 20: // To prevent Electron apps from being used to work around macOS security,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 16: // Which tried bucket to move the entry to.,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 22: if (info.nRefCount),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 73: if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 1: // 1. Modifies a global variable,// 1. Modifies a global variable	int global_count = 0;	void increment_global_count() {	global_count++;	},0
"Line 5: std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);","bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 3: return dest.GetScript();,CScript operator()(const CNoDestination& dest) const	{	return dest.GetScript();	},0
Line 13: if (disallowed.contains(key)) {,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Line 2: return delegate_;,Delegate* AutoUpdater::GetDelegate() {	return delegate_;	},0
Line 4: ,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}	}",0
Line 8: },"std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	LOCK(cs);	Check();	auto addrRet = Select_(new_only, networks);	Check();	return addrRet;	}",0
Line 106: uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 96: },"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 4: },CKeyID ToKeyID(const WitnessV0KeyHash& key_hash)	{	return CKeyID{uint160{key_hash}};	},0
Line 15: },"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 7: },vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {	evens.push_back(num);	}	}	return evens;	},0
"Line 2: return std::visit(ValidDestinationVisitor(), dest);","bool IsValidDestination(const CTxDestination& dest) {	return std::visit(ValidDestinationVisitor(), dest);	}",0
Line 2: for (int i = 0; i < array_copy.size(); ++i) {,"vector<int> addToArray(vector<int> array_copy, int value_to_add) { // returning modified array passed in by value	for (int i = 0; i < array_copy.size(); ++i) {	array_copy[i] += value_to_add;	}	return array_copy;	}",0
Line 12: if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 7: },bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);	has = true;	}	}	return has;	},0
Line 91: ,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 16: if (fCheckSum) {,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Line 12: ,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 3: return CScript() << OP_HASH160 << ToByteVector(scriptID) << OP_EQUAL;,CScript operator()(const ScriptHash& scriptID) const	{	return CScript() << OP_HASH160 << ToByteVector(scriptID) << OP_EQUAL;	},0
Line 3: // found in the LICENSE file.,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 27: if (!Assume(info.nRefCount > 0)) return false;,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 4: },"std::vector<std::pair<AddrInfo, AddressPosition>> AddrMan::GetEntries(bool use_tried) const	{	return m_impl->GetEntries(use_tried);	}",0
Line 19: * * nNew,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 158: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 1: std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()","std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 7: return false;,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;	}	return true;	},0
Line 4: ,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 92: int num_entries{0};,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 9: },bool isPalindrome(const string &s) {	int len = s.size();	for (int i = 0; i < len / 2; ++i) {	if (s[i] != s[len - i - 1]) {	return false;	}	}	return true;	},0
Line 40: if (info.m_last_try < NodeSeconds{0s}) {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 1: CScript operator()(const WitnessUnknown& id) const,CScript operator()(const WitnessUnknown& id) const	{	return CScript() << CScript::EncodeOP_N(id.GetWitnessVersion()) << id.GetWitnessProgram();	},0
"Line 39: int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);","void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 21: } else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 6: ,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 4: if (n <= 1) return n;,"int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;	if (cache.find(n) != cache.end()) return cache[n];		cache[n] = fibonacci(n - 1) + fibonacci(n - 2);	return cache[n];	}",0
Line 120: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 11: ,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 1: bool operator()(const ScriptHash& dest) const { return true; },bool operator()(const ScriptHash& dest) const { return true; },0
Line 6: },bool isPalindrome(const string &s) {	int len = s.size();	for (int i = 0; i < len / 2; ++i) {	if (s[i] != s[len - i - 1]) {	return false;	}	}	return true;	},0
Line 2: std::ofstream file(filename);,"void write_to_file(const std::string& filename, const std::string& content) {	std::ofstream file(filename);	if (file.is_open()) {	file << content;	file.close();	}	}",0
"Line 28: e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 13: } else {,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 1: vector<int> filterEvenNumbers(const vector<int>& numbers) {,vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {	evens.push_back(num);	}	}	return evens;	},0
Line 45: },"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 41: if (pinfo->nRefCount > 0) {,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 6: AddrInfo& info = mapInfo[nId];,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",0
"Line 5: // if there is an entry in the specified bucket, delete it.","void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",0
Line 9: return;,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;	}",0
Line 111: const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 72: if (vvNew[n][i] != -1) {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 88: int nIndex = mapUnkIds[vvNew[bucket][i]];,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 4: },void AddrMan::ResolveCollisions()	{	m_impl->ResolveCollisions();	},0
Line 162: v8::HandleScope scope(isolate);,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 1: std::pair<CAddress, NodeSeconds> AddrMan::SelectTriedCollision()","std::pair<CAddress, NodeSeconds> AddrMan::SelectTriedCollision()	{	return m_impl->SelectTriedCollision();	}",0
Line 1: void AddrManImpl::Check() const,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}	}",0
Line 6: return false;,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 155: } else {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 10: ,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Line 119: int bucket{bucket_entry.first};,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 16: *     (format=5, lowest_compatible=5) and so any versions that do not know how to parse","void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 15: return false;,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 39: ,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 34: #if BUILDFLAG(IS_LINUX),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 1: int max_of_three(int a, int b, int c) {","int max_of_three(int a, int b, int c) {	return std::max({a, b, c});	}",0
Line 9: },bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 30: },"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 69: assert(it_found != mapInfo.end());,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 3: AssertLockHeld(cs);,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",0
"Line 22: int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);","std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 6: #include <fstream>,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;	}",0
Line 15: },"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;	}",0
Line 2: int reversed = 0;,int reverse_number(int num) {	int reversed = 0;	while (num != 0) {	reversed = reversed * 10 + num % 10;	num /= 10;	}	return reversed;	},0
Line 1: class Counter {,class Counter {	public:	int get_count() const {	return count;	}		private:	int count = 0;	};,0
Line 2: return sRval * sRval;,int squareReference(int& sRval) { // returning square of input passed in by reference	return sRval * sRval;	},0
Line 1: bool CBanDB::Write(const banmap_t& banSet),"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);	}	return false;	}",0
Line 7: },"void DeserializeFileDB(const fs::path& path, Data&& data)	{	FILE* file = fsbridge::fopen(path, ""rb"");	AutoFile filein{file};	if (filein.IsNull()) {	throw DbNotFoundError{};	}	DeserializeDB(filein, data);	}",0
Line 57: int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 12: ,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
"Line 166: ""Corrupt data. Consistency check failed with code %s"",","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 10: },"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 2: public:,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
"Line 74: assert(nIds != nTried); // this means nTried was wrong, oh ow","void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 6: switch (whichType) {,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 95: },"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 5: },bool is_initialized = false;		void initialize() {	is_initialized = true;	},0
Line 164: if (check_code != 0) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 107: // V8 requires a task scheduler.,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 7: return ret;,"bool AddrManImpl::Good(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	auto ret = Good_(addr, /*test_before_evict=*/true, time);	Check();	return ret;	}",0
"Line 16: int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};","std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 86: // Store positions in the new table buckets to apply later (if possible).,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 3: int stringLength(const string &s) {,//SEF		int stringLength(const string &s) {	return s.length();	},0
"Line 1: bool starts_with(const std::string& str, const std::string& prefix) {","bool starts_with(const std::string& str, const std::string& prefix) {	return str.rfind(prefix, 0) == 0;	}",0
Line 51: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 34: const auto it{mapAddr.find(info)};,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 58: } else {,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 1: void AutoUpdater::SetFeedURL(gin::Arguments* args) {},void AutoUpdater::SetFeedURL(gin::Arguments* args) {},0
Line 19: },"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Line 16: nNew--;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 66: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 2: return command_line->HasSwitch(switches::kEnableSandbox) ||,bool IsSandboxEnabled(base::CommandLine* command_line) {	return command_line->HasSwitch(switches::kEnableSandbox) ||	!command_line->HasSwitch(sandbox::policy::switches::kNoSandbox);	},0
Line 123: v8::Isolate::Scope isolate_scope(isolate);,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 4: },int factorial(int n) {	if (n == 0) {	return 1;	}	return n * factorial(n - 1);	},0
Line 8: ,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 3: LOCK(cs);,"size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	LOCK(cs);	Check();	auto ret = Size_(net, in_new);	Check();	return ret;	}",0
Line 5: },"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Line 69: ,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 4: },bool IsSandboxEnabled(base::CommandLine* command_line) {	return command_line->HasSwitch(switches::kEnableSandbox) ||	!command_line->HasSwitch(sandbox::policy::switches::kNoSandbox);	},0
Line 86: return -13;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 4: for (int num : numbers) {,double average(const std::vector<int>& numbers) {	if (numbers.empty()) return 0.0;	int sum = 0;	for (int num : numbers) {	sum += num;	}	return static_cast<double>(sum) / numbers.size();	},0
Line 59: it++;,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 4: {,void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{	int temporary = 0;	}	},0
Line 7: ,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 45: } else {,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 15: },"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",0
Line 39: return true;,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 144: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 1: void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)","void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",0
Line 1: int incrementedNotLocal() {,int incrementedNotLocal() {	x++;	return x;	},0
Line 1: bool operator()(const WitnessUnknown& dest) const { return true; },bool operator()(const WitnessUnknown& dest) const { return true; },0
Line 32: int nUBuckets = 0;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 69: int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 9: if (!pubKey.IsValid()) {,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 146: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 18: * * nKey,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 9: },"int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;	if (cache.find(n) != cache.end()) return cache[n];		cache[n] = fibonacci(n - 1) + fibonacci(n - 2);	return cache[n];	}",0
Line 33: infoOld.fInTried = false;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 93: // doesn't have if addrs from a network were being added and then removed again in the past.,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 1: void AddrManImpl::Serialize(Stream& s_) const,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 2: {,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 23: },"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 16: assert(it_2 != mapInfo.end());,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 39: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 17: },"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",0
"Line 137: result->exec_args(),","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 121: v8::Isolate* isolate = gin_env.isolate();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 136: } else {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 81: nLost++;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 78: // Otherwise start over with a (likely) different bucket, and increased chance factor.","std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 85: auto* command_line = base::CommandLine::ForCurrentProcess();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 3: return x;,int incrementedNotLocal() {	x++;	return x;	},0
Line 7: if (!addr_info) return std::nullopt;,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 50: if (mapNew.size() != (size_t)nNew),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
"Line 10: int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};","std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 6: Check();,"void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	LOCK(cs);	Check();	Attempt_(addr, fCountFailure, time);	Check();	}",0
Line 5: num /= 10;,int reverse_number(int num) {	int reversed = 0;	while (num != 0) {	reversed = reversed * 10 + num % 10;	num /= 10;	}	return reversed;	},0
Line 18: // flags (making them errors) exit with the same error code for,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
"Line 2: return str.rfind(prefix, 0) == 0;","bool starts_with(const std::string& str, const std::string& prefix) {	return str.rfind(prefix, 0) == 0;	}",0
"Line 82: // On Linux, initialize crashpad after Nodejs init phase so that","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 154: &electron::crash_keys::SetCrashKey);,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 108: if (format >= Format::V2_ASMAP) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 9: std::unordered_map<nid_type, int> mapNew;","int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 14: auto it = m_network_counts.find(network);,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 10: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 2: {,"void AddrManImpl::Connected(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	Connected_(addr, time);	Check();	}",0
Line 49: int exit_code = 1;,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 20: tried_count += counts.n_tried;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 11: for (const auto& arg : argv) {,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
"Line 1: bool is_divisible(int a, int b) {","bool is_divisible(int a, int b) {	return b != 0 && a % b == 0;	}",0
Line 61: },"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
"Line 19: if (!SerializeDB(fileout, data)) {","bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 29: return false;,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 3: AssertLockHeld(cs);,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 11: AddrInfo& info = *pinfo;,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Line 6: Check();,"void AddrManImpl::Connected(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	Connected_(addr, time);	Check();	}",0
Line 4: uint64_t hash1 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << vchSourceGroupKey).GetCheapHash();,"int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const	{	std::vector<unsigned char> vchSourceGroupKey = netgroupman.GetGroup(src);	uint64_t hash1 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << vchSourceGroupKey).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_NEW_BUCKET_COUNT;	}",0
Line 3: return CKeyID{uint160{key_hash}};,CKeyID ToKeyID(const PKHash& key_hash)	{	return CKeyID{uint160{key_hash}};	},0
Line 101: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 12: };,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 5: return n * factorial(n - 1);,int factorial(int n) {	if (n == 0) {	return 1;	}	return n * factorial(n - 1);	},0
Line 14: ,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 56: ,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 3: },int squareValue(int sVval) { // returning square of input passed in by value	return sVval * sVval;	},0
Line 3: },void setFive(int& var_to_set) { // setting variable passed in by reference	var_to_set = 5;	},0
Line 4: try {,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);	return anchors;	}",0
Line 8: },"bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	LOCK(cs);	Check();	auto ret = Add_(vAddr, source, time_penalty);	Check();	return ret;	}",0
Line 6: },int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {	sum_total += array_to_sum[i];	}		return sum_total;	},0
"Line 32: int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 20: * * nTried,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 1: void setFive(int& var_to_set) { // setting variable passed in by reference,void setFive(int& var_to_set) { // setting variable passed in by reference	var_to_set = 5;	},0
Line 2: {,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",0
Line 3: },void freeMem(int* memory) {	delete memory;	},0
Line 2: DCHECK(base::CommandLine::InitializedForCurrentProcess());,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 85: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 78: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 19: if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
"Line 18: int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);","void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
"Line 1: bool AddrMan::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)","bool AddrMan::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	return m_impl->Add(vAddr, source, time_penalty);	}",0
"Line 17: int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);","void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
"Line 2: return """";","std::string AutoUpdater::GetFeedURL() {	return """";	}",0
Line 164: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 178: //,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 16: continue;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 20: return -1;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 2: {,"std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	LOCK(cs);	Check();	auto addresses = GetAddr_(max_addresses, max_pct, network, filtered);	Check();	return addresses;	}",0
Line 3: LOCK(cs);,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const	{	LOCK(cs);	Check();	auto addrInfos = GetEntries_(from_tried);	Check();	return addrInfos;	}",0
Line 3: },"double distance(double x1, double y1, double x2, double y2) {	return std::sqrt(std::pow(x2 - x1, 2) + std::pow(y2 - y1, 2));	}",0
Line 126: node::IsolateData* isolate_data = nullptr;,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 3: for (int num : numbers) {,vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {	evens.push_back(num);	}	}	return evens;	},0
Line 11: return true;,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;	}	return true;	},0
Line 32: } else if (new_count == 0) {,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 11: return false;,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);	}	return false;	}",0
"Line 1: int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const","int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const	{	std::vector<unsigned char> vchSourceGroupKey = netgroupman.GetGroup(src);	uint64_t hash1 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << vchSourceGroupKey).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_NEW_BUCKET_COUNT;	}",0
Line 2: {,"void AddrMan::SetServices(const CService& addr, ServiceFlags nServices)	{	m_impl->SetServices(addr, nServices);	}",0
Line 3: ,"int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;	if (cache.find(n) != cache.end()) return cache[n];		cache[n] = fibonacci(n - 1) + fibonacci(n - 2);	return cache[n];	}",0
Line 22: },"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Line 1: void freeMem(int* memory) {,void freeMem(int* memory) {	delete memory;	},0
Line 7: case TxoutType::PUBKEY: {,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 15: // verify checksum,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Line 6: },"int gcd(int a, int b) {	while (b != 0) {	int temp = b;	b = a % b;	a = temp;	}	return a;	}",0
Line 8: },"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const	{	LOCK(cs);	Check();	auto addrInfos = GetEntries_(from_tried);	Check();	return addrInfos;	}",0
Line 3: std::vector<unsigned char> vchSourceGroupKey = netgroupman.GetGroup(src);,"int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const	{	std::vector<unsigned char> vchSourceGroupKey = netgroupman.GetGroup(src);	uint64_t hash1 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << vchSourceGroupKey).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_NEW_BUCKET_COUNT;	}",0
Line 42: ,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
"Line 19: /*bucket_in=*/bucket,","std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 16: nid_type n = entry.first;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 27: },"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 96: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 29: },"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 2: return str.length();,int count_chars(const std::string& str) {	return str.length();	},0
Line 73: if (info.fInTried) {,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 2: int rc = 10;,int returnChanges() {	int rc = 10;	rc = 5;	return rc;	},0
Line 4: if (s[i] != s[len - i - 1]) {,bool isPalindrome(const string &s) {	int len = s.size();	for (int i = 0; i < len / 2; ++i) {	if (s[i] != s[len - i - 1]) {	return false;	}	}	return true;	},0
Line 2: {,"void AddrMan::Connected(const CService& addr, NodeSeconds time)	{	m_impl->Connected(addr, time);	}",0
"Line 43: // If the collision hasn't resolved in some reasonable amount of time,","void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 40: erase_collision = true;,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
"Line 2: std::map<std::string, std::string> keys;","v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {	std::map<std::string, std::string> keys;	#if !IS_MAS_BUILD()	electron::crash_keys::GetCrashKeys(&keys);	#endif	return gin::ConvertToV8(isolate, keys);	}",0
Line 9: };,class Counter {	public:	void increment() {	count++;	}		private:	int count = 0;	};,0
"Line 48: nTried,","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 22: ,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 2: {,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 5: if (!net.has_value()) {,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 2: {,CScript operator()(const WitnessUnknown& id) const	{	return CScript() << CScript::EncodeOP_N(id.GetWitnessVersion()) << id.GetWitnessProgram();	},0
Line 5: },"void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& anchors)	{	LOG_TIME_SECONDS(strprintf(""Flush %d outbound block-relay-only peer addresses to anchors.dat"", anchors.size()));	SerializeFileDB(""anchors"", anchors_db_path, CAddress::V2_DISK(anchors));	}",0
Line 6: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 2: return b != 0 && a % b == 0;,"bool is_divisible(int a, int b) {	return b != 0 && a % b == 0;	}",0
Line 4: ,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 2: {,void AddrMan::Serialize(Stream& s_) const	{	m_impl->Serialize<Stream>(s_);	},0
Line 44: },"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
"Line 1: void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)","void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Line 3: },"void changePoint(int* pointed, int& ref) {	pointed = &ref;	}",0
"Line 33: * vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;","void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 5: },bool is_prime(int n) {	if (n <= 1) return false;	for (int i = 2; i * i <= n; ++i) {	if (n % i == 0) return false;	}	return true;	},0
Line 35: if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 1: bool CBanDB::Read(banmap_t& banSet),"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Line 8: },"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;	}",0
Line 8: },"// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content	file.close();	}	return content;	}",0
Line 3: int publicint;,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 82: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 31: erase_collision = true;,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 83: // crash and termination signal handlers can be set by the crashpad client.,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 12: };,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 140: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 8: },"std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	LOCK(cs);	Check();	auto addresses = GetAddr_(max_addresses, max_pct, network, filtered);	Check();	return addresses;	}",0
Line 16: } else {,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
"Line 1: bool AutoUpdater::IsVersionAllowedForUpdate(const std::string& current_version,","bool AutoUpdater::IsVersionAllowedForUpdate(const std::string& current_version,	const std::string& target_version) {	return false;	}",0
"Line 2: return std::sqrt(std::pow(x2 - x1, 2) + std::pow(y2 - y1, 2));","double distance(double x1, double y1, double x2, double y2) {	return std::sqrt(std::pow(x2 - x1, 2) + std::pow(y2 - y1, 2));	}",0
Line 1: bool UnsetHijackableEnvs(base::Environment* env) {,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);	has = true;	}	}	return has;	},0
Line 3: return CScript() << ToByteVector(dest.GetPubKey()) << OP_CHECKSIG;,CScript operator()(const PubKeyDestination& dest) const	{	return CScript() << ToByteVector(dest.GetPubKey()) << OP_CHECKSIG;	},0
Line 10: },"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {	return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;	} else {	return numbers[n / 2];	}	}",0
"Line 1: int gcd(int a, int b) {","int gcd(int a, int b) {	while (b != 0) {	int temp = b;	b = a % b;	a = temp;	}	return a;	}",0
Line 5: },"int AddrInfo::GetBucketPosition(const uint256& nKey, bool fNew, int bucket) const	{	uint64_t hash1 = (HashWriter{} << nKey << (fNew ? uint8_t{'N'} : uint8_t{'K'}) << bucket << GetKey()).GetCheapHash();	return hash1 % ADDRMAN_BUCKET_SIZE;	}",0
Line 5: },"//SE		void add_element(std::vector<int>& numbers, int value) {	numbers.push_back(value);	}",0
Line 25: ,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 13: },"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);	return anchors;	}",0
Line 4: Check();,"void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)	{	LOCK(cs);	Check();	SetServices_(addr, nServices);	Check();	}",0
Line 90: },"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 2: {,std::optional<AddressPosition> AddrMan::FindAddressEntry(const CAddress& addr)	{	return m_impl->FindAddressEntry(addr);	},0
"Line 40: strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 147: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 6: return false;,bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;	}	return true;	},0
Line 23: return false;,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 17: ,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 1: std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr),std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{	LOCK(cs);	Check();	auto entry = FindAddressEntry_(addr);	Check();	return entry;	},0
Line 11: #include <tuple>,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 149: #if IS_MAS_BUILD(),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 77: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 1: double AddrInfo::GetChance(NodeSeconds now) const,"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;	}",0
"Line 53: node_id = GetEntry(search_tried, bucket, position);","std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 6: * Serialized format.,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 98: if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 45: return false;,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
"Line 119: JavascriptEnvironment gin_env(loop, setup_wasm_streaming);","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 116: node::per_process::cli_options->get_per_isolate_options(),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 13: for (auto& entry : bucket) {,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",0
Line 6: Check();,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const	{	LOCK(cs);	Check();	auto addrInfos = GetEntries_(from_tried);	Check();	return addrInfos;	}",0
Line 102: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 9: nid_type id = GetEntry(from_tried, bucket, position);","std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 35: },"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 43: ,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 2: if (numbers.empty()) return 0;  // Return 0 for an empty list,"int find_max(const std::vector<int>& numbers) {	if (numbers.empty()) return 0;  // Return 0 for an empty list	return *std::max_element(numbers.begin(), numbers.end());	}",0
Line 2: {,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;	}",0
Line 31: // Filter for quality,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 34: return true;,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 5: return true;,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);	}	return false;	}",0
"Line 1: size_t AddrMan::Size(std::optional<Network> net, std::optional<bool> in_new) const","size_t AddrMan::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	return m_impl->Size(net, in_new);	}",0
Line 6: if (it == mapAddr.end()),"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",0
Line 57: auto feature_list = std::make_unique<base::FeatureList>();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 7: // open temp output file,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
"Line 6: const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};","void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 44: return -8;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 1: int returnChanges() {,int returnChanges() {	int rc = 10;	rc = 5;	return rc;	},0
Line 12: },bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;	}	return true;	},0
Line 1: double median(std::vector<int> numbers) {,"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {	return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;	} else {	return numbers[n / 2];	}	}",0
Line 10: ,"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);	return anchors;	}",0
Line 32: *,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 96: #elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD()),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 37: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 63: const AddrInfo& info = entry.second;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 10: const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 122: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 13: from_tried,","std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 3: for (const char* name : kHijackableEnvs) {,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);	has = true;	}	}	return has;	},0
Line 6: ,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
"Line 1: void write_to_file(const std::string& filename, const std::string& content) {","void write_to_file(const std::string& filename, const std::string& content) {	std::ofstream file(filename);	if (file.is_open()) {	file << content;	file.close();	}	}",0
Line 3: },int absolute_value(int x) {	return (x < 0) ? -x : x;	},0
Line 8: {,void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{	int temporary = 0;	}	},0
Line 123: // Don't store the entry in the new bucket if it's not a valid address for our addrman,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 8: ,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
"Line 26: *   * for each element: index in the serialized ""all new addresses""","void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 2: int global_count = 0;,// 1. Modifies a global variable	int global_count = 0;	void increment_global_count() {	global_count++;	},0
Line 16: case TxoutType::PUBKEYHASH: {,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 4: Check();,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const	{	LOCK(cs);	Check();	auto addrInfos = GetEntries_(from_tried);	Check();	return addrInfos;	}",0
Line 7: },void AddrManImpl::ResolveCollisions()	{	LOCK(cs);	Check();	ResolveCollisions_();	Check();	},0
Line 102: ,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 6: },"void write_to_file(const std::string& filename, const std::string& content) {	std::ofstream file(filename);	if (file.is_open()) {	file << content;	file.close();	}	}",0
Line 25: AddrInfo& info_old = mapInfo[id_old];,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
"Line 59: std::unordered_map<nid_type, int> mapUnkIds;","void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 20: if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 4: if (arg == DashDash),bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;	}	return true;	},0
Line 2: {,CScript operator()(const PKHash& keyID) const	{	return CScript() << OP_DUP << OP_HASH160 << ToByteVector(keyID) << OP_EQUALVERIFY << OP_CHECKSIG;	},0
Line 5: },"std::unordered_map<int, std::string> database;		void update_record(int id, const std::string& new_value) {	database[id] = new_value;	}",0
Line 6: ,class Counter {	public:	void increment() {	count++;	}		private:	int count = 0;	};,0
Line 9: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 2: cout << sum(testArray) << endl;,int main() {	cout << sum(testArray) << endl;	},0
Line 34: return false;,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 6: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 26: ,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 2: public:,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 9: },int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {	sum_total += array_to_sum[i];	}		return sum_total;	},0
Line 3: },bool is_positive(int x) {	return x > 0;	},0
Line 10: },bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;	}	return true;	},0
Line 1: bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;	}	return true;	},0
"Line 133: // Bucketing has not changed, using existing bucket positions for the new table","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 2: {,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	LOCK(cs);	Check();	auto addrRet = Select_(new_only, networks);	Check();	return addrRet;	}",0
Line 8: if (pnId),"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",0
Line 1: bool operator()(const CNoDestination& dest) const { return false; },bool operator()(const CNoDestination& dest) const { return false; },0
Line 10: const auto it2 = mapInfo.find((*it).second);,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",0
Line 23: const auto it{mapInfo.find(vRandom[n])};,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 65: const auto mapped_as{m_netgroupman.GetMappedAS(addr)};,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 13: // update info,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Line 51: return -10;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 93: // Store asmap checksum after bucket entries so that it,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 8: return true;,bool isPalindrome(const string &s) {	int len = s.size();	for (int i = 0; i < len / 2; ++i) {	if (s[i] != s[len - i - 1]) {	return false;	}	}	return true;	},0
"Line 76: if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {","int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 14: AddrInfo& info = *pinfo;,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 4: #include <cmath>,"#include <vector>	#include <string>	#include <algorithm>	#include <cmath>	#include <iostream>	#include <fstream>		int power(int x, int y) {	int result = 1;	for (int i = 0; i < y; ++i) {	result *= x;	}	return result;	}",0
Line 168: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 1: void indirectRefChange(const int& cref) {,void indirectRefChange(const int& cref) {	const_cast<int&>(cref) = 5;	},0
Line 4: },"void read_user_input(int& input) {	std::cout << ""Enter a number: "";	std::cin >> input;	}",0
Line 1: // 6. Modifies a global array,"// 6. Modifies a global array	int global_array[10] = {0};	void update_global_array(int index, int value) {	if (index >= 0 && index < 10) {	global_array[index] = value;	}	}",0
"Line 43: // Pick a bucket, and an initial position in that bucket.","std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 3: return CScript() << OP_DUP << OP_HASH160 << ToByteVector(keyID) << OP_EQUALVERIFY << OP_CHECKSIG;,CScript operator()(const PKHash& keyID) const	{	return CScript() << OP_DUP << OP_HASH160 << ToByteVector(keyID) << OP_EQUALVERIFY << OP_CHECKSIG;	},0
Line 17: },bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 2: {,CScript operator()(const WitnessV0ScriptHash& id) const	{	return CScript() << OP_0 << ToByteVector(id);	},0
Line 67: // Find the entry to return.,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 14: if (in_new.has_value()) {,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 15: if (time - info.nTime > update_interval) {,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",0
Line 95: return -20;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 5: uint64_t hash2 = (HashWriter{} << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetCheapHash();,"int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const	{	std::vector<unsigned char> vchSourceGroupKey = netgroupman.GetGroup(src);	uint64_t hash1 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << vchSourceGroupKey).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_NEW_BUCKET_COUNT;	}",0
Line 8: },"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision()	{	LOCK(cs);	Check();	auto ret = SelectTriedCollision_();	Check();	return ret;	}",0
Line 8: return true;,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 169: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 4: ,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
"Line 1: vector<int> addToArray(vector<int> array_copy, int value_to_add) { // returning modified array passed in by value","vector<int> addToArray(vector<int> array_copy, int value_to_add) { // returning modified array passed in by value	for (int i = 0; i < array_copy.size(); ++i) {	array_copy[i] += value_to_add;	}	return array_copy;	}",0
Line 8: for (const auto& err : errors) {,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);	}	return false;	}",0
Line 24: if (info.fInTried) return false;,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 118: ->experimental_fetch;,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 8: nid_type nId;,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
"Line 15: bucket,","std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 4: Check();,std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{	LOCK(cs);	Check();	auto entry = FindAddressEntry_(addr);	Check();	return entry;	},0
Line 2: {,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 83: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 9: int temporary = 0;,void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{	int temporary = 0;	}	},0
Line 134: node::EnvironmentFlags::kHideConsoleWindows;,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 7: return entry;,std::optional<AddressPosition> AddrManImpl::FindAddressEntry(const CAddress& addr)	{	LOCK(cs);	Check();	auto entry = FindAddressEntry_(addr);	Check();	return entry;	},0
"Line 6: // If the JSON banlist does not exist, then recreate it","bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Line 53: ,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 15: return -1;,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;	}",0
Line 47: ,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 4: ,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
"Line 3: return m_impl->Good(addr, time);","bool AddrMan::Good(const CService& addr, NodeSeconds time)	{	return m_impl->Good(addr, time);	}",0
Line 84: },"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 2: {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 186: return exit_code;,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 51: addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 2: {,"void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)	{	LOCK(cs);	Check();	SetServices_(addr, nServices);	Check();	}",0
"Line 1: bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)","bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	LOCK(cs);	Check();	auto ret = Add_(vAddr, source, time_penalty);	Check();	return ret;	}",0
Line 21: // currently-connected peers.,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
"Line 32: // replace existing file, if any, with new file","bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 1: CScript GetScriptForDestination(const CTxDestination& dest),"CScript GetScriptForDestination(const CTxDestination& dest)	{	return std::visit(CScriptVisitor(), dest);	}",0
Line 12: if (vRandom.size() != (size_t)(nTried + nNew)),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 8: assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 46: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 21: },"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 42: } else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 156: ++it;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 3: if (now - m_last_try <= 1min) { // never remove things tried in the last minute,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 6: if (m_consistency_check_ratio == 0) return;,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}	}",0
Line 3: try,void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{	int temporary = 0;	}	},0
Line 3: void increment_global_count() {,// 1. Modifies a global variable	int global_count = 0;	void increment_global_count() {	global_count++;	},0
"Line 8: ""--use-openssl-ca"",","void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
"Line 159: process.Set(""crashReporter"", reporter);","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 3: m_impl->Serialize<Stream>(s_);,void AddrMan::Serialize(Stream& s_) const	{	m_impl->Serialize<Stream>(s_);	},0
"Line 5: auto ret = Size_(net, in_new);","size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	LOCK(cs);	Check();	auto ret = Size_(net, in_new);	Check();	return ret;	}",0
"Line 6: std::getline(file, content, '\0'); // Reads the entire file content","// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content	file.close();	}	return content;	}",0
Line 4: ,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Line 6: Check();,"void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)	{	LOCK(cs);	Check();	SetServices_(addr, nServices);	Check();	}",0
Line 2: {,CScriptID ToScriptID(const ScriptHash& script_hash)	{	return CScriptID{uint160{script_hash}};	},0
Line 4: Check();,"void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	LOCK(cs);	Check();	Attempt_(addr, fCountFailure, time);	Check();	}",0
Line 3: return CScriptID{uint160{script_hash}};,CScriptID ToScriptID(const ScriptHash& script_hash)	{	return CScriptID{uint160{script_hash}};	},0
Line 3: rc = 5;,int returnChanges() {	int rc = 10;	rc = 5;	return rc;	},0
Line 5: nid_type nId = nIdCount++;,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",0
Line 11: },"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 60: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 49: const auto mapped_as{m_netgroupman.GetMappedAS(addr)};,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 11: AddrInfo& info = *pinfo;,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;	}",0
Line 10: },"// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content	file.close();	}	return content;	}",0
Line 179: // gin::IsolateHolder waits for tasks running in ThreadPool in its,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 40: // Loop through the addrman table until we find an appropriate entry,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 5: const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 25: return false;,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
"Line 22: // Addrman can be in an inconsistent state after failure, reset it","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
"Line 10: std::unordered_map<Network, NewTriedCount> local_counts;","int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 3: },int pointedInt(int* point) {	return *point;	},0
Line 100: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 49: },"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 20: },"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 16: },"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;	}",0
Line 2: {,CKeyID ToKeyID(const WitnessV0KeyHash& key_hash)	{	return CKeyID{uint160{key_hash}};	},0
Line 46: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 4: },void JustThrow()	{	throw 0;	},0
"Line 58: feature_list->InitFromCommandLine("""", """");","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 3: LOCK(cs);,"void AddrManImpl::Connected(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	Connected_(addr, time);	Check();	}",0
Line 12: ,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 64: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 34: // Will moving this address into tried evict another entry?,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 2: {,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);	}	return false;	}",0
Line 36: },"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 14: AddrInfo& info_new = mapInfo[id_new];,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 49: ,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
"Line 49: int i, position;","std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
"Line 1: nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const","nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;	}",0
Line 52: bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
"Line 1: std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const","std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	return m_impl->GetAddr(max_addresses, max_pct, network, filtered);	}",0
Line 10: },void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{	int temporary = 0;	}	},0
Line 9: return;,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",0
Line 9: private:,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 7: file.close();,"// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content	file.close();	}	return content;	}",0
Line 187: },"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 22: },"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 50: case TxoutType::MULTISIG:,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 2: {,"void ReadFromStream(AddrMan& addr, DataStream& ssPeers)	{	DeserializeDB(ssPeers, addr, false);	}",0
Line 1: int get_next_id() {,int get_next_id() {	static int id = 0;	return ++id;	},0
"Line 72: // With probability GetChance() * chance_factor, return the entry.","std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 1: //SE,"//SE		void add_element(std::vector<int>& numbers, int value) {	numbers.push_back(value);	}",0
Line 1: int squareValue(int sVval) { // returning square of input passed in by value,int squareValue(int sVval) { // returning square of input passed in by value	return sVval * sVval;	},0
Line 40: // stochastic test: previous nRefCount == N: 2^N times harder to increase it,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 67: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
"Line 37: os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 82: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 10: ,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 81: #if BUILDFLAG(IS_LINUX),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 60: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 4: ,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",0
Line 21: },"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 18: if (info.fInTried) {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 7: },class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 4: return reversed;,"std::string reverse_string(const std::string& str) {	std::string reversed = str;	std::reverse(reversed.begin(), reversed.end());	return reversed;	}",0
Line 31: mapNew[n] = info.nRefCount;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 1: int pointedInt(int* point) {,int pointedInt(int* point) {	return *point;	},0
Line 19: const AddrInfo& newInfo = mapInfo[id_new];,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 34: if (format >= Format::V1_DETERMINISTIC) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 38: if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 150: reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 35: ,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 13: // update info,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",0
Line 9: // Selects a random element from m_tried_collisions,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 4: ,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 15: std::vector<CAddress> addresses;,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 3: AssertLockHeld(cs);,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",0
Line 1: void AddrManImpl::Unserialize(Stream& s_),"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 7: if (added > 0) {,"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {	LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);	}	return added > 0;	}",0
Line 18: },"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Line 7: ,int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {	sum_total += array_to_sum[i];	}		return sum_total;	},0
Line 3: LOCK(cs);,"std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	LOCK(cs);	Check();	auto addresses = GetAddr_(max_addresses, max_pct, network, filtered);	Check();	return addresses;	}",0
Line 28: },"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 9: },"double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {	return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;	} else {	return numbers[n / 2];	}	}",0
Line 94: // can be ignored by older clients for backward compatibility.,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 3: AssertLockHeld(cs);,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 38: },"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 10: int privateint_;,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 23: },"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 6: },vector<int> filterEvenNumbers(const vector<int>& numbers) {	vector<int> evens;	for (int num : numbers) {	if (num % 2 == 0) {	evens.push_back(num);	}	}	return evens;	},0
"Line 1: std::vector<std::pair<AddrInfo, AddressPosition>> AddrMan::GetEntries(bool use_tried) const","std::vector<std::pair<AddrInfo, AddressPosition>> AddrMan::GetEntries(bool use_tried) const	{	return m_impl->GetEntries(use_tried);	}",0
Line 26: } catch (const std::exception& e) {,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 1: bool operator()(const WitnessV0KeyHash& dest) const { return true; },bool operator()(const WitnessV0KeyHash& dest) const { return true; },0
Line 159: if (nLost + nLostUnk > 0) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 5: },"std::string reverse_string(const std::string& str) {	std::string reversed = str;	std::reverse(reversed.begin(), reversed.end());	return reversed;	}",0
Line 3: },"int max(int a, int b) {	return (a > b) ? a : b;	}",0
"Line 1: void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& anchors)","void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& anchors)	{	LOG_TIME_SECONDS(strprintf(""Flush %d outbound block-relay-only peer addresses to anchors.dat"", anchors.size()));	SerializeFileDB(""anchors"", anchors_db_path, CAddress::V2_DISK(anchors));	}",0
Line 18: },"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 2: {,"bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	LOCK(cs);	Check();	auto ret = Add_(vAddr, source, time_penalty);	Check();	return ret;	}",0
Line 15: for (const auto& entry : mapInfo) {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 3: if (file.is_open()) {,"void write_to_file(const std::string& filename, const std::string& content) {	std::ofstream file(filename);	if (file.is_open()) {	file << content;	file.close();	}	}",0
Line 9: block_args = true;,bool CheckCommandLineArguments(const base::CommandLine::StringVector& argv) {	bool block_args = false;	for (const auto& arg : argv) {	if (arg == DashDash)	break;	if (block_args)	return false;	if (IsUrlArg(arg))	block_args = true;	}	return true;	},0
Line 3: },"std::string AutoUpdater::GetFeedURL() {	return """";	}",0
Line 2: return (a > b) ? a : b;,"int max(int a, int b) {	return (a > b) ? a : b;	}",0
Line 1: std::string AutoUpdater::GetFeedURL() {,"std::string AutoUpdater::GetFeedURL() {	return """";	}",0
"Line 1: int AddrInfo::GetBucketPosition(const uint256& nKey, bool fNew, int bucket) const","int AddrInfo::GetBucketPosition(const uint256& nKey, bool fNew, int bucket) const	{	uint64_t hash1 = (HashWriter{} << nKey << (fNew ? uint8_t{'N'} : uint8_t{'K'}) << bucket << GetKey()).GetCheapHash();	return hash1 % ADDRMAN_BUCKET_SIZE;	}",0
Line 3: array_copy[i] += value_to_add;,"vector<int> addToArray(vector<int> array_copy, int value_to_add) { // returning modified array passed in by value	for (int i = 0; i < array_copy.size(); ++i) {	array_copy[i] += value_to_add;	}	return array_copy;	}",0
Line 11: if (it2 != mapInfo.end()),"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",0
Line 34: // Give address at least 60 seconds to successfully connect,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 2: return x > 0;,bool is_positive(int x) {	return x > 0;	},0
Line 1: class Counter {,class Counter {	public:	void increment() {	count++;	}		private:	int count = 0;	};,0
Line 12: assert(false);,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}	}",0
Line 19: if (hashTmp != verifier.GetHash()) {,"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Line 4: },"size_t AddrMan::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	return m_impl->Size(net, in_new);	}",0
Line 4: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 158: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 166: // is stopping, or the user hooks process.emit('exit').","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 63: pinfo->nRefCount++;,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 15: },"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
"Line 6: ""--openssl-config"",","void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Line 2: {,"void AddrMan::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	m_impl->Attempt(addr, fCountFailure, time);	}",0
Line 4: },CScript operator()(const WitnessV0KeyHash& id) const	{	return CScript() << OP_0 << ToByteVector(id);	},0
Line 1: void clear_list(std::vector<int>& numbers) {,void clear_list(std::vector<int>& numbers) {	numbers.clear();	},0
Line 3: return CScript() << OP_1 << ToByteVector(tap);,CScript operator()(const WitnessV1Taproot& tap) const	{	return CScript() << OP_1 << ToByteVector(tap);	},0
Line 4: reversed = reversed * 10 + num % 10;,int reverse_number(int num) {	int reversed = 0;	while (num != 0) {	reversed = reversed * 10 + num % 10;	num /= 10;	}	return reversed;	},0
Line 4: ,"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 3: AssertLockHeld(cs);,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 75: },"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 39: * We don't use SERIALIZE_METHODS since the serialization and deserialization code has,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 29: },"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 1: std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path),"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);	return anchors;	}",0
Line 7: return addrInfos;,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries(bool from_tried) const	{	LOCK(cs);	Check();	auto addrInfos = GetEntries_(from_tried);	Check();	return addrInfos;	}",0
Line 18: const bool currently_online{NodeClock::now() - addr.nTime < 24h};,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 21: },"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 2: const std::string& target_version) {,"bool AutoUpdater::IsVersionAllowedForUpdate(const std::string& current_version,	const std::string& target_version) {	return false;	}",0
Line 56: // Initialize feature list.,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 1: int squareReference(int& sRval) { // returning square of input passed in by reference,int squareReference(int& sRval) { // returning square of input passed in by reference	return sRval * sRval;	},0
Line 32: #endif,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 3: },"bool is_divisible(int a, int b) {	return b != 0 && a % b == 0;	}",0
Line 3: },void incrementGlobal() {	++x;	},0
Line 7: for (int bucket = 0; bucket < bucket_count; ++bucket) {,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 9: },"std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)	{	std::vector<CAddress> anchors;	try {	DeserializeFileDB(anchors_db_path, CAddress::V2_DISK(anchors));	LogPrintf(""Loaded %i addresses from %s\n"", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename())));	} catch (const std::exception&) {	anchors.clear();	}		fs::remove(anchors_db_path);	return anchors;	}",0
Line 5: ,"bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;		const auto& c_locale = std::locale::classic();	const auto isspace = [&](auto ch) { return std::isspace(ch, c_locale); };	const auto scheme = arg.substr(0U, scheme_end);	return std::size(scheme) > 1U && std::isalpha(scheme.front(), c_locale) &&	std::ranges::none_of(scheme, isspace);	}",0
Line 1: void AddrManImpl::ResolveCollisions(),void AddrManImpl::ResolveCollisions()	{	LOCK(cs);	Check();	ResolveCollisions_();	Check();	},0
Line 42: const int nFactor{1 << pinfo->nRefCount};,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 36: // do not update if the max reference count is reached,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 24: // add services,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 21: },"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 5: if (!addr.IsRoutable()),"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 129: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 2: {,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 10: try {,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 1: void incrementGlobal() {,void incrementGlobal() {	++x;	},0
Line 28: *,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 44: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 6: {,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",0
Line 6: },"vector<int> addToArray(vector<int> array_copy, int value_to_add) { // returning modified array passed in by value	for (int i = 0; i < array_copy.size(); ++i) {	array_copy[i] += value_to_add;	}	return array_copy;	}",0
Line 180: // destructor and thus must be destroyed before ThreadPool starts skipping,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 65: if (i == ADDRMAN_BUCKET_SIZE) continue;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 9: assert(infoDelete.nRefCount > 0);,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",0
Line 7: ,"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);	}	return false;	}",0
Line 4: },"std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	return m_impl->GetAddr(max_addresses, max_pct, network, filtered);	}",0
Line 2: return sVval * sVval;,int squareValue(int sVval) { // returning square of input passed in by value	return sVval * sVval;	},0
Line 1: int fibonacci(int n) {,"int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;	if (cache.find(n) != cache.end()) return cache[n];		cache[n] = fibonacci(n - 1) + fibonacci(n - 2);	return cache[n];	}",0
Line 37: return addresses;,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 8: int count = 0;,class Counter {	public:	void increment() {	count++;	}		private:	int count = 0;	};,0
Line 48: erase_collision = true;,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 2: {,"bool AddrManImpl::Good(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	auto ret = Good_(addr, /*test_before_evict=*/true, time);	Check();	return ret;	}",0
Line 71: && vvTried[nKBucket][nKBucketPos] == -1) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 7: * * format version byte (@see `Format`),"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 118: for (auto bucket_entry : bucket_entries) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 1: void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const","void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 4: },"bool AutoUpdater::IsVersionAllowedForUpdate(const std::string& current_version,	const std::string& target_version) {	return false;	}",0
Line 4: ,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 5: // deprioritize very recent attempts away,"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;	}",0
Line 6: },"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);	}	return false;	}",0
Line 41: },"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 170: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 31: v8_crashpad_support::SetUp();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 7: Format format;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 1: std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const","std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	LOCK(cs);	Check();	auto addresses = GetAddr_(max_addresses, max_pct, network, filtered);	Check();	return addresses;	}",0
Line 95: s << m_netgroupman.GetAsmapChecksum();,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 23: },"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 6: ,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;	}",0
Line 3: #if !IS_MAS_BUILD(),"v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {	std::map<std::string, std::string> keys;	#if !IS_MAS_BUILD()	electron::crash_keys::GetCrashKeys(&keys);	#endif	return gin::ConvertToV8(isolate, keys);	}",0
Line 37: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 8: if (!pinfo),"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",0
Line 6: if (vvNew[nUBucket][nUBucketPos] != -1) {,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",0
Line 3: double fChance = 1.0;,"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;	}",0
Line 10: },"bool CBanDB::Write(const banmap_t& banSet)	{	std::vector<std::string> errors;	if (common::WriteSettings(m_banlist_json, {{JSON_KEY, BanMapToJson(banSet)}}, errors)) {	return true;	}		for (const auto& err : errors) {	LogError(""%s\n"", err);	}	return false;	}",0
Line 43: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 2: float w = (u = v);,"float unrelatedName(float u, float v) {	float w = (u = v);	return w;	}",0
Line 70: for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
"Line 1: void changePoint(int* pointed, int& ref) {","void changePoint(int* pointed, int& ref) {	pointed = &ref;	}",0
Line 91: },"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 29: if (network != std::nullopt && ai.GetNetClass() != network) continue;,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
"Line 98: bucket_entries.emplace_back(bucket, entry_index);","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 104: // to restore the entries to the buckets/positions they were in before,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 13: return true;,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;	}",0
Line 54: if (!fInsert) {,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
"Line 7: // if not found, bail out","void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Line 12: if (!pinfo) return false;,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 19: if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 84: if (!pid_string.empty()) {,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 6: },int reverse_number(int num) {	int reversed = 0;	while (num != 0) {	reversed = reversed * 10 + num % 10;	num /= 10;	}	return reversed;	},0
Line 41: double chance_factor = 1.0;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 2: {,void JustThrow()	{	throw 0;	},0
Line 4: return s.length();,//SEF		int stringLength(const string &s) {	return s.length();	},0
Line 8: int count = 0;,class Counter {	public:	int get_count() const {	return count;	}		private:	int count = 0;	};,0
Line 3: },"void remove_element(std::vector<int>& numbers, int value) {	numbers.erase(std::remove(numbers.begin(), numbers.end(), value), numbers.end());	}",0
"Line 1: void AddrMan::SetServices(const CService& addr, ServiceFlags nServices)","void AddrMan::SetServices(const CService& addr, ServiceFlags nServices)	{	m_impl->SetServices(addr, nServices);	}",0
Line 24: setTried.insert(n);,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 9: },"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 14: return false;,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 12: ,"void AddrManImpl::Connected_(const CService& addr, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	const auto update_interval{20min};	if (time - info.nTime > update_interval) {	info.nTime = time;	}	}",0
Line 12: return true;,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 4: },"vector<int> addToArray(vector<int> array_copy, int value_to_add) { // returning modified array passed in by value	for (int i = 0; i < array_copy.size(); ++i) {	array_copy[i] += value_to_add;	}	return array_copy;	}",0
Line 4: },"float unrelatedNameToo(float& u, float& v) {	float w = (u = v);	return w;	}",0
Line 3: return m_impl->GetEntries(use_tried);,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrMan::GetEntries(bool use_tried) const	{	return m_impl->GetEntries(use_tried);	}",0
Line 26: ,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 28: ,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 1: int reverse_number(int num) {,int reverse_number(int num) {	int reversed = 0;	while (num != 0) {	reversed = reversed * 10 + num % 10;	num /= 10;	}	return reversed;	},0
Line 94: if (m_network_counts.size() < local_counts.size()) {,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 17: return net_count.n_new + net_count.n_tried;,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 2: public:,class Counter {	public:	void increment() {	count++;	}		private:	int count = 0;	};,0
"Line 3: std::sort(numbers.begin(), numbers.end());","double median(std::vector<int> numbers) {	if (numbers.empty()) return 0.0;	std::sort(numbers.begin(), numbers.end());	int n = numbers.size();	if (n % 2 == 0) {	return (numbers[n / 2 - 1] + numbers[n / 2]) / 2.0;	} else {	return numbers[n / 2];	}	}",0
"Line 15: addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 32: // Remove the to-be-evicted item from the tried set.,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 53: },"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 6: if (!node_options_enabled) {,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 57: // Overwrite the existing new table entry.,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
"Line 11: ParamsStream s{s_, ser_params};","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 47: strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 8: if (!pinfo),"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;	}",0
Line 172: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 59: if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {","int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
"Line 1: std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const","std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
"Line 11: fChance *= pow(0.66, std::min(nAttempts, 8));","double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;	}",0
Line 52: ,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
"Line 17: return AddressPosition(/*tried_in=*/false,","std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
"Line 18: //   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 10: int privateint_;,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 4: return rc;,int returnChanges() {	int rc = 10;	rc = 5;	return rc;	},0
"Line 140: bucket_position = info.GetBucketPosition(nKey, true, bucket);","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 13: },"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}	}",0
Line 38: return false;,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 7: for (auto& bucket : vvNew) {,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",0
Line 53: auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 2: return std::max({a, b, c});","int max_of_three(int a, int b, int c) {	return std::max({a, b, c});	}",0
Line 22: if (lowest_compatible > FILE_FORMAT) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 25: if (new_count + tried_count == 0) return {};,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 1: void AutoUpdater::QuitAndInstall() {},void AutoUpdater::QuitAndInstall() {},0
"Line 8: const auto scheme = arg.substr(0U, scheme_end);","bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;		const auto& c_locale = std::locale::classic();	const auto isspace = [&](auto ch) { return std::isspace(ch, c_locale); };	const auto scheme = arg.substr(0U, scheme_end);	return std::size(scheme) > 1U && std::isalpha(scheme.front(), c_locale) &&	std::ranges::none_of(scheme, isspace);	}",0
"Line 1: bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 52: uv_loop_t* loop = uv_default_loop();,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 14: // libuv may mark stdin/stdout/stderr as close-on-exec, which interferes","// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 64: if (info.nRefCount) {,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 24: nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 36: return false;,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 125: node::Environment* env = nullptr;,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 126: // The entry shouldn't appear in more than,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 29: ,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 3: },bool is_even(int x) {	return x % 2 == 0;	},0
"Line 15: //   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 36: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 1: bool operator()(const PubKeyDestination& dest) const { return false; },bool operator()(const PubKeyDestination& dest) const { return false; },0
Line 13: // If id_new not found in mapInfo remove it from m_tried_collisions,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
"Line 24: if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)","// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 116: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 9: };,class Counter {	public:	int get_count() const {	return count;	}		private:	int count = 0;	};,0
Line 73: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 1: float unrelatedName(float u, float v) {","float unrelatedName(float u, float v) {	float w = (u = v);	return w;	}",0
Line 21: struct stat st;,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 81: for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 20: ,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 34: addresses.push_back(ai);,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 2: {,"WitnessV0ScriptHash::WitnessV0ScriptHash(const CScript& in)	{	CSHA256().Write(in.data(), in.size()).Finalize(begin());	}",0
Line 3: },void squareSelf(int& sSval) {	sSval *= sSval;	},0
Line 23: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 69: node::InitializeOncePerProcess(,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernelâ€™s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 16: // Node.js returns 9 from ProcessGlobalArgs for any errors encountered,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Line 6: return true;,bool is_prime(int n) {	if (n <= 1) return false;	for (int i = 2; i * i <= n; ++i) {	if (n % i == 0) return false;	}	return true;	},0
Line 16: return true;,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 20: return 0;,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
"Line 1: bool AddrMan::Good(const CService& addr, NodeSeconds time)","bool AddrMan::Good(const CService& addr, NodeSeconds time)	{	return m_impl->Good(addr, time);	}",0
Line 22: ,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 5: },class Counter {	public:	int get_count() const {	return count;	}		private:	int count = 0;	};,0
Line 4: if (env->HasVar(name)) {,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);	has = true;	}	}	return has;	},0
Line 8: ,class myClass {	public:	int publicint;		void setPrivateInt(int value) { // SE	privateint_ = value;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 1: std::string reverse_string(const std::string& str) {,"std::string reverse_string(const std::string& str) {	std::string reversed = str;	std::reverse(reversed.begin(), reversed.end());	return reversed;	}",0
Line 43: // Always serialize in the latest version (FILE_FORMAT).,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 4: Check();,"bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	LOCK(cs);	Check();	auto ret = Add_(vAddr, source, time_penalty);	Check();	return ret;	}",0
Line 2: {,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}	}",0
Line 52: case TxoutType::NONSTANDARD:,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 5: file.close();,"void write_to_file(const std::string& filename, const std::string& content) {	std::ofstream file(filename);	if (file.is_open()) {	file << content;	file.close();	}	}",0
Line 6: mutint_ = 5;,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
