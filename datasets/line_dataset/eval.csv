line,code,label
"Line 24: LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());","bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",1
Line 14: s >> compat;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 33: s >> nUBuckets;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
"Line 4: LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));","bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",1
"Line 50: LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",1
Line 73: info.fInTried = true;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
"Line 2: numbers.erase(std::remove(numbers.begin(), numbers.end(), value), numbers.end());","void remove_element(std::vector<int>& numbers, int value) {	numbers.erase(std::remove(numbers.begin(), numbers.end(), value), numbers.end());	}",1
Line 33: addressRet = hash;,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",1
Line 2: *points += 1;,int modifyPoint(int* points) {	*points += 1;	return *points;	},1
Line 7: stream << hashwriter.GetHash();,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;	}",1
"Line 5: Connected_(addr, time);","void AddrManImpl::Connected(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	Connected_(addr, time);	Check();	}",1
Line 18: it_1->second.nRandomPos = nRndPos2;,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",1
"Line 115: LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
Line 105: gin::V8SnapshotFileType::kWithAdditionalContext);,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",1
Line 9: *pnId = (*it).second;,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",1
Line 96: s >> entry_index;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",1
"Line 20: throw std::runtime_error{""Checksum mismatch, data corrupted""};","void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",1
Line 7: mapAddr[addr] = nId;,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",1
"Line 16: LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);","bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",1
Line 24: if (!fileout.Commit()) {,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",1
Line 54: vvTried[nKBucket][nKBucketPos] = nId;,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",1
"Line 23: std::ignore = freopen(""/dev/null"", ""r"", stdin);","// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",1
"Line 12: LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",1
Line 14: mapInfo.erase(nId);,"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",1
Line 29: },"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 81: },"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
"Line 50: int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);","bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 31: ,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 128: v8::HandleScope scope(isolate);,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 5: int getPrivateInt() const { // class member that returns private variable SEF,class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF	return privateint_;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
Line 100: },"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 21: ,"std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}		return infos;	}",0
Line 3: },int count_chars(const std::string& str) {	return str.length();	},0
Line 73: if (!mapNew.count(vvNew[n][i])),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 19: break;,"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;		int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;	SwapRandom(n, nRndPos);	const auto it{mapInfo.find(vRandom[n])};	assert(it != mapInfo.end());		const AddrInfo& ai{it->second};		// Filter by network (optional)	if (network != std::nullopt && ai.GetNetClass() != network) continue;		// Filter for quality	if (ai.IsTerrible(now) && filtered) continue;		addresses.push_back(ai);	}	LogDebug(BCLog::ADDRMAN, ""GetAddr returned %d random addresses\n"", addresses.size());	return addresses;	}",0
Line 22: },"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 12: for (auto& bucket : vvTried) {,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",0
"Line 43: addr.ToStringAddrPort(),","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 90: return -16;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 1: int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref,int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {	sum_total += array_to_sum[i];	}		return sum_total;	},0
Line 15: if (fCountFailure && info.m_last_count_attempt < m_last_good) {,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Line 27: // Decide if we are going to search the new or tried table,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 4: },"float unrelatedName(float u, float v) {	float w = (u = v);	return w;	}",0
Line 89: s << nIndex;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 112: serialized_asmap_checksum == supplied_asmap_checksum};,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 7: return reversed;,int reverse_number(int num) {	int reversed = 0;	while (num != 0) {	reversed = reversed * 10 + num % 10;	num /= 10;	}	return reversed;	},0
Line 93: // Ensure the flags and env variable does not propagate to userland.,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 12: },bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;	}	return true;	},0
Line 23: ,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 41: },"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
"Line 1: bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)","bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 4: try {,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;	}",0
Line 14: },"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",0
Line 4: ,"AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;	mapInfo[nId].nRandomPos = vRandom.size();	vRandom.push_back(nId);	nNew++;	m_network_counts[addr.GetNetwork()].n_new++;	if (pnId)	*pnId = nId;	return &mapInfo[nId];	}",0
"Line 5: ""--force-fips"",","void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Line 7: private:,class Counter {	public:	void increment() {	count++;	}		private:	int count = 0;	};,0
Line 2: {,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 3: return *points;,int modifyPoint(int* points) {	*points += 1;	return *points;	},0
Line 4: },"CScript GetScriptForDestination(const CTxDestination& dest)	{	return std::visit(CScriptVisitor(), dest);	}",0
Line 2: ,"//SE		void add_element(std::vector<int>& numbers, int value) {	numbers.push_back(value);	}",0
Line 5: // Run consistency checks 1 in m_consistency_check_ratio times if enabled,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}	}",0
Line 20: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 151: reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
"Line 20: /*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));","std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
"Line 26: // if it is not in new, something bad happened","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 32: local_counts[info.GetNetwork()].n_new++;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 160: },"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 30: return -4;,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 7: ,"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 9: private:,class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}		private:	int privateint_;	mutable int mutint_; // CURRENTLY NO WAY TO CHECK IF MUTABLE WITHOUT CONTEXT	};,0
"Line 2: : m_impl(std::make_unique<AddrManImpl>(netgroupman, deterministic, consistency_check_ratio)) {}","AddrMan::AddrMan(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: m_impl(std::make_unique<AddrManImpl>(netgroupman, deterministic, consistency_check_ratio)) {}",0
Line 3: void increment() {,class Counter {	public:	void increment() {	count++;	}		private:	int count = 0;	};,0
Line 16: },"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",0
Line 15: ,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 80: },"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 181: // CONTINUE_ON_SHUTDOWN tasks.,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 11: },void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{	int temporary = 0;	}	},0
Line 10: ,"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});		for (const auto& arg : argv) {	const auto key = std::string_view{arg}.substr(0, arg.find('='));	if (disallowed.contains(key)) {	LOG(ERROR) << ""The Node.js cli flag "" << key	<< "" is not supported in Electron"";	// Node.js returns 9 from ProcessGlobalArgs for any errors encountered	// when setting up cli flags and env vars. Since we're outlawing these	// flags (making them errors) exit with the same error code for	// consistency.	exit(9);	}	}	}",0
Line 2: {,"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 154: ++nLostUnk;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 26: if (vvTried[nKBucket][nKBucketPos] != -1) {,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 2: {,"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());	return false;	}		return true;	}",0
Line 2: {,CScript operator()(const CNoDestination& dest) const	{	return dest.GetScript();	},0
Line 66: AddrInfo info;,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 8: ,"std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();		// Selects a random element from m_tried_collisions	std::advance(it, insecure_rand.randrange(m_tried_collisions.size()));	nid_type id_new = *it;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	m_tried_collisions.erase(it);	return {};	}		const AddrInfo& newInfo = mapInfo[id_new];		// which tried bucket to move the entry to	int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);		const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];	return {info_old, info_old.m_last_try};	}",0
Line 1: double celsius_to_fahrenheit(double celsius) {,double celsius_to_fahrenheit(double celsius) {	return (celsius * 9.0 / 5.0) + 32.0;	},0
Line 1: double average(const std::vector<int>& numbers) {,double average(const std::vector<int>& numbers) {	if (numbers.empty()) return 0.0;	int sum = 0;	for (int num : numbers) {	sum += num;	}	return static_cast<double>(sum) / numbers.size();	},0
Line 1: int factorial(int n) {,int factorial(int n) {	if (n == 0) {	return 1;	}	return n * factorial(n - 1);	},0
Line 1: std::optional<AddressPosition> AddrMan::FindAddressEntry(const CAddress& addr),std::optional<AddressPosition> AddrMan::FindAddressEntry(const CAddress& addr)	{	return m_impl->FindAddressEntry(addr);	},0
"Line 10: std::ranges::none_of(scheme, isspace);","bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;		const auto& c_locale = std::locale::classic();	const auto isspace = [&](auto ch) { return std::isspace(ch, c_locale); };	const auto scheme = arg.substr(0U, scheme_end);	return std::size(scheme) > 1U && std::isalpha(scheme.front(), c_locale) &&	std::ranges::none_of(scheme, isspace);	}",0
"Line 3: std::reverse(reversed.begin(), reversed.end());","std::string reverse_string(const std::string& str) {	std::string reversed = str;	std::reverse(reversed.begin(), reversed.end());	return reversed;	}",0
Line 1: void ClearCrashKeyStub(const std::string& key) {},void ClearCrashKeyStub(const std::string& key) {},0
Line 5: if (str[left] != str[right]) {,bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;	}	return true;	},0
Line 163: const int check_code{CheckAddrman()};,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
"Line 21: // restrictions, when the parent process is not part of the app bundle, all","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 2: {,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
"Line 3: void update_record(int id, const std::string& new_value) {","std::unordered_map<int, std::string> database;		void update_record(int id, const std::string& new_value) {	database[id] = new_value;	}",0
"Line 3: auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
"Line 5: added += AddSingle(*it, source, time_penalty) ? 1 : 0;","bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {	LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);	}	return added > 0;	}",0
"Line 19: compat, INCOMPATIBILITY_BASE));","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 24: ,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 29: * 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 44: // Enter it into the new set again.,"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 3: AssertLockHeld(cs);,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",0
"Line 23: // if it is already in the tried set, don't do anything else","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 7: },bool is_prime(int n) {	if (n <= 1) return false;	for (int i = 2; i * i <= n; ++i) {	if (n % i == 0) return false;	}	return true;	},0
Line 1: void ThrowCatch(),void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{	int temporary = 0;	}	},0
Line 10: },"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};	}	}	}",0
Line 5: },class Counter {	public:	void increment() {	count++;	}		private:	int count = 0;	};,0
Line 3: // Generate random temporary filename,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
"Line 1: void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)","void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;	}",0
Line 8: },double average(const std::vector<int>& numbers) {	if (numbers.empty()) return 0.0;	int sum = 0;	for (int num : numbers) {	sum += num;	}	return static_cast<double>(sum) / numbers.size();	},0
Line 3: AssertLockHeld(cs);,"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {	info.m_last_count_attempt = time;	info.nAttempts++;	}	}",0
Line 6: if (now - m_last_try < 10min) {,"double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {	fChance *= 0.01;	}		// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.	fChance *= pow(0.66, std::min(nAttempts, 8));		return fChance;	}",0
Line 2: std::string read_file_content(const std::string& filename) {,"// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {	std::ifstream file(filename);	std::string content;	if (file.is_open()) {	std::getline(file, content, '\0'); // Reads the entire file content	file.close();	}	return content;	}",0
Line 4: Check();,void AddrManImpl::ResolveCollisions()	{	LOCK(cs);	Check();	ResolveCollisions_();	Check();	},0
Line 2: {,"CScript GetScriptForDestination(const CTxDestination& dest)	{	return std::visit(CScriptVisitor(), dest);	}",0
"Line 1: std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const","std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
"Line 112: uv_loop_configure(loop, UV_METRICS_IDLE_TIME);","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 10: if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;	}",0
Line 17: ,"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 2: {,bool AddrInfo::IsTerrible(NodeSeconds now) const	{	if (now - m_last_try <= 1min) { // never remove things tried in the last minute	return false;	}		if (nTime > now + 10min) { // came in a flying DeLorean	return true;	}		if (now - nTime > ADDRMAN_HORIZON) { // not seen in recent history	return true;	}		if (TicksSinceEpoch<std::chrono::seconds>(m_last_success) == 0 && nAttempts >= ADDRMAN_RETRIES) { // tried N times and never a success	return true;	}		if (now - m_last_success > ADDRMAN_MIN_FAIL && nAttempts >= ADDRMAN_MAX_FAILURES) { // N successive failures in the last week	return true;	}		return false;	},0
Line 92: // It's possible that m_network_counts may have all-zero entries that local_counts,"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 1: std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr),"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));	}	}",0
Line 25: WitnessV0KeyHash hash;,"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
"Line 1: util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
Line 9: } else {,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;	}",0
Line 7: },"void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	LOCK(cs);	Check();	Attempt_(addr, fCountFailure, time);	Check();	}",0
Line 151: if (it->second.fInTried == false && it->second.nRefCount == 0) {,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 8: ++left;,bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;	}	return true;	},0
Line 9: },"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {	LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);	}	return added > 0;	}",0
Line 13: return nullptr;,"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",0
Line 50: static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 62: },"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
Line 76: },"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 28: #endif  // BUILDFLAG(IS_MAC),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 6: ,"int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;	if (cache.find(n) != cache.end()) return cache[n];		cache[n] = fibonacci(n - 1) + fibonacci(n - 2);	return cache[n];	}",0
Line 19: },"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 99: },"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 3: LOCK(cs);,"bool AddrManImpl::Good(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	auto ret = Good_(addr, /*test_before_evict=*/true, time);	Check();	return ret;	}",0
Line 71: for (const auto& entry : mapInfo) {,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 12: ,"void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.nServices = nServices;	}",0
Line 27: * * asmap checksum,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 2: ,"std::unordered_map<int, std::string> database;		void update_record(int id, const std::string& new_value) {	database[id] = new_value;	}",0
Line 2: ,bool is_initialized = false;		void initialize() {	is_initialized = true;	},0
Line 10: return false;,"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;	}		return true;	}",0
Line 20: // For details see https://github.com/libuv/libuv/issues/2062,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 61: // Explicitly register electron's builtin bindings.,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 3: LOCK(cs);,"void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	LOCK(cs);	Check();	Attempt_(addr, fCountFailure, time);	Check();	}",0
"Line 1: std::unordered_map<int, std::string> database;","std::unordered_map<int, std::string> database;		void update_record(int id, const std::string& new_value) {	database[id] = new_value;	}",0
Line 7: return ret;,"size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	LOCK(cs);	Check();	auto ret = Size_(net, in_new);	Check();	return ret;	}",0
Line 113: ,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 9: return has;,bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);	has = true;	}	}	return has;	},0
Line 2: {,CScript operator()(const PubKeyDestination& dest) const	{	return CScript() << ToByteVector(dest.GetPubKey()) << OP_CHECKSIG;	},0
"Line 50: infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);","void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;	nTried++;	info.fInTried = true;	m_network_counts[info.GetNetwork()].n_tried++;	}",0
Line 8: ,"void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;		const int err{CheckAddrman()};	if (err) {	LogPrintf(""ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n"", err);	assert(false);	}	}",0
Line 5: if (use_tried) {,"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {	return vvNew[bucket][position];	}	}		return -1;	}",0
"Line 9: const auto path_addr{args.GetDataDirNet() / ""peers.dat""};","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}	return addrman;	}",0
"Line 47: // Iterate over the positions of that bucket, starting at the initial one,","std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
"Line 1: AddrMan::AddrMan(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)","AddrMan::AddrMan(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: m_impl(std::make_unique<AddrManImpl>(netgroupman, deterministic, consistency_check_ratio)) {}",0
Line 5: if (nRndPos1 == nRndPos2),"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;	it_2->second.nRandomPos = nRndPos1;		vRandom[nRndPos1] = nId2;	vRandom[nRndPos2] = nId1;	}",0
Line 28: ,"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 11: return true;,bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;	}	return true;	},0
Line 7: return addresses;,"std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	LOCK(cs);	Check();	auto addresses = GetAddr_(max_addresses, max_pct, network, filtered);	Check();	return addresses;	}",0
"Line 15: // with chromium's subprocess spawning. As a workaround, we detect if these","// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 3: },void AutoUpdater::SetDelegate(Delegate* delegate) {	delegate_ = delegate;	},0
Line 1: bool operator()(const WitnessV1Taproot& dest) const { return true; },bool operator()(const WitnessV1Taproot& dest) const { return true; },0
Line 4: },"void AddrMan::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	m_impl->Attempt(addr, fCountFailure, time);	}",0
Line 3: return 1;,int factorial(int n) {	if (n == 0) {	return 1;	}	return n * factorial(n - 1);	},0
Line 7: catch (...),void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{	int temporary = 0;	}	},0
Line 114: // Initialize gin::IsolateHolder.,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 8: for (auto& entry : bucket) {,"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {	for (auto& entry : bucket) {	entry = -1;	}	}	}",0
Line 53: if (vvNew[nUBucket][nUBucketPos] != nId) {,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 64: // Parse Node.js cli flags and strip out disallowed options.,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 16: // update info,"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), tried_bucket, tried_bucket_pos);	return true;	}	}",0
Line 57: if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 1: CScript operator()(const ScriptHash& scriptID) const,CScript operator()(const ScriptHash& scriptID) const	{	return CScript() << OP_HASH160 << ToByteVector(scriptID) << OP_EQUAL;	},0
"Line 21: pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);","bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
"Line 3: void update_global_array(int index, int value) {","// 6. Modifies a global array	int global_array[10] = {0};	void update_global_array(int index, int value) {	if (index >= 0 && index < 10) {	global_array[index] = value;	}	}",0
Line 60: },"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 16: },"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",0
Line 10: infoDelete.nRefCount--;,"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}	}",0
"Line 26: uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};	if (check_code != 0) {	throw std::ios_base::failure(strprintf(	""Corrupt data. Consistency check failed with code %s"",	check_code));	}	}",0
Line 6: },"int AddrInfo::GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const	{	uint64_t hash1 = (HashWriter{} << nKey << GetKey()).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;	}",0
Line 38: if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}	}		return 0;	}",0
Line 6: ,"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
"Line 32: std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());","bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V1_TAPROOT: {	WitnessV1Taproot tap;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), tap.begin());	addressRet = tap;	return true;	}	case TxoutType::ANCHOR: {	addressRet = PayToAnchor();	return true;	}	case TxoutType::WITNESS_UNKNOWN: {	addressRet = WitnessUnknown{vSolutions[0][0], vSolutions[1]};	return true;	}	case TxoutType::MULTISIG:	case TxoutType::NULL_DATA:	case TxoutType::NONSTANDARD:	addressRet = CNoDestination(scriptPubKey);	return false;	} // no default case, so the compiler can warn about missing cases	assert(false);	}",0
Line 152: #else,"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.	base::ThreadPoolInstance::Get()->Shutdown();		v8::V8::Dispose();		return exit_code;	}",0
Line 54: if (node_id != -1) {,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
Line 3: ,int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;		for (int i = 0; i < array_to_sum.size(); ++i) {	sum_total += array_to_sum[i];	}		return sum_total;	},0
"Line 26: if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)","// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stderr);	}",0
Line 12: if (addr == source) {,"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {	if (!fInsert) {	AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];	if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {	// Overwrite the existing new table entry.	fInsert = true;	}	}	if (fInsert) {	ClearNew(nUBucket, nUBucketPos);	pinfo->nRefCount++;	vvNew[nUBucket][nUBucketPos] = nId;	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Added %s%s to new[%i][%i]\n"",	addr.ToStringAddrPort(), (mapped_as ? strprintf("" mapped to AS%i"", mapped_as) : """"), nUBucket, nUBucketPos);	} else {	if (pinfo->nRefCount == 0) {	Delete(nId);	}	}	}	return fInsert;	}",0
Line 38: ,"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}		return true;	}",0
Line 3: },void setSix(){ // setting global variable	x = 6;	},0
Line 4: Check();,"std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	LOCK(cs);	Check();	auto addrRet = Select_(new_only, networks);	Check();	return addrRet;	}",0
Line 4: },"void AddrMan::Connected(const CService& addr, NodeSeconds time)	{	m_impl->Connected(addr, time);	}",0
Line 2: {,"size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{	AssertLockHeld(cs);		if (!net.has_value()) {	if (in_new.has_value()) {	return *in_new ? nNew : nTried;	} else {	return vRandom.size();	}	}	if (auto it = m_network_counts.find(*net); it != m_network_counts.end()) {	auto net_count = it->second;	if (in_new.has_value()) {	return *in_new ? net_count.n_new : net_count.n_tried;	} else {	return net_count.n_new + net_count.n_tried;	}	}	return 0;	}",0
Line 67: nIds++;,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
Line 14: *     version N will still try to parse it.,"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;	}	}	}	// Store asmap checksum after bucket entries so that it	// can be ignored by older clients for backward compatibility.	s << m_netgroupman.GetAsmapChecksum();	}",0
