line,code,label
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (if_statement condition: (condition_clause value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (ERROR (identifier)) (string_literal (string_content) (escape_sequence))) (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))))))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier))))) consequence: (compound_statement (return_statement (false)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (identifier)) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (identifier) (identifier))))) consequence: (compound_statement (for_range_loop (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content) (escape_sequence)) (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier))) (identifier)))))) (return_statement (false)))) (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) (identifier))))) (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content) (escape_sequence)) (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier))) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))))),"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);	}	return false;	}		try {	BanMapFromJson(settings[JSON_KEY], banSet);	} catch (const std::runtime_error& e) {	LogPrintf(""Cannot parse banlist %s: %s\n"", fs::PathToString(m_banlist_json), e.what());",1
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (MISSING ""}""))))","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;",1
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (identifier) (identifier)))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier))) (identifier) (identifier) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier)))))))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (MISSING ""}""))))","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;",1
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (condition_clause value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (ERROR (identifier)) (string_literal (string_content) (escape_sequence))) (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))))))),"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));",1
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (type_identifier) declarator: (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (return_statement (false))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (pointer_expression argument: (identifier)))) (comment) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (return_statement (false))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal)))))) consequence: (return_statement (false))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (comment) (condition_clause value: (binary_expression left: (identifier) right: (parenthesized_expression (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))))) (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence)) (conditional_expression condition: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list)) alternative: (string_literal)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (return_statement (false))) (comment) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier)))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (identifier) (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence)))),"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),	m_tried_collisions.size());	return false;	} else {	// move nId to the tried tables	MakeTried(info, nId);	const auto mapped_as{m_netgroupman.GetMappedAS(addr)};	LogDebug(BCLog::ADDRMAN, ""Moved %s%s to tried[%i][%i]\n"",",1
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (identifier) (identifier)))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier))) (identifier) (identifier) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier)))))))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (comment) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal)))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (true))))),"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;",1
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type))))) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (identifier))) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (MISSING ""}""))))","void remove_element(std::vector<int>& numbers, int value) {	numbers.erase(std::remove(numbers.begin(), numbers.end(), value), numbers.end());",1
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier))))) (condition_clause value: (identifier)) (case_statement value: (qualified_identifier scope: (namespace_identifier) name: (identifier)) (compound_statement (declaration type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (abstract_array_declarator size: (number_literal)))))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier)))))) alternative: (else_clause (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier)))))))) (return_statement (false)))) (case_statement value: (qualified_identifier scope: (namespace_identifier) name: (identifier)) (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))))))))) (return_statement (true)))) (case_statement value: (qualified_identifier scope: (namespace_identifier) name: (identifier)) (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))))))))) (return_statement (true)))) (case_statement value: (qualified_identifier scope: (namespace_identifier) name: (identifier)) (compound_statement (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (return_statement (true)))) (qualified_identifier scope: (namespace_identifier) name: (identifier)) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))))),"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;",1
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (pointer_declarator declarator: (identifier))))) body: (compound_statement (expression_statement (assignment_expression left: (pointer_expression argument: (identifier)) right: (number_literal))) (MISSING ""}""))))",int modifyPoint(int* points) {	*points += 1;,1
(ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier)))) (expression_statement (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (call_expression function: (identifier) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list))) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))),"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();",1
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier)))) (MISSING ""}""))))","void AddrManImpl::Connected(const CService& addr, NodeSeconds time)	{	LOCK(cs);	Check();	Connected_(addr, time);",1
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (sized_type_specifier type: (primitive_type)) declarator: (identifier)) (parameter_declaration type: (sized_type_specifier type: (primitive_type)) declarator: (identifier))) (type_qualifier)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (return_statement)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (expression_statement (assignment_expression left: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) right: (identifier))) (MISSING ""}""))))","void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());		it_1->second.nRandomPos = nRndPos2;",1
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (identifier) (identifier)))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier))) (identifier) (identifier) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier)))))))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (comment) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal)))) consequence: (compound_statement (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (true))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))) alternative: (else_clause (compound_statement (expression_statement (update_expression argument: (identifier)))))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (comment) (comment) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)) (type_descriptor type: (primitive_type))))))))) declarator: (identifier)) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (number_literal)) right: (binary_expression left: (identifier) right: (identifier)))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))))))))) (comment) (comment) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) consequence: (compound_statement (expression_statement (binary_expression left: (identifier) right: (identifier))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (binary_expression left: (identifier) right: (identifier)))))) (condition_clause value: (unary_expression argument: (identifier))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence))))))),"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");",1
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list)))))) consequence: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) consequence: (compound_statement (expression_statement (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (concatenated_string (string_literal (string_content)) (string_literal (string_content)))))))))) (comment) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))))) consequence: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal)) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (field_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))) (comment) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list)))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal) (string_literal)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (initializer_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) (for_range_loop (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) body: (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal))) consequence: (compound_statement (return_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (comment) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) alternative: (preproc_elif condition: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (parenthesized_expression (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);",1
"(translation_unit (function_definition type: (type_identifier) declarator: (pointer_declarator declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (pointer_declarator declarator: (identifier)))))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (return_statement (null))) (if_statement condition: (condition_clause value: (identifier)) consequence: (expression_statement (assignment_expression left: (pointer_expression argument: (identifier)) right: (field_expression argument: (parenthesized_expression (pointer_expression argument: (identifier))) field: (field_identifier))))) (MISSING ""}""))))","AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;",1
(ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (identifier) (identifier)))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier))) (identifier) (identifier) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier)))))))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (comment) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal)))) consequence: (compound_statement (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (true))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))) alternative: (else_clause (compound_statement (expression_statement (update_expression argument: (identifier)))))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (comment) (comment) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)) (type_descriptor type: (primitive_type))))))))) declarator: (identifier)) initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (expression_statement (binary_expression left: (identifier) right: (identifier))) initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (expression_statement (binary_expression left: (identifier) right: (identifier)))),"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;",1
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))) (optional_parameter_declaration type: (primitive_type) declarator: (identifier) default_value: (true)))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier)))) (comment) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (call_expression function: (identifier) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (throw_statement (compound_literal_expression type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) value: (initializer_list (string_literal (string_content))))))) (comment) (expression_statement (binary_expression left: (identifier) right: (identifier))) (comment) (condition_clause value: (identifier)) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (throw_statement (compound_literal_expression type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) value: (initializer_list (string_literal (string_content))))))),"void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}		// de-serialize data	verifier >> data;		// verify checksum	if (fCheckSum) {	uint256 hashTmp;	stream >> hashTmp;	if (hashTmp != verifier.GetHash()) {	throw std::runtime_error{""Checksum mismatch, data corrupted""};",1
"(translation_unit (function_definition type: (type_identifier) declarator: (pointer_declarator declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (pointer_declarator declarator: (identifier)))))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (update_expression argument: (identifier)))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier))))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (MISSING ""}""))))","AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);		nid_type nId = nIdCount++;	mapInfo[nId] = AddrInfo(addr, addrSource);	mapAddr[addr] = nId;",1
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (if_statement condition: (condition_clause value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (ERROR (identifier)) (string_literal (string_content) (escape_sequence))) (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))))))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier))))) consequence: (compound_statement (return_statement (false)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (identifier)) (condition_clause value: (unary_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (identifier) (identifier))))) (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) (expression_statement (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content) (escape_sequence)) (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier))) (identifier)))))),"bool CBanDB::Read(banmap_t& banSet)	{	if (fs::exists(m_banlist_dat)) {	LogPrintf(""banlist.dat ignored because it can only be read by "" CLIENT_NAME "" version 22.x. Remove %s to silence this warning.\n"", fs::quoted(fs::PathToString(m_banlist_dat)));	}	// If the JSON banlist does not exist, then recreate it	if (!fs::exists(m_banlist_json)) {	return false;	}		std::map<std::string, common::SettingsValue> settings;	std::vector<std::string> errors;		if (!common::ReadSettings(m_banlist_json, settings, errors)) {	for (const auto& err : errors) {	LogPrintf(""Cannot load banlist %s: %s\n"", fs::PathToString(m_banlist_json), err);",1
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) (comment) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (call_expression function: (identifier) arguments: (argument_list)) field: (template_method name: (field_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type))))) arguments: (argument_list))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (identifier))))) (comment) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (string_literal (string_content)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier)))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content) (escape_sequence)) (identifier) (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (return_statement (false)))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier))))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (return_statement (false)))) (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))),"bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {",1
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (comment) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (parenthesized_expression (binary_expression left: (identifier) right: (identifier))) right: (identifier))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) consequence: (compound_statement (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (expression_statement (update_expression argument: (field_expression argument: (identifier) field: (field_identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))) consequence: (break_statement)))))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) consequence: (compound_statement (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))) right: (number_literal))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (comment) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (false))) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))))) (comment) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (identifier) (identifier) (identifier) (identifier)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))))) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (MISSING ""}""))))","void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);	}	assert(vvTried[nKBucket][nKBucketPos] == -1);		vvTried[nKBucket][nKBucketPos] = nId;",1
"(translation_unit (comment) (comment) (comment) (preproc_include path: (string_literal (string_content))) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list)) body: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (declaration type: (struct_specifier name: (type_identifier)) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))) right: (number_literal)) right: (binary_expression left: (identifier) right: (identifier)))) consequence: (expression_statement (assignment_expression left: (qualified_identifier scope: (namespace_identifier) name: (identifier)) right: (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (string_literal (string_content)) (identifier)))))) (MISSING ""}""))))","// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);",1
(ERROR type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))))))) (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type))))) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (identifier))) (number_literal) (number_literal))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (string_literal (string_content)))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier) (identifier) (comment) (identifier)))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (string_literal (string_content)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list (binary_expression left: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)) right: (identifier)))))))),"util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));",1
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))) right: (number_literal))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (unary_expression argument: (field_expression argument: (identifier) field: (field_identifier)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (field_expression argument: (identifier) field: (field_identifier)) (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal))))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (MISSING ""}""))))","void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);",1
"(translation_unit (function_definition type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))))))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type))))) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (identifier))) (number_literal) (number_literal))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (string_literal (string_content)))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier) (identifier) (comment) (identifier)))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (string_literal (string_content)))))) (try_statement body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list (binary_expression left: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)) right: (identifier)))))))) (catch_clause parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (abstract_reference_declarator))) body: (compound_statement (comment) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier) (identifier) (comment) (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content) (escape_sequence)) (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (catch_clause parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (abstract_reference_declarator))) body: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (identifier) (binary_expression left: (cast_expression type: (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) value: (identifier)) right: (string_literal (string_content))))))) consequence: (compound_statement (return_statement (compound_literal_expression type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) value: (initializer_list (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content))))))))))) (comment) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier) (identifier) (comment) (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content) (escape_sequence)) (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (catch_clause parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier)))) body: (compound_statement (return_statement (compound_literal_expression type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) value: (initializer_list (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)))) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (identifier) (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier))))))))))))) (MISSING ""}""))))","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};	try {	DeserializeFileDB(path_addr, *addrman);	LogPrintf(""Loaded %i addresses from peers.dat  %dms\n"", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));	} catch (const DbNotFoundError&) {	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating peers.dat because the file was not found (%s)\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const InvalidAddrManVersionError&) {	if (!RenameOver(path_addr, (fs::path)path_addr + "".bak"")) {	return util::Error{strprintf(_(""Failed to rename invalid peers.dat file. Please move or delete it and try again.""))};	}	// Addrman can be in an inconsistent state after failure, reset it	addrman = std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman);	LogPrintf(""Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n"", fs::quoted(fs::PathToString(path_addr)));	DumpPeerAddresses(args, *addrman);	} catch (const std::exception& e) {	return util::Error{strprintf(_(""Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.""),	e.what(), CLIENT_BUGREPORT, fs::quoted(fs::PathToString(path_addr)))};	}",0
(translation_unit (function_definition type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (reference_declarator (identifier)))) (type_qualifier)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (initializer_list))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (for_range_loop type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (continue_statement))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (return_statement (initializer_list))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (number_literal))) consequence: (return_statement (initializer_list))) (comment) (comment) (declaration type: (primitive_type) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (false)))) alternative: (else_clause (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (true)))) alternative: (else_clause (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (conditional_expression condition: (identifier) consequence: (identifier) alternative: (identifier))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (while_statement condition: (condition_clause value: (number_literal)) body: (compound_statement (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (comment) (comment) (declaration type: (primitive_type) declarator: (identifier) declarator: (identifier)) (declaration type: (type_identifier) declarator: (identifier)) (for_statement initializer: (assignment_expression left: (identifier) right: (number_literal)) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (binary_expression left: (parenthesized_expression (binary_expression left: (identifier) right: (identifier))) right: (identifier)))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list)))))) consequence: (break_statement))) alternative: (else_clause (compound_statement (break_statement)))))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (continue_statement)) (comment) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (declaration (type_qualifier) type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (initializer_list (field_expression argument: (identifier) field: (field_identifier))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (template_method name: (field_identifier) arguments: (template_argument_list (number_literal)))) arguments: (argument_list)) right: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal)))))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (conditional_expression condition: (identifier) consequence: (string_literal (string_content)) alternative: (string_literal (string_content)))))) (return_statement (initializer_list (identifier) (field_expression argument: (identifier) field: (field_identifier)))))) (comment) (expression_statement (assignment_expression left: (identifier) right: (number_literal)))))))),"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}	}",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (return_statement (false))) (declaration type: (type_identifier) declarator: (identifier)) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (user_defined_literal (number_literal) (literal_suffix)))))) (if_statement condition: (condition_clause value: (identifier)) consequence: (compound_statement (comment) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (binary_expression left: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)) right: (field_expression argument: (identifier) field: (field_identifier))) right: (user_defined_literal (number_literal) (literal_suffix)))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (conditional_expression condition: (identifier) consequence: (user_defined_literal (number_literal) (literal_suffix)) alternative: (user_defined_literal (number_literal) (literal_suffix)))))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)) right: (identifier)))) consequence: (compound_statement (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))) (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))))))) (comment) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (field_expression argument: (identifier) field: (field_identifier))))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (field_expression argument: (identifier) field: (field_identifier)))) consequence: (compound_statement (return_statement (false)))) (comment) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (return_statement (false))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))) consequence: (return_statement (false))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))) consequence: (compound_statement (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (number_literal) right: (field_expression argument: (identifier) field: (field_identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))) right: (number_literal))) consequence: (return_statement (false)))))) alternative: (else_clause (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier) (pointer_expression argument: (identifier)))))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))) (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier) (identifier))))) (MISSING ""}""))))","bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (comment) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (call_expression function: (identifier) arguments: (argument_list)) field: (template_method name: (field_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type))))) arguments: (argument_list))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (identifier))))) (comment) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (string_literal (string_content)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier)))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content) (escape_sequence)) (identifier) (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (return_statement (false)))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier))))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (return_statement (false)))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content) (escape_sequence)) (identifier) (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (return_statement (false)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (MISSING ""}""))))","bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();	",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list)))))) consequence: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) consequence: (compound_statement (expression_statement (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (concatenated_string (string_literal (string_content)) (string_literal (string_content)))))))))) (comment) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))))) consequence: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal)) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (field_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))) (comment) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list)))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal) (string_literal)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (initializer_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) (for_range_loop (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) body: (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal))) consequence: (compound_statement (return_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (comment) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) alternative: (preproc_elif condition: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (parenthesized_expression (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (string_literal (string_content))))) (comment) (comment) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier)))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (call_expression function: (field_expression argument: (call_expression function: (field_expression argument: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) field: (field_identifier)) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list)) field: (field_identifier)))) (declaration type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier)) (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (null))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (null))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))))),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);",0
(translation_unit (ERROR (type_identifier) (access_specifier) (field_declaration type: (primitive_type) declarator: (field_identifier)) type: (primitive_type) (function_declarator declarator: (field_identifier) parameters: (parameter_list) (type_qualifier))) (comment)),class myClass {	public:	int publicint;		int getPrivateInt() const { // class member that returns private variable SEF,0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (qualified_identifier scope: (namespace_identifier) name: (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (primitive_type))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (parenthesized_expression (binary_expression left: (identifier) right: (identifier)))))) consequence: (return_statement (number_literal))) (for_range_loop (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (declaration (type_qualifier) type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (field_expression argument: (identifier) field: (field_identifier)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list (field_expression argument: (identifier) field: (field_identifier)))))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (return_statement (number_literal))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))) alternative: (else_clause (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal)) right: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (unary_expression argument: (field_expression argument: (identifier) field: (field_identifier)))) consequence: (return_statement (number_literal))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal)) right: (binary_expression left: (cast_expression type: (type_descriptor type: (primitive_type)) value: (field_expression argument: (identifier) field: (field_identifier))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) right: (binary_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (field_expression argument: (identifier) field: (field_identifier)))) right: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))))) consequence: (compound_statement (return_statement (number_literal)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (identifier)))) consequence: (return_statement (number_literal))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))) consequence: (return_statement (number_literal))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (binary_expression left: (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))) right: (identifier)))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))) right: (identifier))) consequence: (compound_statement (return_statement (number_literal)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))))))))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))) consequence: (return_statement (number_literal))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (binary_expression left: (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier))) right: (identifier)))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (update_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))) right: (number_literal))) consequence: (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))))))))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (number_literal))) (comment) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (return_statement (number_literal)))) (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (structured_binding_declarator (identifier) (identifier))) right: (identifier) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) field: (field_identifier)) right: (field_expression argument: (identifier) field: (field_identifier))) right: (binary_expression left: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) field: (field_identifier)) right: (field_expression argument: (identifier) field: (field_identifier))))) consequence: (compound_statement (return_statement (number_literal)))))),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts	// doesn't have if addrs from a network were being added and then removed again in the past.	if (m_network_counts.size() < local_counts.size()) {	return -20;	}	for (const auto& [net, count] : m_network_counts) {	if (local_counts[net].n_new != count.n_new || local_counts[net].n_tried != count.n_tried) {	return -21;	}",0
"(translation_unit (function_definition type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))))))) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier))) (type_qualifier)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (conditional_expression condition: (identifier) consequence: (identifier) alternative: (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))))))) declarator: (identifier)) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (comment) (conditional_expression condition: (identifier) consequence: (number_literal) alternative: (field_expression argument: (identifier) field: (field_identifier))) (identifier) (identifier))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))))))))) (MISSING ""}""))))","std::vector<std::pair<AddrInfo, AddressPosition>> AddrManImpl::GetEntries_(bool from_tried) const	{	AssertLockHeld(cs);		const int bucket_count = from_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT;	std::vector<std::pair<AddrInfo, AddressPosition>> infos;	for (int bucket = 0; bucket < bucket_count; ++bucket) {	for (int position = 0; position < ADDRMAN_BUCKET_SIZE; ++position) {	nid_type id = GetEntry(from_tried, bucket, position);	if (id >= 0) {	AddrInfo info = mapInfo.at(id);	AddressPosition location = AddressPosition(	from_tried,	/*multiplicity_in=*/from_tried ? 1 : info.nRefCount,	bucket,	position);	infos.emplace_back(info, location);	}	}	}	",0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))))) body: (compound_statement (return_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))),int count_chars(const std::string& str) {	return str.length();	},0
(ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (qualified_identifier scope: (namespace_identifier) name: (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (primitive_type))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (parenthesized_expression (binary_expression left: (identifier) right: (identifier)))))) consequence: (return_statement (number_literal))) (for_range_loop (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (declaration (type_qualifier) type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (field_expression argument: (identifier) field: (field_identifier)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list (field_expression argument: (identifier) field: (field_identifier)))))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (return_statement (number_literal))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))) alternative: (else_clause (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal)) right: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (unary_expression argument: (field_expression argument: (identifier) field: (field_identifier)))) consequence: (return_statement (number_literal))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal)) right: (binary_expression left: (cast_expression type: (type_descriptor type: (primitive_type)) value: (field_expression argument: (identifier) field: (field_identifier))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) right: (binary_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (field_expression argument: (identifier) field: (field_identifier)))) right: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))))) consequence: (compound_statement (return_statement (number_literal)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (identifier)))) consequence: (return_statement (number_literal))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))) consequence: (return_statement (number_literal))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (binary_expression left: (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))) right: (identifier)))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))) right: (identifier))) consequence: (compound_statement (return_statement (number_literal)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))))))))) initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))))),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))",0
(translation_unit (ERROR type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (parameter_declaration (type_qualifier) type: (primitive_type) declarator: (identifier))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (number_literal)))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (identifier))))))) (comment) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)))) arguments: (argument_list))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) initializer: (declaration type: (sized_type_specifier type: (primitive_type)) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) update: (update_expression argument: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (identifier))) consequence: (break_statement)))),"std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	AssertLockHeld(cs);		size_t nNodes = vRandom.size();	if (max_pct != 0) {	nNodes = max_pct * nNodes / 100;	}	if (max_addresses != 0) {	nNodes = std::min(nNodes, max_addresses);	}		// gather a list of random nodes, skipping those of low quality	const auto now{Now<NodeSeconds>()};	std::vector<CAddress> addresses;	addresses.reserve(nNodes);	for (unsigned int n = 0; n < vRandom.size(); n++) {	if (addresses.size() >= nNodes)	break;",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (return_statement (false))) (declaration type: (type_identifier) declarator: (identifier)) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (user_defined_literal (number_literal) (literal_suffix)))))) (condition_clause value: (identifier)) (comment) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (binary_expression left: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)) right: (field_expression argument: (identifier) field: (field_identifier))) right: (user_defined_literal (number_literal) (literal_suffix)))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (conditional_expression condition: (identifier) consequence: (user_defined_literal (number_literal) (literal_suffix)) alternative: (user_defined_literal (number_literal) (literal_suffix)))))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)) right: (identifier)))) consequence: (compound_statement (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))) (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))))))))),"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}",0
(translation_unit (ERROR (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier)))) (field_initializer_list (field_initializer (field_identifier) (initializer_list (identifier))) (field_initializer (field_identifier) (initializer_list (conditional_expression condition: (identifier) consequence: (compound_literal_expression type: (type_identifier) value: (initializer_list (number_literal))) alternative: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (field_initializer (field_identifier) (initializer_list (identifier))) (field_initializer (field_identifier) (initializer_list (identifier)))) (for_range_loop type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (for_range_loop type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (number_literal))))))) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier))),"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {	entry = -1;	}	}	for (auto& bucket : vvTried) {",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (type_identifier) declarator: (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (return_statement (false))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (pointer_expression argument: (identifier)))) (comment) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (return_statement (false))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal)))))) consequence: (return_statement (false))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (comment) (condition_clause value: (binary_expression left: (identifier) right: (parenthesized_expression (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))) (identifier) (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence)) (conditional_expression condition: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list)) alternative: (string_literal)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))),"bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened	if (!Assume(info.nRefCount > 0)) return false;			// which tried bucket to move the entry to	int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);		// Will moving this address into tried evict another entry?	if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {	if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {	m_tried_collisions.insert(nId);	}	// Output the entry we'd be colliding with, for debugging purposes	auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);	LogDebug(BCLog::ADDRMAN, ""Collision with %s while attempting to move %s to tried table. Collisions=%d\n"",	colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : """",	addr.ToStringAddrPort(),",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list) (type_qualifier)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (qualified_identifier scope: (namespace_identifier) name: (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (primitive_type))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (parenthesized_expression (binary_expression left: (identifier) right: (identifier)))))) consequence: (return_statement (number_literal))) (for_range_loop (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (declaration (type_qualifier) type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (field_expression argument: (identifier) field: (field_identifier)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list (field_expression argument: (identifier) field: (field_identifier)))))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (return_statement (number_literal))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))) alternative: (else_clause (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal)) right: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (unary_expression argument: (field_expression argument: (identifier) field: (field_identifier)))) consequence: (return_statement (number_literal))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal)) right: (binary_expression left: (cast_expression type: (type_descriptor type: (primitive_type)) value: (field_expression argument: (identifier) field: (field_identifier))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) right: (binary_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (field_expression argument: (identifier) field: (field_identifier)))) right: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))))) consequence: (compound_statement (return_statement (number_literal)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (identifier)))) consequence: (return_statement (number_literal))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))) consequence: (return_statement (number_literal))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (binary_expression left: (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))) right: (identifier)))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))) right: (identifier))) consequence: (compound_statement (return_statement (number_literal)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))))))))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))) consequence: (return_statement (number_literal))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (binary_expression left: (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier))) right: (identifier)))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (update_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))) right: (number_literal))) consequence: (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))))))))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (number_literal))) (MISSING ""}""))))","int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)))) declarator: (reference_declarator (identifier))))) body: (compound_statement (comment) (MISSING ""}""))))",int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref,0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (type_identifier) declarator: (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier))))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (return_statement)) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (pointer_expression argument: (identifier)))) (comment) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))) (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))))),"void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;		// update info	info.m_last_try = time;	if (fCountFailure && info.m_last_count_attempt < m_last_good) {",0
"(translation_unit (function_definition type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (reference_declarator (identifier)))) (type_qualifier)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (initializer_list))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (for_range_loop type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (continue_statement))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (return_statement (initializer_list))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (number_literal))) consequence: (return_statement (initializer_list))) (comment) (MISSING ""}""))))","std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table",0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier)))) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (assignment_expression left: (identifier) right: (identifier))))) (return_statement (identifier))))),"float unrelatedName(float u, float v) {	float w = (u = v);	return w;	}",0
(ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier)))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (comment) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (qualified_identifier scope: (namespace_identifier) name: (identifier))))) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)))) arguments: (argument_list (identifier))))) (comment) (comment) (declaration (storage_class_specifier) (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)))) arguments: (argument_list (binary_expression left: (identifier) right: (identifier)))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal)))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (primitive_type))))) declarator: (identifier)) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (for_range_loop (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (field_expression argument: (identifier) field: (field_identifier)))) right: (identifier))) (declaration (type_qualifier) type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (field_expression argument: (identifier) field: (field_identifier)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (identifier))))) (comment) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (update_expression argument: (identifier))))))) (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (for_range_loop (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (declaration (type_qualifier) type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (field_expression argument: (identifier) field: (field_identifier)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (identifier))))) (comment) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (update_expression argument: (identifier))))))) initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) consequence: (expression_statement (update_expression argument: (identifier)))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))) (expression_statement (binary_expression left: (identifier) right: (identifier)))),"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {	const AddrInfo& info = entry.second;	if (info.fInTried) {	assert(nIds != nTried); // this means nTried was wrong, oh ow	s << info;	nIds++;	}	}	for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {	int nSize = 0;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1)	nSize++;	}	s << nSize;	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[bucket][i] != -1) {	int nIndex = mapUnkIds[vvNew[bucket][i]];	s << nIndex;",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (identifier) (identifier)))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier))) (identifier) (identifier) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier)))))))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (comment) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal)))) consequence: (compound_statement (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (true))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))) alternative: (else_clause (compound_statement (expression_statement (update_expression argument: (identifier)))))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (comment) (comment) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)) (type_descriptor type: (primitive_type))))))))) declarator: (identifier)) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (number_literal)) right: (binary_expression left: (identifier) right: (identifier)))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))))))))) (comment) (comment) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) consequence: (compound_statement (expression_statement (binary_expression left: (identifier) right: (identifier))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (binary_expression left: (identifier) right: (identifier)))))) (MISSING ""}""))))","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)))) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (while_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) body: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (binary_expression left: (binary_expression left: (identifier) right: (number_literal)) right: (binary_expression left: (identifier) right: (number_literal))))) (expression_statement (assignment_expression left: (identifier) right: (number_literal))))) (return_statement (identifier)) (MISSING ""}""))))",int reverse_number(int num) {	int reversed = 0;	while (num != 0) {	reversed = reversed * 10 + num % 10;	num /= 10;	}	return reversed;,0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list)))))) consequence: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) consequence: (compound_statement (expression_statement (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (concatenated_string (string_literal (string_content)) (string_literal (string_content)))))))))) (comment) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))))) consequence: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal)) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (field_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))) (comment) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list)))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal) (string_literal)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (initializer_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) (for_range_loop (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) body: (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal))) consequence: (compound_statement (return_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (call_expression function: (identifier) arguments: (argument_list (identifier))) (comment) (comment) (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (comment)),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.",0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))))) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal)))) (while_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) body: (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) consequence: (compound_statement (return_statement (false)))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (identifier))))) (return_statement (true))))),bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;	}	return true;	},0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (return_statement (false))) (declaration type: (type_identifier) declarator: (identifier)) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (user_defined_literal (number_literal) (literal_suffix)))))) (condition_clause value: (identifier)) (comment) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (binary_expression left: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)) right: (field_expression argument: (identifier) field: (field_identifier))) right: (user_defined_literal (number_literal) (literal_suffix)))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (conditional_expression condition: (identifier) consequence: (user_defined_literal (number_literal) (literal_suffix)) alternative: (user_defined_literal (number_literal) (literal_suffix)))))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)) right: (identifier)))) consequence: (compound_statement (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))) (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))))))))),"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}	",0
(ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) initializer: (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)))) name: (type_identifier))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) condition: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (pointer_expression argument: (identifier)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (false))) (comment) (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))) right: (number_literal))) (compound_statement (expression_statement (assignment_expression left: (identifier) right: (true)))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (compound_statement (comment) (expression_statement (assignment_expression left: (identifier) right: (true)))) (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (comment) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)))) arguments: (argument_list))))) (comment) (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier))) right: (identifier))) (compound_statement (expression_statement (assignment_expression left: (identifier) right: (true)))) (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier))) right: (identifier))) (comment) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier))) right: (user_defined_literal (number_literal) (literal_suffix)))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (comment) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (false) (identifier)))) (expression_statement (assignment_expression left: (identifier) right: (true)))))),"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}",0
"(translation_unit (declaration type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (identifier)))) (MISSING "";"")))","bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)",0
(ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) (comment)),"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {",0
(translation_unit (function_definition type: (type_identifier) declarator: (pointer_declarator declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (pointer_declarator declarator: (identifier)))))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (return_statement (null))) (if_statement condition: (condition_clause value: (identifier)) consequence: (expression_statement (assignment_expression left: (pointer_expression argument: (identifier)) right: (field_expression argument: (parenthesized_expression (pointer_expression argument: (identifier))) field: (field_identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (field_expression argument: (parenthesized_expression (pointer_expression argument: (identifier))) field: (field_identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (return_statement (pointer_expression argument: (field_expression argument: (parenthesized_expression (pointer_expression argument: (identifier))) field: (field_identifier))))) (return_statement (null))))),"AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;	}",0
"(translation_unit (function_definition type: (type_identifier) declarator: (pointer_declarator declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (pointer_declarator declarator: (identifier)))))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (MISSING ""}""))))","AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, nid_type* pnId)	{	AssertLockHeld(cs);	",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (reference_declarator (identifier))))) (comment) (storage_class_specifier) (type_qualifier) type: (placeholder_type_specifier (auto)) (identifier) (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) (string_literal (string_content)) (string_literal (string_content)))),"void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",",0
(translation_unit (ERROR (type_identifier) (access_specifier) (function_definition type: (primitive_type) declarator: (function_declarator declarator: (field_identifier) parameters: (parameter_list)) body: (compound_statement (expression_statement (update_expression argument: (identifier))))) (access_specifier))),class Counter {	public:	void increment() {	count++;	}		private:,0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (MISSING ""}""))))","void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (pointer_declarator declarator: (identifier))))) body: (compound_statement (expression_statement (assignment_expression left: (pointer_expression argument: (identifier)) right: (number_literal))) (return_statement (pointer_expression argument: (identifier))) (MISSING ""}""))))",int modifyPoint(int* points) {	*points += 1;	return *points;,0
(translation_unit (function_definition type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (return_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list)) (identifier))))))),"CScript GetScriptForDestination(const CTxDestination& dest)	{	return std::visit(CScriptVisitor(), dest);	}",0
(translation_unit (comment)),//SE	,0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list) (type_qualifier)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (comment) (MISSING ""}""))))",void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled,0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (identifier) (identifier)))))))) (MISSING ""}""))))","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list)))))) consequence: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) consequence: (compound_statement (expression_statement (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (concatenated_string (string_literal (string_content)) (string_literal (string_content)))))))))) (comment) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))))) consequence: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal)) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (field_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))) (comment) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list)))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal) (string_literal)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (initializer_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) (for_range_loop (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) body: (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal))) consequence: (compound_statement (return_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (comment) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) alternative: (preproc_elif condition: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (parenthesized_expression (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (string_literal (string_content))))) (comment) (comment) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier)))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (call_expression function: (field_expression argument: (call_expression function: (field_expression argument: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) field: (field_identifier)) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list)) field: (field_identifier)))) (declaration type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier)) (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (null))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (null))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (null) (identifier)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) right: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (null) (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (identifier) value: (argument_list (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (identifier))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier))))) (call_expression function: (identifier) arguments: (argument_list)) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier))))))),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);",0
(translation_unit (ERROR type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier))))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (return_statement (qualified_identifier scope: (namespace_identifier) name: (identifier)))) (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))))) (return_statement (call_expression function: (identifier) arguments: (argument_list (comment) (true) (comment) (number_literal) (comment) (identifier) (comment) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))))) (return_statement (call_expression function: (identifier) arguments: (argument_list (comment) (false) (comment) (field_expression argument: (identifier) field: (field_identifier)) (comment) (identifier) (comment) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier)))))))),"std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr)	{	AssertLockHeld(cs);		AddrInfo* addr_info = Find(addr);		if (!addr_info) return std::nullopt;		if(addr_info->fInTried) {	int bucket{addr_info->GetTriedBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/true,	/*multiplicity_in=*/1,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, false, bucket));	} else {	int bucket{addr_info->GetNewBucket(nKey, m_netgroupman)};	return AddressPosition(/*tried_in=*/false,	/*multiplicity_in=*/addr_info->nRefCount,	/*bucket_in=*/bucket,	/*position_in=*/addr_info->GetBucketPosition(nKey, true, bucket));",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (return_statement (false))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (pointer_expression argument: (identifier)))) (comment) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (return_statement (false))) (comment) (MISSING ""}""))))","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else	if (info.fInTried) return false;		// if it is not in new, something bad happened",0
(ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (qualified_identifier scope: (namespace_identifier) name: (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (primitive_type))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (parenthesized_expression (binary_expression left: (identifier) right: (identifier)))))) consequence: (return_statement (number_literal))) (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (declaration (type_qualifier) type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (field_expression argument: (identifier) field: (field_identifier)))) (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list (field_expression argument: (identifier) field: (field_identifier)))))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (return_statement (number_literal))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal)) right: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (unary_expression argument: (field_expression argument: (identifier) field: (field_identifier)))) consequence: (return_statement (number_literal))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list)))))) consequence: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) consequence: (compound_statement (expression_statement (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (concatenated_string (string_literal (string_content)) (string_literal (string_content)))))))))) (comment) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))))) consequence: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal)) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (field_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))) (comment) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list)))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal) (string_literal)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (initializer_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) (for_range_loop (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) body: (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal))) consequence: (compound_statement (return_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (comment) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) alternative: (preproc_elif condition: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (parenthesized_expression (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (string_literal (string_content))))) (comment) (comment) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier)))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (call_expression function: (field_expression argument: (call_expression function: (field_expression argument: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) field: (field_identifier)) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list)) field: (field_identifier)))) (declaration type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier)) (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (null))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (null))) (compound_statement (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (null) (identifier)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) right: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (null) (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (identifier) value: (argument_list (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (identifier))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list)) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier))))) alternative: (preproc_else (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))))))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (identifier))))))),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}",0
(ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (qualified_identifier scope: (namespace_identifier) name: (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (primitive_type))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (parenthesized_expression (binary_expression left: (identifier) right: (identifier)))))) consequence: (return_statement (number_literal))) (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (declaration (type_qualifier) type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (field_expression argument: (identifier) field: (field_identifier)))) (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list (field_expression argument: (identifier) field: (field_identifier)))))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (return_statement (number_literal))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal)) right: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (unary_expression argument: (field_expression argument: (identifier) field: (field_identifier)))) consequence: (return_statement (number_literal)))),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) initializer: (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)))) name: (type_identifier))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) condition: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (pointer_expression argument: (identifier)))))),void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;	,0
(translation_unit (ERROR (type_identifier) (access_specifier) (field_declaration type: (primitive_type) declarator: (field_identifier)) (function_definition type: (primitive_type) declarator: (function_declarator declarator: (field_identifier) parameters: (parameter_list)) body: (compound_statement (comment) (expression_statement (assignment_expression left: (identifier) right: (number_literal))))) (access_specifier))),class myClass {	public:	int publicint;		void changeMut() { // SEF	mutint_ = 5;	}		private:,0
(translation_unit (function_definition declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier)))) (field_initializer_list (field_initializer (field_identifier) (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier) (identifier) (identifier)))))) body: (compound_statement))),"AddrMan::AddrMan(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: m_impl(std::make_unique<AddrManImpl>(netgroupman, deterministic, consistency_check_ratio)) {}",0
(translation_unit (ERROR (type_identifier) (access_specifier) type: (primitive_type) (function_declarator declarator: (field_identifier) parameters: (parameter_list)))),class Counter {	public:	void increment() {,0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))) right: (number_literal))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (unary_expression argument: (field_expression argument: (identifier) field: (field_identifier)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (field_expression argument: (identifier) field: (field_identifier)) (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal))))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (identifier)))))),"void AddrManImpl::Delete(nid_type nId)	{	AssertLockHeld(cs);		assert(mapInfo.count(nId) != 0);	AddrInfo& info = mapInfo[nId];	assert(!info.fInTried);	assert(info.nRefCount == 0);		SwapRandom(info.nRandomPos, vRandom.size() - 1);	m_network_counts[info.GetNetwork()].n_new--;	vRandom.pop_back();	mapAddr.erase(info);	mapInfo.erase(nId);	nNew--;	}",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (return_statement (false))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (pointer_expression argument: (identifier)))) (MISSING ""}""))))","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;	",0
"(translation_unit (function_definition type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (reference_declarator (identifier)))) (type_qualifier)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (initializer_list))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (for_range_loop type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (continue_statement))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (return_statement (initializer_list))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (number_literal))) consequence: (return_statement (initializer_list))) (comment) (comment) (declaration type: (primitive_type) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (false)))) alternative: (else_clause (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (true)))) alternative: (else_clause (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (conditional_expression condition: (identifier) consequence: (identifier) alternative: (identifier))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (while_statement condition: (condition_clause value: (number_literal)) body: (compound_statement (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (comment) (comment) (declaration type: (primitive_type) declarator: (identifier) declarator: (identifier)) (declaration type: (type_identifier) declarator: (identifier)) (for_statement initializer: (assignment_expression left: (identifier) right: (number_literal)) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (binary_expression left: (parenthesized_expression (binary_expression left: (identifier) right: (identifier))) right: (identifier)))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list)))))) consequence: (break_statement))) alternative: (else_clause (compound_statement (break_statement)))))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (continue_statement)) (comment) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (declaration (type_qualifier) type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (initializer_list (field_expression argument: (identifier) field: (field_identifier))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (template_method name: (field_identifier) arguments: (template_argument_list (number_literal)))) arguments: (argument_list)) right: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal)))))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (conditional_expression condition: (identifier) consequence: (string_literal (string_content)) alternative: (string_literal (string_content)))))) (return_statement (initializer_list (identifier) (field_expression argument: (identifier) field: (field_identifier)))))) (comment) (expression_statement (assignment_expression left: (identifier) right: (number_literal))))) (MISSING ""}""))))","std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}		// Otherwise start over with a (likely) different bucket, and increased chance factor.	chance_factor *= 1.2;	}",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list)))))) consequence: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) consequence: (compound_statement (expression_statement (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (concatenated_string (string_literal (string_content)) (string_literal (string_content)))))))))) (comment) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))))) consequence: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal)) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (field_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))) (comment) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (compound_statement (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list)))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal) (string_literal)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (initializer_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) (for_range_loop (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) body: (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal))) consequence: (compound_statement (return_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (comment) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) alternative: (preproc_elif condition: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (parenthesized_expression (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (string_literal (string_content))))) (comment) (comment) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier)))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (call_expression function: (field_expression argument: (call_expression function: (field_expression argument: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) field: (field_identifier)) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list)) field: (field_identifier)))) (declaration type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier)) (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (null))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (null))) (compound_statement (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (null) (identifier)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) right: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (null) (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (identifier) value: (argument_list (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (identifier))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list)) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier))))) alternative: (preproc_else (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))))))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (compound_literal_expression type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) value: (initializer_list)) (pointer_expression argument: (identifier))))) (comment) (comment) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (field_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier))) field: (field_identifier)) arguments: (argument_list (number_literal))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier))))) (comment) (comment) (comment) (comment) (comment) (MISSING ""}""))))","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else	reporter.SetMethod(""addExtraParameter"",	&electron::crash_keys::SetCrashKey);	reporter.SetMethod(""removeExtraParameter"",	&electron::crash_keys::ClearCrashKey);	#endif		process.Set(""crashReporter"", reporter);	}		v8::HandleScope scope(isolate);	node::LoadEnvironment(env, node::StartExecutionCallback{}, &OnNodePreload);		// Potential reasons we get Nothing here may include: the env	// is stopping, or the user hooks process.emit('exit').	exit_code = node::SpinEventLoop(env).FromMaybe(1);		node::ResetStdio();		node::Stop(env, node::StopFlags::kDoNotTerminateIsolate);		node::FreeEnvironment(env);	node::FreeIsolateData(isolate_data);	}		// According to ""src/gin/shell/gin_main.cc"":	//	// gin::IsolateHolder waits for tasks running in ThreadPool in its	// destructor and thus must be destroyed before ThreadPool starts skipping	// CONTINUE_ON_SHUTDOWN tasks.",0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list)) body: (compound_statement (try_statement body: (compound_statement (throw_statement (number_literal))) (catch_clause parameters: (parameter_list) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))))))))),void ThrowCatch()	{	try	{	throw 1;	}	catch (...)	{	int temporary = 0;	}	},0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (reference_declarator (identifier))))) body: (compound_statement (comment) (declaration (storage_class_specifier) (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list (initializer_list (string_literal (string_content)) (string_literal (string_content)) (string_literal (string_content)) (string_literal (string_content)) (string_literal (string_content))))))) (MISSING ""}""))))","void ExitIfContainsDisallowedFlags(const std::vector<std::string>& argv) {	// Options that are unilaterally disallowed.	static constexpr auto disallowed = base::MakeFixedFlatSet<std::string_view>({	""--enable-fips"",	""--force-fips"",	""--openssl-config"",	""--use-bundled-ca"",	""--use-openssl-ca"",	});	",0
"(translation_unit (function_definition type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))))))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (MISSING ""}""))))","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (identifier) (identifier)))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier))) (identifier) (identifier) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier)))))))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (comment) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal)))) consequence: (compound_statement (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (true))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))) alternative: (else_clause (compound_statement (expression_statement (update_expression argument: (identifier)))))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (comment) (comment) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)) (type_descriptor type: (primitive_type))))))))) declarator: (identifier)) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (number_literal)) right: (binary_expression left: (identifier) right: (identifier)))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))))))))) (comment) (comment) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) consequence: (compound_statement (expression_statement (binary_expression left: (identifier) right: (identifier))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (binary_expression left: (identifier) right: (identifier)))))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence))))))) (for_range_loop type: (placeholder_type_specifier (auto)) declarator: (identifier) right: (identifier) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (field_expression argument: (identifier) field: (field_identifier))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (field_expression argument: (identifier) field: (field_identifier))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (continue_statement)) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))) consequence: (continue_statement)) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal)))) consequence: (compound_statement (comment) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (identifier) field: (field_identifier))))) alternative: (else_clause (compound_statement (comment) (comment) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) consequence: (compound_statement (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (identifier) field: (field_identifier))))))))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) initializer: (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) condition: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (condition_clause value: (binary_expression left: (binary_expression left: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) right: (false)) right: (binary_expression left: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) right: (number_literal)))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (update_expression argument: (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (field_expression argument: (identifier) field: (field_identifier))))) (expression_statement (update_expression argument: (identifier))))),"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (comment) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (parenthesized_expression (binary_expression left: (identifier) right: (identifier))) right: (identifier))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) consequence: (compound_statement (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (expression_statement (update_expression argument: (field_expression argument: (identifier) field: (field_identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))) consequence: (break_statement)))))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (comment) (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))))),"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (MISSING ""}""))))",bool CBanDB::Read(banmap_t& banSet)	{,0
"(translation_unit (function_definition type: (type_identifier) declarator: (function_declarator declarator: (operator_name) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier)))) (type_qualifier)) body: (compound_statement (MISSING ""}""))))",CScript operator()(const CNoDestination& dest) const	{,0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (identifier) (identifier)))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier))) (identifier) (identifier) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier)))))))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (comment) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) (declaration type: (type_identifier) declarator: (identifier)))),"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;",0
"(translation_unit (function_definition type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal))) consequence: (return_statement (initializer_list))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)))) name: (type_identifier))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (MISSING ""}""))))","std::pair<CAddress, NodeSeconds> AddrManImpl::SelectTriedCollision_()	{	AssertLockHeld(cs);		if (m_tried_collisions.size() == 0) return {};		std::set<nid_type>::iterator it = m_tried_collisions.begin();	",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)))) body: (compound_statement (MISSING ""}""))))",double celsius_to_fahrenheit(double celsius) {,0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type))))) declarator: (reference_declarator (identifier))))) body: (compound_statement (MISSING ""}""))))",double average(const std::vector<int>& numbers) {,0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)))) body: (compound_statement (MISSING ""}""))))",int factorial(int n) {,0
"(translation_unit (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) (MISSING "";"")))",std::optional<AddressPosition> AddrMan::FindAddressEntry(const CAddress& addr),0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (identifier)))) body: (compound_statement (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (char_literal (character)))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) consequence: (return_statement (false))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (lambda_expression captures: (lambda_capture_specifier (lambda_default_capture)) declarator: (abstract_function_declarator parameters: (parameter_list (parameter_declaration type: (placeholder_type_specifier (auto)) declarator: (identifier)))) body: (compound_statement (return_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (identifier)))))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (number_literal) (identifier))))) (return_statement (binary_expression left: (binary_expression left: (binary_expression left: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier))) right: (number_literal)) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (identifier)))) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (identifier) (identifier))))) (MISSING ""}""))))","bool IsUrlArg(const base::CommandLine::StringViewType arg) {	const auto scheme_end = arg.find(':');	if (scheme_end == base::CommandLine::StringViewType::npos)	return false;		const auto& c_locale = std::locale::classic();	const auto isspace = [&](auto ch) { return std::isspace(ch, c_locale); };	const auto scheme = arg.substr(0U, scheme_end);	return std::size(scheme) > 1U && std::isalpha(scheme.front(), c_locale) &&	std::ranges::none_of(scheme, isspace);",0
"(translation_unit (function_definition type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))))) body: (compound_statement (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (identifier) value: (identifier))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (MISSING ""}""))))","std::string reverse_string(const std::string& str) {	std::string reversed = str;	std::reverse(reversed.begin(), reversed.end());",0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))))) body: (compound_statement))),void ClearCrashKeyStub(const std::string& key) {},0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal)))) (condition_clause value: (binary_expression left: (identifier) right: (identifier))) (condition_clause value: (binary_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))))),bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {,0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (identifier) (identifier)))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier))) (identifier) (identifier) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier)))))))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (comment) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal)))) consequence: (compound_statement (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (true))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))) alternative: (else_clause (compound_statement (expression_statement (update_expression argument: (identifier)))))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (comment) (comment) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)) (type_descriptor type: (primitive_type))))))))) declarator: (identifier)) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (number_literal)) right: (binary_expression left: (identifier) right: (identifier)))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))))))))) (comment) (comment) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) consequence: (compound_statement (expression_statement (binary_expression left: (identifier) right: (identifier))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (binary_expression left: (identifier) right: (identifier)))))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence))))))) (for_range_loop type: (placeholder_type_specifier (auto)) declarator: (identifier) right: (identifier) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (field_expression argument: (identifier) field: (field_identifier))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (field_expression argument: (identifier) field: (field_identifier))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (continue_statement)) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))) consequence: (continue_statement)) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal)))) consequence: (compound_statement (comment) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (identifier) field: (field_identifier))))) alternative: (else_clause (compound_statement (comment) (comment) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) consequence: (compound_statement (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (identifier) field: (field_identifier))))))))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (for_statement initializer: (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) condition: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) body: (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) right: (false)) right: (binary_expression left: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) right: (number_literal)))) consequence: (compound_statement (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (update_expression argument: (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (field_expression argument: (identifier) field: (field_identifier))))) (expression_statement (update_expression argument: (identifier)))) alternative: (else_clause (compound_statement (expression_statement (update_expression argument: (identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (number_literal))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence)) (identifier) (identifier)))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (identifier) arguments: (argument_list))))) (MISSING ""}""))))","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {	const auto itCopy = it++;	Delete(itCopy->first);	++nLostUnk;	} else {	++it;	}	}	if (nLost + nLostUnk > 0) {	LogDebug(BCLog::ADDRMAN, ""addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n"", nLostUnk, nLost);	}		const int check_code{CheckAddrman()};",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))))) (call_expression function: (identifier) arguments: (argument_list (identifier))) (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list))))))) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment)),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (MISSING ""}""))))","bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{",0
"(translation_unit (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)) (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (identifier)) (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))))) body: (compound_statement (MISSING ""}""))))","std::unordered_map<int, std::string> database;		void update_record(int id, const std::string& new_value) {",0
"(translation_unit (function_definition type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))))))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type))))) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (identifier))) (number_literal) (number_literal))))) (MISSING ""}""))))","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (identifier)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) initializer: (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)))) name: (type_identifier))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) condition: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) update: (update_expression argument: (identifier)) (expression_statement (assignment_expression left: (identifier) right: (conditional_expression condition: (call_expression function: (identifier) arguments: (argument_list (pointer_expression argument: (identifier)) (identifier) (identifier))) consequence: (number_literal) alternative: (number_literal)))))),"bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (condition_clause value: (binary_expression left: (identifier) right: (identifier))) (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (identifier) (identifier)))))))),"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (comment) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (parenthesized_expression (binary_expression left: (identifier) right: (identifier))) right: (identifier))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) consequence: (compound_statement (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (expression_statement (update_expression argument: (field_expression argument: (identifier) field: (field_identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))) consequence: (break_statement)))))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (MISSING ""}""))))","void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	",0
"(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier)))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (ERROR) (expression_statement (binary_expression left: (pointer_expression argument: (pointer_expression argument: (pointer_expression argument: (identifier)))) (ERROR (identifier)) right: (pointer_expression argument: (identifier))) (MISSING "";"")) (declaration type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (ERROR (UNEXPECTED '@')) (parameter_declaration type: (type_identifier) (ERROR (UNEXPECTED '`')) declarator: (identifier)) (ERROR (UNEXPECTED '`')))) (MISSING "";"")) (ERROR (pointer_expression argument: (pointer_expression argument: (field_expression argument: (identifier) (ERROR (identifier) (identifier) (identifier) (identifier)) field: (field_identifier)))) (identifier)) (declaration type: (type_identifier) (ERROR (identifier) (identifier) (identifier) (identifier) (identifier)) declarator: (init_declarator declarator: (pointer_declarator (ERROR (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) declarator: (pointer_declarator declarator: (pointer_declarator (ERROR (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) declarator: (identifier)))) value: (number_literal)) (MISSING "";"")) (declaration type: (type_identifier) (ERROR (identifier) (identifier)) declarator: (init_declarator declarator: (identifier) (ERROR (number_literal)) value: (binary_expression left: (identifier) right: (assignment_expression left: (identifier) (ERROR (identifier) (identifier) (identifier) (number_literal) (identifier) (identifier) (identifier) (identifier) (identifier)) right: (binary_expression left: (number_literal) right: (binary_expression left: (identifier) (ERROR (identifier) (identifier) (identifier)) right: (identifier)))))) (ERROR (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) (ERROR (identifier) (identifier) (identifier) (number_literal) (identifier) (identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (parenthesized_declarator (identifier) (MISSING "")""))) value: (number_literal)) declarator: (init_declarator declarator: (identifier) (ERROR (number_literal) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) value: (identifier)) (ERROR (identifier) (identifier)) declarator: (init_declarator declarator: (pointer_declarator (ERROR (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) declarator: (pointer_declarator declarator: (pointer_declarator (ERROR (identifier) (identifier) (identifier) (identifier) (number_literal) (identifier) (identifier) (identifier)) declarator: (identifier)))) value: (number_literal)) (MISSING "";"")) (declaration type: (type_identifier) (ERROR (identifier) (identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (parenthesized_declarator (identifier) (MISSING "")""))) value: (number_literal)) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (number_literal) (ERROR) (ERROR (identifier) (identifier) (identifier) (identifier)) right: (binary_expression left: (unary_expression argument: (identifier)) (ERROR (identifier) (identifier) (identifier)) right: (assignment_expression left: (identifier) right: (number_literal))))) (MISSING "";"")) (ERROR type: (type_identifier) (ERROR (identifier) (identifier) (identifier) (identifier) (identifier)) (ERROR (identifier)) (ERROR (identifier)) (ERROR (identifier)) (pointer_declarator (ERROR (identifier)) declarator: (identifier)) (string_content)) (expression_statement (binary_expression left: (pointer_expression argument: (pointer_expression (ERROR (identifier)) argument: (new_expression type: (type_identifier) arguments: (argument_list (identifier) (ERROR (identifier) (identifier)))))) right: (pointer_expression argument: (identifier))) (MISSING "";"")) (declaration type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier) (ERROR (identifier)) declarator: (identifier)))) (MISSING "";"")) (expression_statement (binary_expression left: (pointer_expression argument: (pointer_expression (ERROR (identifier) (identifier)) argument: (new_expression type: (type_identifier)))) (ERROR) right: (pointer_expression argument: (identifier))) (MISSING "";"")) type: (type_identifier) (ERROR (identifier)) (ERROR (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) (ERROR (identifier) (identifier)) (ERROR (number_literal)) (pointer_declarator (ERROR (number_literal) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) declarator: (identifier)) (identifier)))","void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (comment) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (parenthesized_expression (binary_expression left: (identifier) right: (identifier))) right: (identifier))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) consequence: (compound_statement (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (expression_statement (update_expression argument: (field_expression argument: (identifier) field: (field_identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))) consequence: (break_statement)))))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (comment) (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))) right: (number_literal))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (comment) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (false))) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal)))))) (comment)),"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.",0
"(translation_unit (function_definition type: (type_identifier) declarator: (pointer_declarator declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (pointer_declarator declarator: (identifier)))))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (MISSING ""}""))))","AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (return_statement (false))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (pointer_expression argument: (identifier)))) (comment) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))) (comment) (comment) (comment) (MISSING ""}""))))","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info	info.m_last_success = time;	info.m_last_try = time;	info.nAttempts = 0;	// nTime is not updated here, to avoid leaking information about	// currently-connected peers.		// if it is already in the tried set, don't do anything else",0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)))) body: (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (return_statement (false))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (number_literal))) consequence: (return_statement (false))))) (return_statement (true))))),bool is_prime(int n) {	if (n <= 1) return false;	for (int i = 2; i * i <= n; ++i) {	if (n % i == 0) return false;	}	return true;	},0
"(translation_unit (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (argument_list)) (MISSING "";"")))",void ThrowCatch(),0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))) (optional_parameter_declaration type: (primitive_type) declarator: (identifier) default_value: (true)))) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier)))) (comment) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (call_expression function: (identifier) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (throw_statement (compound_literal_expression type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) value: (initializer_list (string_literal (string_content))))))) (MISSING ""}""))))","void DeserializeDB(Stream& stream, Data&& data, bool fCheckSum = true)	{	HashVerifier verifier{stream};	// de-serialize file header (network specific magic number) and ..	MessageStartChars pchMsgTmp;	verifier >> pchMsgTmp;	// ... verify the network matches ours	if (pchMsgTmp != Params().MessageStart()) {	throw std::runtime_error{""Invalid network magic number""};	}",0
(translation_unit (ERROR (type_identifier) (access_specifier) (function_definition type: (primitive_type) declarator: (function_declarator declarator: (field_identifier) parameters: (parameter_list)) body: (compound_statement (expression_statement (update_expression argument: (identifier))))))),class Counter {	public:	void increment() {	count++;	},0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (comment) (MISSING ""}""))))","bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename",0
"(translation_unit (declaration type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (identifier)))) (MISSING "";"")))","void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)",0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type))))) declarator: (reference_declarator (identifier))))) body: (compound_statement (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (number_literal))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (for_range_loop type: (primitive_type) declarator: (identifier) right: (identifier) body: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (identifier))))) (return_statement (binary_expression left: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)))) arguments: (argument_list (identifier))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))))),double average(const std::vector<int>& numbers) {	if (numbers.empty()) return 0.0;	int sum = 0;	for (int num : numbers) {	sum += num;	}	return static_cast<double>(sum) / numbers.size();	},0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (MISSING ""}""))))","void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds time)	{	AssertLockHeld(cs);",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (identifier))) (type_qualifier)) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (comment) (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (user_defined_literal (number_literal) (literal_suffix)))))),double AddrInfo::GetChance(NodeSeconds now) const	{	double fChance = 1.0;		// deprioritize very recent attempts away	if (now - m_last_try < 10min) {,0
"(translation_unit (comment) (function_definition type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))))) body: (compound_statement (MISSING ""}""))))",// 8. Opens a file and reads its content	std::string read_file_content(const std::string& filename) {,0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list))) (MISSING ""}""))))",void AddrManImpl::ResolveCollisions()	{	LOCK(cs);	Check();,0
"(translation_unit (function_definition type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (MISSING ""}""))))",CScript GetScriptForDestination(const CTxDestination& dest)	{,0
"(translation_unit (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (reference_declarator (identifier)))) (type_qualifier)) (MISSING "";"")))","std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list)))))) consequence: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) consequence: (compound_statement (expression_statement (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (concatenated_string (string_literal (string_content)) (string_literal (string_content)))))))))) (comment) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))))) consequence: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal)) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (field_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))) (comment) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list)))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal) (string_literal)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (initializer_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) (for_range_loop (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) body: (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal))) consequence: (compound_statement (return_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (comment) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) alternative: (preproc_elif condition: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (parenthesized_expression (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (string_literal (string_content))))) (comment) (comment) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier)))))),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);",0
(translation_unit (ERROR type: (type_identifier) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (condition_clause value: (identifier)) (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (identifier)))) right: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (identifier)))))) consequence: (compound_statement (return_statement (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))) (condition_clause value: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (identifier)))) right: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (identifier)))))))),"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_NEW_BUCKET_COUNT)) {",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (sized_type_specifier type: (primitive_type)) declarator: (identifier)) (parameter_declaration type: (sized_type_specifier type: (primitive_type)) declarator: (identifier))) (type_qualifier)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (return_statement)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (MISSING ""}""))))","void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)	return;		assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());		nid_type nId1 = vRandom[nRndPos1];	nid_type nId2 = vRandom[nRndPos2];		const auto it_1{mapInfo.find(nId1)};	const auto it_2{mapInfo.find(nId2)};	assert(it_1 != mapInfo.end());	assert(it_2 != mapInfo.end());	",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (identifier))) (type_qualifier)) body: (compound_statement (MISSING ""}""))))",bool AddrInfo::IsTerrible(NodeSeconds now) const	{,0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list) (type_qualifier)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (qualified_identifier scope: (namespace_identifier) name: (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (primitive_type))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (parenthesized_expression (binary_expression left: (identifier) right: (identifier)))))) consequence: (return_statement (number_literal))) (for_range_loop (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (declaration (type_qualifier) type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (field_expression argument: (identifier) field: (field_identifier)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list (field_expression argument: (identifier) field: (field_identifier)))))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (return_statement (number_literal))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))) alternative: (else_clause (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal)) right: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (unary_expression argument: (field_expression argument: (identifier) field: (field_identifier)))) consequence: (return_statement (number_literal))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal)) right: (binary_expression left: (cast_expression type: (type_descriptor type: (primitive_type)) value: (field_expression argument: (identifier) field: (field_identifier))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) right: (binary_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (field_expression argument: (identifier) field: (field_identifier)))) right: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))))) consequence: (compound_statement (return_statement (number_literal)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (identifier)))) consequence: (return_statement (number_literal))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))) consequence: (return_statement (number_literal))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (binary_expression left: (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))) right: (identifier)))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))) right: (identifier))) consequence: (compound_statement (return_statement (number_literal)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))))))))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))) consequence: (return_statement (number_literal))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (binary_expression left: (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier))) right: (identifier)))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (binary_expression left: (update_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier)))))) right: (number_literal))) consequence: (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))))))))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (number_literal))) (comment) (MISSING ""}""))))","int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)	return -14;	if (info.m_last_try < NodeSeconds{0s}) {	return -6;	}	if (info.m_last_success < NodeSeconds{0s}) {	return -8;	}	}		if (setTried.size() != (size_t)nTried)	return -9;	if (mapNew.size() != (size_t)nNew)	return -10;		for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvTried[n][i] != -1) {	if (!setTried.count(vvTried[n][i]))	return -11;	const auto it{mapInfo.find(vvTried[n][i])};	if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {	return -17;	}	if (it->second.GetBucketPosition(nKey, false, n) != i) {	return -18;	}	setTried.erase(vvTried[n][i]);	}	}	}		for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {	for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {	if (vvNew[n][i] != -1) {	if (!mapNew.count(vvNew[n][i]))	return -12;	const auto it{mapInfo.find(vvNew[n][i])};	if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {	return -19;	}	if (--mapNew[vvNew[n][i]] == 0)	mapNew.erase(vvNew[n][i]);	}	}	}		if (setTried.size())	return -13;	if (mapNew.size())	return -15;	if (nKey.IsNull())	return -16;		// It's possible that m_network_counts may have all-zero entries that local_counts",0
"(translation_unit (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) (MISSING "";"")))",std::optional<AddressPosition> AddrManImpl::FindAddressEntry_(const CAddress& addr),0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier))))) (condition_clause value: (identifier)) (case_statement value: (qualified_identifier scope: (namespace_identifier) name: (identifier)) (compound_statement (declaration type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (abstract_array_declarator size: (number_literal)))))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier)))))) alternative: (else_clause (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier)))))))) (return_statement (false)))) (case_statement value: (qualified_identifier scope: (namespace_identifier) name: (identifier)) (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))))))))) (return_statement (true)))) (case_statement value: (qualified_identifier scope: (namespace_identifier) name: (identifier)) (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))))))))) (return_statement (true)))) (qualified_identifier scope: (namespace_identifier) name: (identifier)) (declaration type: (type_identifier) declarator: (identifier)))),"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;",0
"(translation_unit (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))))))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) (MISSING "";"")))","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)",0
(translation_unit (ERROR type: (type_identifier) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (condition_clause value: (identifier)) (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (identifier)))) right: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (identifier)))))) consequence: (compound_statement (return_statement (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))))))),"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {	if (Assume(position < ADDRMAN_BUCKET_SIZE) && Assume(bucket < ADDRMAN_TRIED_BUCKET_COUNT)) {	return vvTried[bucket][position];	}	} else {",0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier) (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list)))))),"void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	LOCK(cs);	Check();	Attempt_(addr, fCountFailure, time);	Check();	}",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (identifier) (identifier)))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier))) (identifier) (identifier) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier)))))))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (comment) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal)))) consequence: (compound_statement (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (true))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))) alternative: (else_clause (compound_statement (expression_statement (update_expression argument: (identifier)))))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (comment) (comment) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)) (type_descriptor type: (primitive_type))))))))) declarator: (identifier)) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (number_literal)) right: (binary_expression left: (identifier) right: (identifier)))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))))))))) (comment) (comment) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) consequence: (compound_statement (expression_statement (binary_expression left: (identifier) right: (identifier))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (binary_expression left: (identifier) right: (identifier)))))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence))))))) (for_range_loop type: (placeholder_type_specifier (auto)) declarator: (identifier) right: (identifier) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (field_expression argument: (identifier) field: (field_identifier))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (field_expression argument: (identifier) field: (field_identifier))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (continue_statement)) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))) consequence: (continue_statement)) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal)))) consequence: (compound_statement (comment) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (identifier) field: (field_identifier))))) alternative: (else_clause (compound_statement (comment) (comment) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) consequence: (compound_statement (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (identifier) field: (field_identifier))))))))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) initializer: (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) condition: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (condition_clause value: (binary_expression left: (binary_expression left: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) right: (false)) right: (binary_expression left: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) right: (number_literal)))))),"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}	}	}		// If the bucket count and asmap checksum haven't changed, then attempt	// to restore the entries to the buckets/positions they were in before	// serialization.	uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};	uint256 serialized_asmap_checksum;	if (format >= Format::V2_ASMAP) {	s >> serialized_asmap_checksum;	}	const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&	serialized_asmap_checksum == supplied_asmap_checksum};		if (!restore_bucketing) {	LogDebug(BCLog::ADDRMAN, ""Bucketing method was updated, re-bucketing addrman entries from disk\n"");	}		for (auto bucket_entry : bucket_entries) {	int bucket{bucket_entry.first};	const int entry_index{bucket_entry.second};	AddrInfo& info = mapInfo[entry_index];		// Don't store the entry in the new bucket if it's not a valid address for our addrman	if (!info.IsValid()) continue;		// The entry shouldn't appear in more than	// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip	// this bucket_entry.	if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;		int bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {	// Bucketing has not changed, using existing bucket positions for the new table	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	} else {	// In case the new table data cannot be used (bucket count wrong or new asmap),	// try to give them a reference based on their primary source address.	bucket = info.GetNewBucket(nKey, m_netgroupman);	bucket_position = info.GetBucketPosition(nKey, true, bucket);	if (vvNew[bucket][bucket_position] == -1) {	vvNew[bucket][bucket_position] = entry_index;	++info.nRefCount;	}	}	}		// Prune new entries with refcount 0 (as a result of collisions or invalid address).	int nLostUnk = 0;	for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {	if (it->second.fInTried == false && it->second.nRefCount == 0) {",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal)))) (condition_clause value: (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) consequence: (compound_statement (return_statement (false)))) (expression_statement (update_expression argument: (identifier))))),bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;,0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (identifier)))) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (for_statement initializer: (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)))) name: (type_identifier))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) condition: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) update: (update_expression argument: (identifier)) body: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (conditional_expression condition: (call_expression function: (identifier) arguments: (argument_list (pointer_expression argument: (identifier)) (identifier) (identifier))) consequence: (number_literal) alternative: (number_literal)))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence)) (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (identifier) (identifier)))))) (MISSING ""}""))))","bool AddrManImpl::Add_(const std::vector<CAddress>& vAddr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	int added{0};	for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++) {	added += AddSingle(*it, source, time_penalty) ? 1 : 0;	}	if (added > 0) {	LogDebug(BCLog::ADDRMAN, ""Added %i addresses (of %i) from %s: %i tried, %i new\n"", added, vAddr.size(), source.ToStringAddr(), nTried, nNew);	}",0
"(translation_unit (function_definition type: (type_identifier) declarator: (pointer_declarator declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (pointer_declarator declarator: (identifier)))))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (return_statement (null))) (if_statement condition: (condition_clause value: (identifier)) consequence: (expression_statement (assignment_expression left: (pointer_expression argument: (identifier)) right: (field_expression argument: (parenthesized_expression (pointer_expression argument: (identifier))) field: (field_identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (field_expression argument: (parenthesized_expression (pointer_expression argument: (identifier))) field: (field_identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (return_statement (pointer_expression argument: (field_expression argument: (parenthesized_expression (pointer_expression argument: (identifier))) field: (field_identifier))))) (return_statement (null)) (MISSING ""}""))))","AddrInfo* AddrManImpl::Find(const CService& addr, nid_type* pnId)	{	AssertLockHeld(cs);		const auto it = mapAddr.find(addr);	if (it == mapAddr.end())	return nullptr;	if (pnId)	*pnId = (*it).second;	const auto it2 = mapInfo.find((*it).second);	if (it2 != mapInfo.end())	return &(*it2).second;	return nullptr;",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier)))) (type_qualifier)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (comment) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (qualified_identifier scope: (namespace_identifier) name: (identifier))))) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)))) arguments: (argument_list (identifier))))) (comment) (comment) (declaration (storage_class_specifier) (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) (MISSING ""}""))))","void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;",0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (for_statement initializer: (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)))) name: (type_identifier))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) condition: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (pointer_expression argument: (identifier)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (false))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))) right: (number_literal))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (true)))) alternative: (else_clause (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (comment) (expression_statement (assignment_expression left: (identifier) right: (true)))) alternative: (else_clause (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) consequence: (compound_statement (comment) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)))) arguments: (argument_list))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier))) right: (identifier))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (true)))) alternative: (else_clause (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier))) right: (identifier))) consequence: (compound_statement (comment) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier))) right: (user_defined_literal (number_literal) (literal_suffix)))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (comment) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (false) (identifier)))) (expression_statement (assignment_expression left: (identifier) right: (true)))))) alternative: (else_clause (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier))) right: (identifier))) consequence: (compound_statement (comment) (comment) (comment) (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (false) (identifier)))) (expression_statement (assignment_expression left: (identifier) right: (true)))))))))) alternative: (else_clause (compound_statement (comment) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (false) (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)))) arguments: (argument_list))))) (expression_statement (assignment_expression left: (identifier) right: (true))))))))))) (if_statement condition: (condition_clause value: (identifier)) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (update_expression argument: (identifier)))))) alternative: (else_clause (compound_statement (expression_statement (update_expression argument: (identifier))))))))))),"void AddrManImpl::ResolveCollisions_()	{	AssertLockHeld(cs);		for (std::set<nid_type>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {	nid_type id_new = *it;		bool erase_collision = false;		// If id_new not found in mapInfo remove it from m_tried_collisions	if (mapInfo.count(id_new) != 1) {	erase_collision = true;	} else {	AddrInfo& info_new = mapInfo[id_new];		// Which tried bucket to move the entry to.	int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);	int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);	if (!info_new.IsValid()) { // id_new may no longer map to a valid address	erase_collision = true;	} else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty		// Get the to-be-evicted address that is being tested	nid_type id_old = vvTried[tried_bucket][tried_bucket_pos];	AddrInfo& info_old = mapInfo[id_old];		const auto current_time{Now<NodeSeconds>()};		// Has successfully connected in last X hours	if (current_time - info_old.m_last_success < ADDRMAN_REPLACEMENT) {	erase_collision = true;	} else if (current_time - info_old.m_last_try < ADDRMAN_REPLACEMENT) { // attempted to connect and failed in last X hours		// Give address at least 60 seconds to successfully connect	if (current_time - info_old.m_last_try > 60s) {	LogDebug(BCLog::ADDRMAN, ""Replacing %s with %s in tried table\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());		// Replaces an existing address already in the tried table with the new address	Good_(info_new, false, current_time);	erase_collision = true;	}	} else if (current_time - info_new.m_last_success > ADDRMAN_TEST_WINDOW) {	// If the collision hasn't resolved in some reasonable amount of time,	// just evict the old entry -- we must not be able to	// connect to it for some reason.	LogDebug(BCLog::ADDRMAN, ""Unable to test; replacing %s with %s in tried table anyway\n"", info_old.ToStringAddrPort(), info_new.ToStringAddrPort());	Good_(info_new, false, current_time);	erase_collision = true;	}	} else { // Collision is not actually a collision anymore	Good_(info_new, false, Now<NodeSeconds>());	erase_collision = true;	}	}		if (erase_collision) {	m_tried_collisions.erase(it++);	} else {	it++;	}	}	}",0
(translation_unit (ERROR type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (reference_declarator (identifier)))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (initializer_list))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (for_range_loop type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (continue_statement))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (return_statement (initializer_list))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (number_literal))) consequence: (return_statement (initializer_list))) (comment) (comment) (declaration type: (primitive_type) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (false)))) alternative: (else_clause (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (true)))) alternative: (else_clause (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (conditional_expression condition: (identifier) consequence: (identifier) alternative: (identifier))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (condition_clause value: (number_literal)) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (comment) (comment) (declaration type: (primitive_type) declarator: (identifier) declarator: (identifier)) (declaration type: (type_identifier) declarator: (identifier)) (for_statement initializer: (assignment_expression left: (identifier) right: (number_literal)) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (binary_expression left: (parenthesized_expression (binary_expression left: (identifier) right: (identifier))) right: (identifier)))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list)))))) consequence: (break_statement))) alternative: (else_clause (compound_statement (break_statement)))))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (continue_statement)) (comment) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (declaration (type_qualifier) type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (initializer_list (field_expression argument: (identifier) field: (field_identifier))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (template_method name: (field_identifier) arguments: (template_argument_list (number_literal)))) arguments: (argument_list)) right: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal)))))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (conditional_expression condition: (identifier) consequence: (string_literal (string_content)) alternative: (string_literal (string_content)))))) (return_statement (initializer_list (identifier) (field_expression argument: (identifier) field: (field_identifier)))))))),"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}	}	}		// If the bucket is entirely empty, start over with a (likely) different one.	if (i == ADDRMAN_BUCKET_SIZE) continue;		// Find the entry to return.	const auto it_found{mapInfo.find(node_id)};	assert(it_found != mapInfo.end());	const AddrInfo& info{it_found->second};		// With probability GetChance() * chance_factor, return the entry.	if (insecure_rand.randbits<30>() < chance_factor * info.GetChance() * (1 << 30)) {	LogDebug(BCLog::ADDRMAN, ""Selected %s from %s\n"", info.ToStringAddrPort(), search_tried ? ""tried"" : ""new"");	return {info, info.m_last_try};	}",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list)))))) consequence: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) consequence: (compound_statement (expression_statement (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (concatenated_string (string_literal (string_content)) (string_literal (string_content)))))))))) (comment) (MISSING ""}""))))","int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)))) body: (compound_statement (declaration (storage_class_specifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)) (type_descriptor type: (primitive_type))))) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (return_statement (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (return_statement (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (MISSING ""}""))))","int fibonacci(int n) {	static std::unordered_map<int, int> cache;		if (n <= 1) return n;	if (cache.find(n) != cache.end()) return cache[n];	",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier))))) (condition_clause value: (identifier)) (case_statement value: (qualified_identifier scope: (namespace_identifier) name: (identifier)) (compound_statement (declaration type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (abstract_array_declarator size: (number_literal)))))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier)))))) alternative: (else_clause (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier)))))))) (return_statement (false)))) (case_statement value: (qualified_identifier scope: (namespace_identifier) name: (identifier)) (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))))))))) (return_statement (true)))))),"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}",0
(ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (identifier) (identifier)))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier))) (identifier) (identifier) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier)))))))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (identifier))) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (binary_expression left: (identifier) right: (identifier))))))))) (comment) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal)))) consequence: (compound_statement (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (true))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))) alternative: (else_clause (compound_statement (expression_statement (update_expression argument: (identifier)))))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (comment) (comment) (comment) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)) (type_descriptor type: (primitive_type))))))))) declarator: (identifier)) initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (expression_statement (binary_expression left: (identifier) right: (identifier))) initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (number_literal)))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (number_literal)) right: (binary_expression left: (identifier) right: (identifier)))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))))),"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}		s >> nKey;	s >> nNew;	s >> nTried;	int nUBuckets = 0;	s >> nUBuckets;	if (format >= Format::V1_DETERMINISTIC) {	nUBuckets ^= (1 << 30);	}		if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"",	nNew,	ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {	throw std::ios_base::failure(	strprintf(""Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"",	nTried,	ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));	}		// Deserialize entries from the new table.	for (int n = 0; n < nNew; n++) {	AddrInfo& info = mapInfo[n];	s >> info;	mapAddr[info] = n;	info.nRandomPos = vRandom.size();	vRandom.push_back(n);	m_network_counts[info.GetNetwork()].n_new++;	}	nIdCount = nNew;		// Deserialize entries from the tried table.	int nLost = 0;	for (int n = 0; n < nTried; n++) {	AddrInfo info;	s >> info;	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);	if (info.IsValid()	&& vvTried[nKBucket][nKBucketPos] == -1) {	info.nRandomPos = vRandom.size();	info.fInTried = true;	vRandom.push_back(nIdCount);	mapInfo[nIdCount] = info;	mapAddr[info] = nIdCount;	vvTried[nKBucket][nKBucketPos] = nIdCount;	nIdCount++;	m_network_counts[info.GetNetwork()].n_tried++;	} else {	nLost++;	}	}	nTried -= nLost;		// Store positions in the new table buckets to apply later (if possible).	// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,	// so we store all bucket-entry_index pairs to iterate through later.	std::vector<std::pair<int, int>> bucket_entries;		for (int bucket = 0; bucket < nUBuckets; ++bucket) {	int num_entries{0};	s >> num_entries;	for (int n = 0; n < num_entries; ++n) {	int entry_index{0};	s >> entry_index;	if (entry_index >= 0 && entry_index < nNew) {	bucket_entries.emplace_back(bucket, entry_index);	}",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (MISSING ""}""))))","bool AddrManImpl::Good(const CService& addr, NodeSeconds time)	{	LOCK(cs);",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier)))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (comment) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (qualified_identifier scope: (namespace_identifier) name: (identifier))))) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)))) arguments: (argument_list (identifier))))) (comment) (comment) (declaration (storage_class_specifier) (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)))) arguments: (argument_list (binary_expression left: (identifier) right: (identifier)))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal)))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (primitive_type))))) declarator: (identifier)) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (for_range_loop (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (field_expression argument: (identifier) field: (field_identifier)))) right: (identifier))) (declaration (type_qualifier) type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (field_expression argument: (identifier) field: (field_identifier)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (identifier))))) (comment) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (update_expression argument: (identifier))))))) (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier))),"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;	}	}	nIds = 0;	for (const auto& entry : mapInfo) {",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier))))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (return_statement)) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (pointer_expression argument: (identifier)))) (MISSING ""}""))))","void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)	{	AssertLockHeld(cs);		AddrInfo* pinfo = Find(addr);		// if not found, bail out	if (!pinfo)	return;		AddrInfo& info = *pinfo;	",0
"(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier)))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (ERROR) (expression_statement (binary_expression left: (pointer_expression argument: (pointer_expression argument: (pointer_expression argument: (identifier)))) (ERROR (identifier)) right: (pointer_expression argument: (identifier))) (MISSING "";"")) (declaration type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (ERROR (UNEXPECTED '@')) (parameter_declaration type: (type_identifier) (ERROR (UNEXPECTED '`')) declarator: (identifier)) (ERROR (UNEXPECTED '`')))) (MISSING "";"")) (ERROR (pointer_expression argument: (pointer_expression argument: (field_expression argument: (identifier) (ERROR (identifier) (identifier) (identifier) (identifier)) field: (field_identifier)))) (identifier)) (declaration type: (type_identifier) (ERROR (identifier) (identifier) (identifier) (identifier) (identifier)) declarator: (init_declarator declarator: (pointer_declarator (ERROR (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) declarator: (pointer_declarator declarator: (pointer_declarator (ERROR (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) declarator: (identifier)))) value: (number_literal)) (MISSING "";"")) (declaration type: (type_identifier) (ERROR (identifier) (identifier)) declarator: (init_declarator declarator: (identifier) (ERROR (number_literal)) value: (binary_expression left: (identifier) right: (assignment_expression left: (identifier) (ERROR (identifier) (identifier) (identifier) (number_literal) (identifier) (identifier) (identifier) (identifier) (identifier)) right: (binary_expression left: (number_literal) right: (binary_expression left: (identifier) (ERROR (identifier) (identifier) (identifier)) right: (identifier)))))) (ERROR (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) (ERROR (identifier) (identifier) (identifier) (number_literal) (identifier) (identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (parenthesized_declarator (identifier) (MISSING "")""))) value: (number_literal)) declarator: (init_declarator declarator: (identifier) (ERROR (number_literal) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) value: (identifier)) (ERROR (identifier) (identifier)) declarator: (init_declarator declarator: (pointer_declarator (ERROR (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) declarator: (pointer_declarator declarator: (pointer_declarator (ERROR (identifier) (identifier) (identifier) (identifier) (number_literal) (identifier) (identifier) (identifier)) declarator: (identifier)))) value: (number_literal)) (MISSING "";"")) (declaration type: (type_identifier) (ERROR (identifier) (identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (parenthesized_declarator (identifier) (MISSING "")""))) value: (number_literal)) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (number_literal) (ERROR) (ERROR (identifier) (identifier) (identifier) (identifier)) right: (binary_expression left: (unary_expression argument: (identifier)) (ERROR (identifier) (identifier) (identifier)) right: (assignment_expression left: (identifier) right: (number_literal))))) (MISSING "";"")) (ERROR type: (type_identifier) (ERROR (identifier) (identifier) (identifier) (identifier) (identifier)) (ERROR (identifier)) (ERROR (identifier)) (ERROR (identifier)) (pointer_declarator (ERROR (identifier)) declarator: (identifier)) (string_content)) (expression_statement (binary_expression left: (pointer_expression argument: (pointer_expression (ERROR (identifier)) argument: (new_expression type: (type_identifier) arguments: (argument_list (identifier) (ERROR (identifier) (identifier)))))) right: (pointer_expression argument: (identifier))) (MISSING "";"")) (declaration type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier) (ERROR (identifier)) declarator: (identifier)))) (MISSING "";"")) (expression_statement (binary_expression left: (pointer_expression argument: (pointer_expression (ERROR (identifier) (identifier)) argument: (new_expression type: (type_identifier)))) (ERROR) right: (pointer_expression argument: (identifier))) (MISSING "";"")) type: (type_identifier) (ERROR (identifier)) (ERROR (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) (pointer_declarator declarator: (identifier)) (identifier)))","void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum",0
(translation_unit (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)) (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (identifier))),"std::unordered_map<int, std::string> database;	",0
(translation_unit (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (false)))),bool is_initialized = false;	,0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) (comment) (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier)))) (expression_statement (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (call_expression function: (identifier) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list))) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content) (escape_sequence)) (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (return_statement (false)))),"bool SerializeDB(Stream& stream, const Data& data)	{	// Write and commit header, data	try {	HashedSourceWriter hashwriter{stream};	hashwriter << Params().MessageStart() << data;	stream << hashwriter.GetHash();	} catch (const std::exception& e) {	LogError(""%s: Serialize or I/O error - %s\n"", __func__, e.what());	return false;",0
"(translation_unit (comment) (comment) (comment) (preproc_include path: (string_literal (string_content))) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list)) body: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (MISSING ""}""))))","// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list)))))) consequence: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) consequence: (compound_statement (expression_statement (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (concatenated_string (string_literal (string_content)) (string_literal (string_content)))))))))) (comment) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))))) consequence: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal)) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (field_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))) (comment) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list)))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal) (string_literal)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier))))))) (comment)),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (MISSING ""}""))))","void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	LOCK(cs);",0
(translation_unit (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)) (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (identifier))),"std::unordered_map<int, std::string> database;",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type))))) declarator: (identifier))) (type_qualifier)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list))) (return_statement (identifier)) (MISSING ""}""))))","size_t AddrManImpl::Size(std::optional<Network> net, std::optional<bool> in_new) const	{	LOCK(cs);	Check();	auto ret = Size_(net, in_new);	Check();	return ret;",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list)))))) consequence: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) consequence: (compound_statement (expression_statement (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (concatenated_string (string_literal (string_content)) (string_literal (string_content)))))))))) (comment) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))))) consequence: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal)) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (field_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))) (comment) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list)))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal) (string_literal)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (initializer_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) (for_range_loop (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) body: (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal))) consequence: (compound_statement (return_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (comment) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) alternative: (preproc_elif condition: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (parenthesized_expression (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (string_literal (string_content))))) (comment) (comment) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier)))))),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);	",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (pointer_declarator declarator: (identifier))))) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (false))) (for_range_loop (type_qualifier) type: (primitive_type) declarator: (pointer_declarator declarator: (identifier)) right: (identifier) body: (compound_statement (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (assignment_expression left: (identifier) right: (true))))))) (return_statement (identifier)) (MISSING ""}""))))",bool UnsetHijackableEnvs(base::Environment* env) {	bool has = false;	for (const char* name : kHijackableEnvs) {	if (env->HasVar(name)) {	env->UnSetVar(name);	has = true;	}	}	return has;,0
"(translation_unit (function_definition type: (type_identifier) declarator: (function_declarator declarator: (operator_name) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier)))) (type_qualifier)) body: (compound_statement (MISSING ""}""))))",CScript operator()(const PubKeyDestination& dest) const	{,0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (comment) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))))) (for_statement initializer: (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) body: (compound_statement (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (parenthesized_expression (binary_expression left: (identifier) right: (identifier))) right: (identifier))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) consequence: (compound_statement (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (expression_statement (update_expression argument: (field_expression argument: (identifier) field: (field_identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))) consequence: (break_statement)))))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (false) (identifier))))) (comment) (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))) right: (number_literal))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (comment) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (false))) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))))) (comment) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (identifier) (identifier) (identifier) (identifier)))))),"void AddrManImpl::MakeTried(AddrInfo& info, nid_type nId)	{	AssertLockHeld(cs);		// remove the entry from all new buckets	const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};	for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {	const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};	const int pos{info.GetBucketPosition(nKey, true, bucket)};	if (vvNew[bucket][pos] == nId) {	vvNew[bucket][pos] = -1;	info.nRefCount--;	if (info.nRefCount == 0) break;	}	}	nNew--;	m_network_counts[info.GetNetwork()].n_new--;		assert(info.nRefCount == 0);		// which tried bucket to move the entry to	int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);	int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);		// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).	if (vvTried[nKBucket][nKBucketPos] != -1) {	// find an item to evict	nid_type nIdEvict = vvTried[nKBucket][nKBucketPos];	assert(mapInfo.count(nIdEvict) == 1);	AddrInfo& infoOld = mapInfo[nIdEvict];		// Remove the to-be-evicted item from the tried set.	infoOld.fInTried = false;	vvTried[nKBucket][nKBucketPos] = -1;	nTried--;	m_network_counts[infoOld.GetNetwork()].n_tried--;		// find which new bucket it belongs to	int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);	int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);	ClearNew(nUBucket, nUBucketPos);	assert(vvNew[nUBucket][nUBucketPos] == -1);		// Enter it into the new set again.	infoOld.nRefCount = 1;	vvNew[nUBucket][nUBucketPos] = nIdEvict;	nNew++;	m_network_counts[infoOld.GetNetwork()].n_new++;	LogDebug(BCLog::ADDRMAN, ""Moved %s from tried[%i][%i] to new[%i][%i] to make space\n"",	infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPos);",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list) (type_qualifier)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (return_statement)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))) right: (number_literal))) consequence: (return_statement)) (MISSING ""}""))))",void AddrManImpl::Check() const	{	AssertLockHeld(cs);		// Run consistency checks 1 in m_consistency_check_ratio times if enabled	if (m_consistency_check_ratio == 0) return;	if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;	,0
(translation_unit (ERROR type: (type_identifier) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (condition_clause value: (identifier)))),"nid_type AddrManImpl::GetEntry(bool use_tried, size_t bucket, size_t position) const	{	AssertLockHeld(cs);		if (use_tried) {",0
"(translation_unit (function_definition type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))))))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type))))) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (identifier))) (number_literal) (number_literal))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (string_literal (string_content)))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier) (identifier) (comment) (identifier)))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (string_literal (string_content)))))) (MISSING ""}""))))","util::Result<std::unique_ptr<AddrMan>> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args)	{	auto check_addrman = std::clamp<int32_t>(args.GetIntArg(""-checkaddrman"", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);	bool deterministic = HasTestOption(args, ""addrman""); // use a deterministic addrman only for tests		auto addrman{std::make_unique<AddrMan>(netgroupman, deterministic, /*consistency_check_ratio=*/check_addrman)};		const auto start{SteadyClock::now()};	const auto path_addr{args.GetDataDirNet() / ""peers.dat""};",0
(translation_unit (ERROR type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (reference_declarator (identifier)))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (initializer_list))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (for_range_loop type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (continue_statement))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (return_statement (initializer_list))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (number_literal))) consequence: (return_statement (initializer_list))) (comment) (comment) (declaration type: (primitive_type) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (false)))) alternative: (else_clause (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (true)))) alternative: (else_clause (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (conditional_expression condition: (identifier) consequence: (identifier) alternative: (identifier))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (condition_clause value: (number_literal)) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (comment)),"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,",0
(translation_unit (ERROR (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier)))))),"AddrMan::AddrMan(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (sized_type_specifier type: (primitive_type)) declarator: (identifier)) (parameter_declaration type: (sized_type_specifier type: (primitive_type)) declarator: (identifier))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (condition_clause value: (binary_expression left: (identifier) right: (identifier))))),"void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const	{	AssertLockHeld(cs);		if (nRndPos1 == nRndPos2)",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (identifier) (identifier)))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier))) (identifier) (identifier) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier)))))))))) (MISSING ""}""))))","void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));	}	",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))))) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal)))) (while_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) body: (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) consequence: (compound_statement (return_statement (false)))) (expression_statement (update_expression argument: (identifier))) (expression_statement (update_expression argument: (identifier))))) (return_statement (true)) (MISSING ""}""))))",bool is_palindrome(const std::string& str) {	int left = 0;	int right = str.length() - 1;	while (left < right) {	if (str[left] != str[right]) {	return false;	}	++left;	--right;	}	return true;,0
"(translation_unit (function_definition type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (parameter_declaration (type_qualifier) type: (primitive_type) declarator: (identifier))) (type_qualifier)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier) (identifier) (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list))) (return_statement (identifier)) (MISSING ""}""))))","std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network, const bool filtered) const	{	LOCK(cs);	Check();	auto addresses = GetAddr_(max_addresses, max_pct, network, filtered);	Check();	return addresses;",0
"(translation_unit (comment) (comment) (comment) (preproc_include path: (string_literal (string_content))) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list)) body: (compound_statement (comment) (comment) (MISSING ""}""))))","// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these",0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (pointer_declarator declarator: (identifier))))) body: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (identifier)))))),void AutoUpdater::SetDelegate(Delegate* delegate) {	delegate_ = delegate;	},0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (operator_name) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier)))) (type_qualifier)) body: (compound_statement (return_statement (true))))),bool operator()(const WitnessV1Taproot& dest) const { return true; },0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier) (identifier))))))),"void AddrMan::Attempt(const CService& addr, bool fCountFailure, NodeSeconds time)	{	m_impl->Attempt(addr, fCountFailure, time);	}",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)))) (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) (return_statement (number_literal)))),int factorial(int n) {	if (n == 0) {	return 1;,0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list)) (compound_statement (throw_statement (number_literal))) (parameter_list))),void ThrowCatch()	{	try	{	throw 1;	}	catch (...),0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list)))))) consequence: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) consequence: (compound_statement (expression_statement (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (concatenated_string (string_literal (string_content)) (string_literal (string_content)))))))))) (comment) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))))) consequence: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal)) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (field_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))) (comment) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list)))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal) (string_literal)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (initializer_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) (for_range_loop (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) body: (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal))) consequence: (compound_statement (return_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (comment) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) alternative: (preproc_elif condition: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (parenthesized_expression (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (string_literal (string_content))))) (comment) (comment) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier))))) (comment)),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.",0
(translation_unit (ERROR (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier)))) (field_initializer_list (field_initializer (field_identifier) (initializer_list (identifier))) (field_initializer (field_identifier) (initializer_list (conditional_expression condition: (identifier) consequence: (compound_literal_expression type: (type_identifier) value: (initializer_list (number_literal))) alternative: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (field_initializer (field_identifier) (initializer_list (identifier))) (field_initializer (field_identifier) (initializer_list (identifier)))) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier))),"AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)	: insecure_rand{deterministic}	, nKey{deterministic ? uint256{1} : insecure_rand.rand256()}	, m_consistency_check_ratio{consistency_check_ratio}	, m_netgroupman{netgroupman}	{	for (auto& bucket : vvNew) {	for (auto& entry : bucket) {",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (return_statement (false))) (declaration type: (type_identifier) declarator: (identifier)) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (user_defined_literal (number_literal) (literal_suffix)))))) (if_statement condition: (condition_clause value: (identifier)) consequence: (compound_statement (comment) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (binary_expression left: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)) right: (field_expression argument: (identifier) field: (field_identifier))) right: (user_defined_literal (number_literal) (literal_suffix)))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (conditional_expression condition: (identifier) consequence: (user_defined_literal (number_literal) (literal_suffix)) alternative: (user_defined_literal (number_literal) (literal_suffix)))))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)) right: (identifier)))) consequence: (compound_statement (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))) (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))))))) (comment) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (field_expression argument: (identifier) field: (field_identifier))))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (field_expression argument: (identifier) field: (field_identifier)))) consequence: (compound_statement (return_statement (false)))) (comment) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (return_statement (false))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))) consequence: (return_statement (false))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))) consequence: (compound_statement (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (number_literal) right: (field_expression argument: (identifier) field: (field_identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))) right: (number_literal))) consequence: (return_statement (false)))))) alternative: (else_clause (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier) (pointer_expression argument: (identifier)))))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))) (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier))))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (true) (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal)))) (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (identifier))))),"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);	}		// add services	pinfo->nServices = ServiceFlags(pinfo->nServices | addr.nServices);		// do not update if no new information is present	if (addr.nTime <= pinfo->nTime) {	return false;	}		// do not update if the entry was already in the ""tried"" table	if (pinfo->fInTried)	return false;		// do not update if the max reference count is reached	if (pinfo->nRefCount == ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return false;		// stochastic test: previous nRefCount == N: 2^N times harder to increase it	if (pinfo->nRefCount > 0) {	const int nFactor{1 << pinfo->nRefCount};	if (insecure_rand.randrange(nFactor) != 0) return false;	}	} else {	pinfo = Create(addr, source, &nId);	pinfo->nTime = std::max(NodeSeconds{0s}, pinfo->nTime - time_penalty);	}		int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);	int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);	bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;	if (vvNew[nUBucket][nUBucketPos] != nId) {",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list)))))) consequence: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) consequence: (compound_statement (expression_statement (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (concatenated_string (string_literal (string_content)) (string_literal (string_content)))))))))) (comment) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))))) consequence: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal)) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (field_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))) (comment) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list)))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal) (string_literal)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (comment)),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (return_statement (false))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (pointer_expression argument: (identifier)))) (comment) (MISSING ""}""))))","bool AddrManImpl::Good_(const CService& addr, bool test_before_evict, NodeSeconds time)	{	AssertLockHeld(cs);		nid_type nId;		m_last_good = time;		AddrInfo* pinfo = Find(addr, &nId);		// if not found, bail out	if (!pinfo) return false;		AddrInfo& info = *pinfo;		// update info",0
(ERROR type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (reference_declarator (identifier)))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (initializer_list))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (for_range_loop type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (continue_statement))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (return_statement (initializer_list))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (number_literal))) consequence: (return_statement (initializer_list))) (comment) (comment) (declaration type: (primitive_type) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (false)))) alternative: (else_clause (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (true)))) alternative: (else_clause (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (conditional_expression condition: (identifier) consequence: (identifier) alternative: (identifier))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (condition_clause value: (number_literal)) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (comment) (comment) (declaration type: (primitive_type) declarator: (identifier) declarator: (identifier)) (declaration type: (type_identifier) declarator: (identifier)) initializer: (assignment_expression left: (identifier) right: (number_literal)) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) (expression_statement (assignment_expression left: (identifier) right: (binary_expression left: (parenthesized_expression (binary_expression left: (identifier) right: (identifier))) right: (identifier)))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier) (identifier))))) (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list)))))) consequence: (break_statement))),"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;",0
"(translation_unit (declaration type: (type_identifier) declarator: (function_declarator declarator: (operator_name) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier)))) (type_qualifier)) (MISSING "";"")))",CScript operator()(const ScriptHash& scriptID) const,0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (return_statement (false))) (declaration type: (type_identifier) declarator: (identifier)) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (user_defined_literal (number_literal) (literal_suffix)))))) (condition_clause value: (identifier)) (comment) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (binary_expression left: (binary_expression left: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)) right: (field_expression argument: (identifier) field: (field_identifier))) right: (user_defined_literal (number_literal) (literal_suffix)))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (conditional_expression condition: (identifier) consequence: (user_defined_literal (number_literal) (literal_suffix)) alternative: (user_defined_literal (number_literal) (literal_suffix)))))) (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)) right: (identifier)))) (expression_statement (assignment_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (compound_literal_expression type: (type_identifier) value: (initializer_list (user_defined_literal (number_literal) (literal_suffix)))) (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))))))),"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {	time_penalty = 0s;	}		if (pinfo) {	// periodically update nTime	const bool currently_online{NodeClock::now() - addr.nTime < 24h};	const auto update_interval{currently_online ? 1h : 24h};	if (pinfo->nTime < addr.nTime - update_interval - time_penalty) {	pinfo->nTime = std::max(NodeSeconds{0s}, addr.nTime - time_penalty);",0
"(translation_unit (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (array_declarator declarator: (identifier) size: (number_literal)) value: (initializer_list (number_literal)))) (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier)))) body: (compound_statement (MISSING ""}""))))","// 6. Modifies a global array	int global_array[10] = {0};	void update_global_array(int index, int value) {",0
(ERROR type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (reference_declarator (identifier)))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (initializer_list))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (for_range_loop type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (continue_statement))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (return_statement (initializer_list))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (number_literal))) consequence: (return_statement (initializer_list))) (comment) (comment) (declaration type: (primitive_type) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (false)))) alternative: (else_clause (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (true)))) alternative: (else_clause (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (conditional_expression condition: (identifier) consequence: (identifier) alternative: (identifier))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (condition_clause value: (number_literal)) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (comment) (comment) (declaration type: (primitive_type) declarator: (identifier) declarator: (identifier)) (declaration type: (type_identifier) declarator: (identifier)) initializer: (assignment_expression left: (identifier) right: (number_literal)) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) (expression_statement (assignment_expression left: (identifier) right: (binary_expression left: (parenthesized_expression (binary_expression left: (identifier) right: (identifier))) right: (identifier)))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier) (identifier))))) (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (call_expression function: (field_expression argument: (field_expression argument: (identifier) field: (field_identifier)) field: (field_identifier)) arguments: (argument_list)))))) consequence: (break_statement))) alternative: (else_clause (compound_statement (break_statement))))),"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {	if (!networks.empty()) {	const auto it{mapInfo.find(node_id)};	if (Assume(it != mapInfo.end()) && networks.contains(it->second.GetNetwork())) break;	} else {	break;	}",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (comment) (if_statement condition: (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) consequence: (compound_statement (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))))) (expression_statement (update_expression argument: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (identifier)) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (identifier) (identifier)))) (if_statement condition: (condition_clause value: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))))))) (MISSING ""}""))))","void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;	vvNew[nUBucket][nUBucketPos] = -1;	LogDebug(BCLog::ADDRMAN, ""Removed %s from new[%i][%i]\n"", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPos);	if (infoDelete.nRefCount == 0) {	Delete(nIdDelete);	}	}",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration type: (primitive_type) declarator: (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (comment) (condition_clause value: (binary_expression left: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))) right: (number_literal))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (subscript_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) indices: (subscript_argument_list (identifier))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal))))) (expression_statement (update_expression argument: (field_expression argument: (identifier) field: (field_identifier)))))),"void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)	{	AssertLockHeld(cs);		// if there is an entry in the specified bucket, delete it.	if (vvNew[nUBucket][nUBucketPos] != -1) {	nid_type nIdDelete = vvNew[nUBucket][nUBucketPos];	AddrInfo& infoDelete = mapInfo[nIdDelete];	assert(infoDelete.nRefCount > 0);	infoDelete.nRefCount--;",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (template_type name: (type_identifier) arguments: (template_argument_list (number_literal)))))) arguments: (argument_list (identifier))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (parenthesized_expression (conditional_expression condition: (binary_expression left: (identifier) right: (qualified_identifier scope: (namespace_identifier) name: (identifier))) consequence: (qualified_identifier scope: (namespace_identifier) name: (identifier)) alternative: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (identifier)))) (declaration type: (primitive_type) declarator: (identifier)) (expression_statement (binary_expression left: (identifier) right: (identifier))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (identifier))) consequence: (compound_statement (throw_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (identifier) (identifier)))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (identifier)))) (condition_clause value: (binary_expression left: (identifier) right: (identifier))) (throw_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (concatenated_string (string_literal (string_content)) (string_literal (string_content))) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier))) (identifier) (identifier) (compound_literal_expression type: (primitive_type) value: (initializer_list (identifier)))))))))),"void AddrManImpl::Unserialize(Stream& s_)	{	LOCK(cs);		assert(vRandom.empty());		Format format;	s_ >> Using<CustomUintFormatter<1>>(format);		const auto ser_params = (format >= Format::V3_BIP155 ? CAddress::V2_DISK : CAddress::V1_DISK);	ParamsStream s{s_, ser_params};		uint8_t compat;	s >> compat;	if (compat < INCOMPATIBILITY_BASE) {	throw std::ios_base::failure(strprintf(	""Corrupted addrman database: The compat value (%u) ""	""is lower than the expected minimum value %u."",	compat, INCOMPATIBILITY_BASE));	}	const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;	if (lowest_compatible > FILE_FORMAT) {	throw InvalidAddrManVersionError(strprintf(	""Unsupported format of addrman database: %u. It is compatible with formats >=%u, ""	""but the maximum supported by this version of %s is %u."",	uint8_t{format}, lowest_compatible, CLIENT_NAME, uint8_t{FILE_FORMAT}));",0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier)))) (type_qualifier)) body: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (parenthesized_expression (binary_expression left: (binary_expression left: (compound_literal_expression type: (type_identifier) value: (initializer_list)) right: (identifier)) right: (call_expression function: (identifier) arguments: (argument_list)))) field: (field_identifier)) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (parenthesized_expression (binary_expression left: (binary_expression left: (binary_expression left: (compound_literal_expression type: (type_identifier) value: (initializer_list)) right: (identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (pointer_expression argument: (this))))) right: (parenthesized_expression (binary_expression left: (identifier) right: (identifier))))) field: (field_identifier)) arguments: (argument_list)))) (return_statement (binary_expression left: (identifier) right: (identifier)))))),"int AddrInfo::GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const	{	uint64_t hash1 = (HashWriter{} << nKey << GetKey()).GetCheapHash();	uint64_t hash2 = (HashWriter{} << nKey << netgroupman.GetGroup(*this) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();	return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;	}",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (qualified_identifier scope: (namespace_identifier) name: (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (primitive_type))))) declarator: (identifier)) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (cast_expression type: (type_descriptor type: (primitive_type)) value: (parenthesized_expression (binary_expression left: (identifier) right: (identifier)))))) consequence: (return_statement (number_literal))) (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (declaration (type_qualifier) type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (field_expression argument: (identifier) field: (field_identifier)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (compound_statement (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list (field_expression argument: (identifier) field: (field_identifier)))))) consequence: (compound_statement (return_statement (number_literal)))) (if_statement condition: (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) consequence: (return_statement (number_literal))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))) alternative: (else_clause (compound_statement (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal)) right: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))) consequence: (return_statement (number_literal))) (if_statement condition: (condition_clause value: (unary_expression argument: (field_expression argument: (identifier) field: (field_identifier)))) consequence: (return_statement (number_literal))) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (identifier))) right: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (update_expression argument: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) field: (field_identifier))))))) (declaration (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) right: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (identifier)))) consequence: (compound_statement (return_statement (number_literal)))) (condition_clause value: (binary_expression left: (binary_expression left: (binary_expression left: (field_expression argument: (identifier) field: (field_identifier)) right: (number_literal)) right: (binary_expression left: (cast_expression type: (type_descriptor type: (primitive_type)) value: (field_expression argument: (identifier) field: (field_identifier))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) right: (binary_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (field_expression argument: (identifier) field: (field_identifier)))) right: (identifier)))))),"int AddrManImpl::CheckAddrman() const	{	AssertLockHeld(cs);		LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(	strprintf(""new %i, tried %i, total %u"", nNew, nTried, vRandom.size()), BCLog::ADDRMAN);		std::unordered_set<nid_type> setTried;	std::unordered_map<nid_type, int> mapNew;	std::unordered_map<Network, NewTriedCount> local_counts;		if (vRandom.size() != (size_t)(nTried + nNew))	return -7;		for (const auto& entry : mapInfo) {	nid_type n = entry.first;	const AddrInfo& info = entry.second;	if (info.fInTried) {	if (!TicksSinceEpoch<std::chrono::seconds>(info.m_last_success)) {	return -1;	}	if (info.nRefCount)	return -2;	setTried.insert(n);	local_counts[info.GetNetwork()].n_tried++;	} else {	if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)	return -3;	if (!info.nRefCount)	return -4;	mapNew[n] = info.nRefCount;	local_counts[info.GetNetwork()].n_new++;	}	const auto it{mapAddr.find(info)};	if (it == mapAddr.end() || it->second != n) {	return -5;	}	if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)",0
(translation_unit (comment) (comment) (comment) (preproc_include path: (string_literal (string_content)))),"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""	",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier))))) (condition_clause value: (identifier)) (case_statement value: (qualified_identifier scope: (namespace_identifier) name: (identifier)) (compound_statement (declaration type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (abstract_array_declarator size: (number_literal)))))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier)))))) alternative: (else_clause (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier)))))))) (return_statement (false)))) (case_statement value: (qualified_identifier scope: (namespace_identifier) name: (identifier)) (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))))))))) (return_statement (true)))) (case_statement value: (qualified_identifier scope: (namespace_identifier) name: (identifier)) (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))))))))) (return_statement (true)))) (case_statement value: (qualified_identifier scope: (namespace_identifier) name: (identifier)) (compound_statement (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (expression_statement (assignment_expression left: (identifier) right: (identifier))) (return_statement (true)))) (qualified_identifier scope: (namespace_identifier) name: (identifier)) (declaration type: (type_identifier) declarator: (identifier)) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))))),"bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)	{	std::vector<valtype> vSolutions;	TxoutType whichType = Solver(scriptPubKey, vSolutions);		switch (whichType) {	case TxoutType::PUBKEY: {	CPubKey pubKey(vSolutions[0]);	if (!pubKey.IsValid()) {	addressRet = CNoDestination(scriptPubKey);	} else {	addressRet = PubKeyDestination(pubKey);	}	return false;	}	case TxoutType::PUBKEYHASH: {	addressRet = PKHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::SCRIPTHASH: {	addressRet = ScriptHash(uint160(vSolutions[0]));	return true;	}	case TxoutType::WITNESS_V0_KEYHASH: {	WitnessV0KeyHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());	addressRet = hash;	return true;	}	case TxoutType::WITNESS_V0_SCRIPTHASH: {	WitnessV0ScriptHash hash;	std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list))))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (if_statement condition: (condition_clause value: (unary_expression argument: (identifier))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (identifier) arguments: (argument_list)))))) consequence: (compound_statement (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (if_statement condition: (condition_clause value: (call_expression function: (identifier) arguments: (argument_list (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) consequence: (compound_statement (expression_statement (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (concatenated_string (string_literal (string_content)) (string_literal (string_content)))))))))) (comment) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (identifier) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier)))))) consequence: (compound_statement (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal)) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (pointer_expression argument: (identifier))))))) (expression_statement (call_expression function: (field_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list (identifier) (identifier)))) (comment) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)))))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list)))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) arguments: (argument_list (identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal) (string_literal)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (initializer_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) (for_range_loop (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier)) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) body: (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (string_literal (string_content) (escape_sequence)) (call_expression function: (field_expression argument: (subscript_expression argument: (identifier) indices: (subscript_argument_list (number_literal))) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (if_statement condition: (condition_clause value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (number_literal))) consequence: (compound_statement (return_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (preproc_if condition: (call_expression function: (identifier) arguments: (argument_list (identifier))) (comment) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (comment) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))))) alternative: (preproc_elif condition: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (parenthesized_expression (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier))) right: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (false) (string_literal (string_content))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (pointer_expression argument: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list)))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list))))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (comment) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (string_literal (string_content))))) (comment) (comment) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier)))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (call_expression function: (field_expression argument: (call_expression function: (field_expression argument: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) field: (field_identifier)) arguments: (argument_list)) field: (field_identifier)) arguments: (argument_list)) field: (field_identifier)))) (declaration type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier)) (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (null))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (null))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (type_identifier))))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (null) (identifier)))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) right: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)))))) arguments: (argument_list (identifier))))))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (null) (identifier)))) (expression_statement (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (identifier) value: (argument_list (identifier) (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (qualified_identifier scope: (namespace_identifier) name: (identifier)))))) (comment) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (identifier))) arguments: (argument_list (identifier))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier))))) (call_expression function: (identifier) arguments: (argument_list)) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier))))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (string_literal (string_content)) (pointer_expression argument: (identifier))))))),"int NodeMain() {	DCHECK(base::CommandLine::InitializedForCurrentProcess());		auto os_env = base::Environment::Create();	bool node_options_enabled = electron::fuses::IsNodeOptionsEnabled();	if (!node_options_enabled) {	os_env->UnSetVar(""NODE_OPTIONS"");	os_env->UnSetVar(""NODE_EXTRA_CA_CERTS"");	}		#if BUILDFLAG(IS_MAC)	if (!ProcessSignatureIsSameWithCurrentApp(getppid())) {	// On macOS, it is forbidden to run sandboxed app with custom arguments	// from another app, i.e. args are discarded in following call:	//   exec(""Sandboxed.app"", [""--custom-args-will-be-discarded""])	// However it is possible to bypass the restriction by abusing the node mode	// of Electron apps:	//   exec(""Electron.app"", {env: {ELECTRON_RUN_AS_NODE: ""1"",	//                               NODE_OPTIONS: ""--require 'bad.js'""}})	// To prevent Electron apps from being used to work around macOS security	// restrictions, when the parent process is not part of the app bundle, all	// environment variables that may be used to inject scripts are removed.	if (UnsetHijackableEnvs(os_env.get())) {	LOG(ERROR) << ""Node.js environment variables are disabled because this ""	""process is invoked by other apps."";	}	}	#endif  // BUILDFLAG(IS_MAC)		#if BUILDFLAG(IS_WIN)	v8_crashpad_support::SetUp();	#endif		#if BUILDFLAG(IS_LINUX)	std::string fd_string, pid_string;	if (os_env->GetVar(""CRASHDUMP_SIGNAL_FD"", &fd_string) &&	os_env->GetVar(""CRASHPAD_HANDLER_PID"", &pid_string)) {	int fd = -1, pid = -1;	DCHECK(base::StringToInt(fd_string, &fd));	DCHECK(base::StringToInt(pid_string, &pid));	base::GlobalDescriptors::GetInstance()->Set(kCrashDumpSignal, fd);	// Following API is unsafe in multi-threaded scenario, but at this point	// we are still single threaded.	os_env->UnSetVar(""CRASHDUMP_SIGNAL_FD"");	os_env->UnSetVar(""CRASHPAD_HANDLER_PID"");	}	#endif		int exit_code = 1;	{	// Feed gin::PerIsolateData with a task runner.	uv_loop_t* loop = uv_default_loop();	auto uv_task_runner = base::MakeRefCounted<UvTaskRunner>(loop);	base::SingleThreadTaskRunner::CurrentDefaultHandle handle(uv_task_runner);		// Initialize feature list.	auto feature_list = std::make_unique<base::FeatureList>();	feature_list->InitFromCommandLine("""", """");	base::FeatureList::SetInstance(std::move(feature_list));		// Explicitly register electron's builtin bindings.	NodeBindings::RegisterBuiltinBindings();		// Parse Node.js cli flags and strip out disallowed options.	const std::vector<std::string> args = ElectronCommandLine::AsUtf8();	ExitIfContainsDisallowedFlags(args);		std::unique_ptr<node::InitializationResult> result =	node::InitializeOncePerProcess(	args,	{node::ProcessInitializationFlags::kNoInitializeV8,	node::ProcessInitializationFlags::kNoInitializeNodeV8Platform});		for (const std::string& error : result->errors())	fprintf(stderr, ""%s: %s\n"", args[0].c_str(), error.c_str());		if (result->early_return() != 0) {	return result->exit_code();	}		#if BUILDFLAG(IS_LINUX)	// On Linux, initialize crashpad after Nodejs init phase so that	// crash and termination signal handlers can be set by the crashpad client.	if (!pid_string.empty()) {	auto* command_line = base::CommandLine::ForCurrentProcess();	command_line->AppendSwitchASCII(	crash_reporter::switches::kCrashpadHandlerPid, pid_string);	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	// Ensure the flags and env variable does not propagate to userland.	command_line->RemoveSwitch(crash_reporter::switches::kCrashpadHandlerPid);	}	#elif BUILDFLAG(IS_WIN) || (BUILDFLAG(IS_MAC) && !IS_MAS_BUILD())	ElectronCrashReporterClient::Create();	crash_reporter::InitializeCrashpad(false, ""node"");	crash_keys::SetCrashKeysFromCommandLine(	*base::CommandLine::ForCurrentProcess());	crash_keys::SetPlatformCrashKey();	#endif		gin::V8Initializer::LoadV8Snapshot(	gin::V8SnapshotFileType::kWithAdditionalContext);		// V8 requires a task scheduler.	base::ThreadPoolInstance::CreateAndStartWithDefaultParams(""Electron"");		// Allow Node.js to track the amount of time the event loop has spent	// idle in the kernel’s event provider .	uv_loop_configure(loop, UV_METRICS_IDLE_TIME);		// Initialize gin::IsolateHolder.	bool setup_wasm_streaming =	node::per_process::cli_options->get_per_isolate_options()	->get_per_env_options()	->experimental_fetch;	JavascriptEnvironment gin_env(loop, setup_wasm_streaming);		v8::Isolate* isolate = gin_env.isolate();		v8::Isolate::Scope isolate_scope(isolate);	v8::Locker locker(isolate);	node::Environment* env = nullptr;	node::IsolateData* isolate_data = nullptr;	{	v8::HandleScope scope(isolate);		isolate_data = node::CreateIsolateData(isolate, loop, gin_env.platform());	CHECK_NE(nullptr, isolate_data);		uint64_t env_flags = node::EnvironmentFlags::kDefaultFlags |	node::EnvironmentFlags::kHideConsoleWindows;	env = node::CreateEnvironment(	isolate_data, isolate->GetCurrentContext(), result->args(),	result->exec_args(),	static_cast<node::EnvironmentFlags::Flags>(env_flags));	CHECK_NE(nullptr, env);		node::SetIsolateUpForNode(isolate);		gin_helper::Dictionary process(isolate, env->process_object());	process.SetMethod(""crash"", &ElectronBindings::Crash);		// Setup process.crashReporter in child node processes	auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);	reporter.SetMethod(""getParameters"", &GetParameters);	#if IS_MAS_BUILD()	reporter.SetMethod(""addExtraParameter"", &SetCrashKeyStub);	reporter.SetMethod(""removeExtraParameter"", &ClearCrashKeyStub);	#else",0
(ERROR type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (reference_declarator (identifier)))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (return_statement (initializer_list))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (identifier))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (expression_statement (assignment_expression left: (identifier) right: (number_literal))) (for_range_loop type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) body: (compound_statement (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (continue_statement))) (declaration type: (placeholder_type_specifier (auto)) declarator: (init_declarator declarator: (identifier) value: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))) (expression_statement (assignment_expression left: (identifier) right: (field_expression argument: (identifier) field: (field_identifier)))))))) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (return_statement (initializer_list))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (identifier) right: (identifier)) right: (number_literal))) consequence: (return_statement (initializer_list))) (comment) (comment) (declaration type: (primitive_type) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (binary_expression left: (identifier) right: (number_literal)))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (false)))) alternative: (else_clause (if_statement condition: (condition_clause value: (binary_expression left: (identifier) right: (number_literal))) consequence: (compound_statement (expression_statement (assignment_expression left: (identifier) right: (true)))) alternative: (else_clause (compound_statement (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))))))))) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (conditional_expression condition: (identifier) consequence: (identifier) alternative: (identifier))))) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (condition_clause value: (number_literal)) (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier))))) (comment) (comment) (declaration type: (primitive_type) declarator: (identifier) declarator: (identifier)) (declaration type: (type_identifier) declarator: (identifier)) initializer: (assignment_expression left: (identifier) right: (number_literal)) condition: (binary_expression left: (identifier) right: (identifier)) update: (update_expression argument: (identifier)) (expression_statement (assignment_expression left: (identifier) right: (binary_expression left: (parenthesized_expression (binary_expression left: (identifier) right: (identifier))) right: (identifier)))) (expression_statement (assignment_expression left: (identifier) right: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier) (identifier))))) (condition_clause value: (binary_expression left: (identifier) right: (number_literal)))),"std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, const std::unordered_set<Network>& networks) const	{	AssertLockHeld(cs);		if (vRandom.empty()) return {};		size_t new_count = nNew;	size_t tried_count = nTried;		if (!networks.empty()) {	new_count = 0;	tried_count = 0;	for (auto& network : networks) {	auto it = m_network_counts.find(network);	if (it == m_network_counts.end()) {	continue;	}	auto counts = it->second;	new_count += counts.n_new;	tried_count += counts.n_tried;	}	}		if (new_only && new_count == 0) return {};	if (new_count + tried_count == 0) return {};		// Decide if we are going to search the new or tried table	// If either option is viable, use a 50% chance to choose	bool search_tried;	if (new_only || tried_count == 0) {	search_tried = false;	} else if (new_count == 0) {	search_tried = true;	} else {	search_tried = insecure_rand.randbool();	}		const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};		// Loop through the addrman table until we find an appropriate entry	double chance_factor = 1.0;	while (1) {	// Pick a bucket, and an initial position in that bucket.	int bucket = insecure_rand.randrange(bucket_count);	int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);		// Iterate over the positions of that bucket, starting at the initial one,	// and looping around.	int i, position;	nid_type node_id;	for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {	position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;	node_id = GetEntry(search_tried, bucket, position);	if (node_id != -1) {",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration type: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)))) declarator: (reference_declarator (identifier))))) body: (compound_statement (comment) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (MISSING ""}""))))",int sum(vector<int>& array_to_sum) { // returning sum of vector passed in by ref	int sum_total = 0;	,0
(translation_unit (comment) (comment) (comment) (preproc_include path: (string_literal (string_content))) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (preproc_include path: (system_lib_string)) (ERROR type: (primitive_type) (function_declarator declarator: (identifier) parameters: (parameter_list)) (comment) (comment) (comment) (comment) (comment) (comment) (comment) (declaration type: (struct_specifier name: (type_identifier)) declarator: (identifier)) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))) right: (number_literal)) right: (binary_expression left: (identifier) right: (identifier)))) consequence: (expression_statement (assignment_expression left: (qualified_identifier scope: (namespace_identifier) name: (identifier)) right: (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (string_literal (string_content)) (identifier)))))) (if_statement condition: (condition_clause value: (binary_expression left: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))) right: (number_literal)) right: (binary_expression left: (identifier) right: (identifier)))) consequence: (expression_statement (assignment_expression left: (qualified_identifier scope: (namespace_identifier) name: (identifier)) right: (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (string_literal (string_content)) (identifier)))))) (condition_clause value: (binary_expression left: (binary_expression left: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))) right: (number_literal)) right: (binary_expression left: (identifier) right: (identifier)))))),"// Copyright (c) 2022 Slack Technologies, Inc.	// Use of this source code is governed by the MIT license that can be	// found in the LICENSE file.		#include ""shell/app/uv_stdio_fix.h""		#include <errno.h>	#include <sys/stat.h>	#include <unistd.h>	#include <cstdio>	#include <tuple>		void FixStdioStreams() {	// libuv may mark stdin/stdout/stderr as close-on-exec, which interferes	// with chromium's subprocess spawning. As a workaround, we detect if these	// streams are closed on startup, and reopen them as /dev/null if necessary.	// Otherwise, an unrelated file descriptor will be assigned as stdout/stderr	// which may cause various errors when attempting to write to them.	//	// For details see https://github.com/libuv/libuv/issues/2062	struct stat st;	if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""r"", stdin);	if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)	std::ignore = freopen(""/dev/null"", ""w"", stdout);	if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (qualified_identifier scope: (namespace_identifier) name: (type_identifier))) declarator: (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (return_statement (false))) (declaration type: (type_identifier) declarator: (identifier)) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (identifier) arguments: (argument_list (identifier) (pointer_expression argument: (identifier)))))) (comment) (condition_clause value: (binary_expression left: (identifier) right: (identifier))))),"bool AddrManImpl::AddSingle(const CAddress& addr, const CNetAddr& source, std::chrono::seconds time_penalty)	{	AssertLockHeld(cs);		if (!addr.IsRoutable())	return false;		nid_type nId;	AddrInfo* pinfo = Find(addr, &nId);		// Do not set a penalty for a source's self-announcement	if (addr == source) {",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (reference_declarator (identifier))) (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))))) body: (compound_statement (comment) (declaration (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (initializer_list (call_expression function: (field_expression argument: (call_expression function: (identifier) arguments: (argument_list)) field: (template_method name: (field_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type))))) arguments: (argument_list))))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (identifier) value: (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content)) (identifier) (identifier))))) (comment) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (type_identifier)) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)) right: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (pointer_declarator declarator: (identifier)) value: (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier) (string_literal (string_content)))))) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier)))) (if_statement condition: (condition_clause value: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content) (escape_sequence)) (identifier) (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (return_statement (false)))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier))))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (return_statement (false)))) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list)))) consequence: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content) (escape_sequence)) (identifier) (call_expression function: (qualified_identifier scope: (namespace_identifier) name: (identifier)) arguments: (argument_list (identifier)))))) (return_statement (false)))) (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list))) (comment) (if_statement condition: (condition_clause value: (unary_expression argument: (call_expression function: (identifier) arguments: (argument_list (identifier) (identifier))))) consequence: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (string_literal (string_content) (escape_sequence)) (identifier)))) (return_statement (false)))) (MISSING ""}""))))","bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)	{	// Generate random temporary filename	const uint16_t randv{FastRandomContext().rand<uint16_t>()};	std::string tmpfn = strprintf(""%s.%04x"", prefix, randv);		// open temp output file	fs::path pathTmp = gArgs.GetDataDirNet() / fs::u8path(tmpfn);	FILE *file = fsbridge::fopen(pathTmp, ""wb"");	AutoFile fileout{file};	if (fileout.IsNull()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to open file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}		// Serialize	if (!SerializeDB(fileout, data)) {	fileout.fclose();	remove(pathTmp);	return false;	}	if (!fileout.Commit()) {	fileout.fclose();	remove(pathTmp);	LogError(""%s: Failed to flush file %s\n"", __func__, fs::PathToString(pathTmp));	return false;	}	fileout.fclose();		// replace existing file, if any, with new file	if (!RenameOver(pathTmp, path)) {	remove(pathTmp);	LogError(""%s: Rename-into-place failed\n"", __func__);	return false;	}	",0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list)) body: (compound_statement (comment) (expression_statement (assignment_expression left: (identifier) right: (number_literal)))))),void setSix(){ // setting global variable	x = 6;	},0
"(translation_unit (function_definition type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (type_identifier))))) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (primitive_type) declarator: (identifier)) (parameter_declaration (type_qualifier) type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (reference_declarator (identifier)))) (type_qualifier)) body: (compound_statement (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (expression_statement (call_expression function: (identifier) arguments: (argument_list))) (MISSING ""}""))))","std::pair<CAddress, NodeSeconds> AddrManImpl::Select(bool new_only, const std::unordered_set<Network>& networks) const	{	LOCK(cs);	Check();",0
(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration (type_qualifier) type: (type_identifier) declarator: (reference_declarator (identifier))) (parameter_declaration type: (type_identifier) declarator: (identifier)))) body: (compound_statement (expression_statement (call_expression function: (field_expression argument: (identifier) field: (field_identifier)) arguments: (argument_list (identifier) (identifier))))))),"void AddrMan::Connected(const CService& addr, NodeSeconds time)	{	m_impl->Connected(addr, time);	}",0
"(translation_unit (function_definition type: (primitive_type) declarator: (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier))))) declarator: (identifier)) (parameter_declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type))))) declarator: (identifier))) (type_qualifier)) body: (compound_statement (MISSING ""}""))))","size_t AddrManImpl::Size_(std::optional<Network> net, std::optional<bool> in_new) const	{",0
(translation_unit (ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier)))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (comment) (comment) (declaration type: (type_identifier) declarator: (init_declarator declarator: (identifier) value: (initializer_list (identifier) (qualified_identifier scope: (namespace_identifier) name: (identifier))))) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)))) arguments: (argument_list (identifier))))) (comment) (comment) (declaration (storage_class_specifier) (type_qualifier) type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (qualified_identifier scope: (namespace_identifier) name: (identifier)))) (expression_statement (binary_expression left: (identifier) right: (call_expression function: (template_function name: (identifier) arguments: (template_argument_list (type_descriptor type: (primitive_type)))) arguments: (argument_list (binary_expression left: (identifier) right: (identifier)))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (binary_expression left: (identifier) right: (parenthesized_expression (binary_expression left: (number_literal) right: (number_literal)))))) (expression_statement (binary_expression left: (identifier) right: (identifier))) (declaration type: (qualified_identifier scope: (namespace_identifier) name: (template_type name: (type_identifier) arguments: (template_argument_list (type_descriptor type: (type_identifier)) (type_descriptor type: (primitive_type))))) declarator: (identifier)) (declaration type: (primitive_type) declarator: (init_declarator declarator: (identifier) value: (number_literal))) (type_qualifier) type: (placeholder_type_specifier (auto)) declarator: (reference_declarator (identifier)) right: (identifier) (expression_statement (assignment_expression left: (subscript_expression argument: (identifier) indices: (subscript_argument_list (field_expression argument: (identifier) field: (field_identifier)))) right: (identifier))) (declaration (type_qualifier) type: (type_identifier) declarator: (init_declarator declarator: (reference_declarator (identifier)) value: (field_expression argument: (identifier) field: (field_identifier)))) (condition_clause value: (field_expression argument: (identifier) field: (field_identifier))) (expression_statement (call_expression function: (identifier) arguments: (argument_list (binary_expression left: (identifier) right: (identifier))))) (comment) (expression_statement (binary_expression left: (identifier) right: (identifier))) (expression_statement (update_expression argument: (identifier))))),"void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.	*   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write	*     (format=5, lowest_compatible=5) and so any versions that do not know how to parse	*     format=5 will not try to read the file.	* * nKey	* * nNew	* * nTried	* * number of ""new"" buckets XOR 2**30	* * all new addresses (total count: nNew)	* * all tried addresses (total count: nTried)	* * for each new bucket:	*   * number of elements	*   * for each element: index in the serialized ""all new addresses""	* * asmap checksum	*	* 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it	* as incompatible. This is necessary because it did not check the version number on	* deserialization.	*	* vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;	* they are instead reconstructed from the other information.	*	* This format is more complex, but significantly smaller (at most 1.5 MiB), and supports	* changes to the ADDRMAN_ parameters without breaking the on-disk structure.	*	* We don't use SERIALIZE_METHODS since the serialization and deserialization code has	* very little in common.	*/		// Always serialize in the latest version (FILE_FORMAT).	ParamsStream s{s_, CAddress::V2_DISK};		s << static_cast<uint8_t>(FILE_FORMAT);		// Increment `lowest_compatible` iff a newly introduced format is incompatible with	// the previous one.	static constexpr uint8_t lowest_compatible = Format::V4_MULTIPORT;	s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);		s << nKey;	s << nNew;	s << nTried;		int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);	s << nUBuckets;	std::unordered_map<nid_type, int> mapUnkIds;	int nIds = 0;	for (const auto& entry : mapInfo) {	mapUnkIds[entry.first] = nIds;	const AddrInfo& info = entry.second;	if (info.nRefCount) {	assert(nIds != nNew); // this means nNew was wrong, oh ow	s << info;	nIds++;",0
"(ERROR type: (primitive_type) (function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier)) parameters: (parameter_list (parameter_declaration type: (type_identifier) declarator: (reference_declarator (identifier)))) (type_qualifier)) (expression_statement (call_expression function: (identifier) arguments: (argument_list (identifier)))) (ERROR) (expression_statement (binary_expression left: (pointer_expression argument: (pointer_expression argument: (pointer_expression argument: (identifier)))) (ERROR (identifier)) right: (pointer_expression argument: (identifier))) (MISSING "";"")) (declaration type: (type_identifier) declarator: (function_declarator declarator: (identifier) parameters: (parameter_list (ERROR (UNEXPECTED '@')) (parameter_declaration type: (type_identifier) (ERROR (UNEXPECTED '`')) declarator: (identifier)) (ERROR (UNEXPECTED '`')))) (MISSING "";"")) (ERROR (pointer_expression argument: (pointer_expression argument: (field_expression argument: (identifier) (ERROR (identifier) (identifier) (identifier) (identifier)) field: (field_identifier)))) (identifier)) (declaration type: (type_identifier) (ERROR (identifier) (identifier) (identifier) (identifier) (identifier)) declarator: (init_declarator declarator: (pointer_declarator (ERROR (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) declarator: (pointer_declarator declarator: (pointer_declarator (ERROR (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) declarator: (identifier)))) value: (number_literal)) (MISSING "";"")) type: (type_identifier) (ERROR (identifier) (identifier)) (init_declarator declarator: (identifier) (ERROR (number_literal)) value: (binary_expression left: (identifier) right: (assignment_expression left: (identifier) (ERROR (identifier) (identifier) (identifier) (number_literal) (identifier) (identifier) (identifier) (identifier) (identifier)) right: (binary_expression left: (number_literal) right: (binary_expression left: (identifier) (ERROR (identifier) (identifier) (identifier)) right: (identifier)))))) (ERROR (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) (ERROR (identifier) (identifier) (identifier) (number_literal) (identifier) (identifier)) declarator: (init_declarator declarator: (pointer_declarator declarator: (parenthesized_declarator (identifier) (MISSING "")""))) value: (number_literal)) declarator: (init_declarator declarator: (identifier) (ERROR (number_literal) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier)) value: (identifier)) (ERROR (identifier) (identifier)) (pointer_declarator declarator: (identifier)) (identifier) (identifier) (identifier) (identifier) (identifier) (identifier))","void AddrManImpl::Serialize(Stream& s_) const	{	LOCK(cs);		/**	* Serialized format.	* * format version byte (@see `Format`)	* * lowest compatible format version byte. This is used to help old software decide	*   whether to parse the file. For example:	*   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is	*     introduced in version N+1 that is compatible with format=3 and it is known that	*     version N will be able to parse it, then version N+1 will write	*     (format=4, lowest_compatible=3) in the first two bytes of the file, and so	*     version N will still try to parse it.",0
